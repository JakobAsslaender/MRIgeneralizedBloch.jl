var documenterSearchIndex = {"docs":
[{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"EditURL = \"https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/master/docs/src/Analyze_NMR_Data.jl\"","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"(Image: ) (Image: )","category":"page"},{"location":"build_literate/Analyze_NMR_Data/#NMR-Data-Analysis","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"The following code replicates the NMR data analysis in Fig. 4, including the full MnCl_2 analysis that is not shown in the paper in the interest of brevity.","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"For this analysis we need the following packages:","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"using MRIgeneralizedBloch\nusing DifferentialEquations\nusing LinearAlgebra\nusing LsqFit\nusing Statistics\nimport Pingouin\nusing Printf\nusing Formatting\nusing Plots\nplotlyjs(bg = RGBA(31/255,36/255,36/255,1.0), ticks=:native);\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"The raw data is stored in a separate github repository and the following functions return the URL to the individual files:","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"MnCl2_data(TRF_scale) = string(\"https://github.com/JakobAsslaender/MRIgeneralizedBloch_NMRData/blob/main/20210419_1mM_MnCl2/ja_IR_v2%20(\", TRF_scale, \")/1/data.2d?raw=true\")\nBSA_data(TRF_scale)   = string(\"https://github.com/JakobAsslaender/MRIgeneralizedBloch_NMRData/blob/main/20210416_15%25BSA_2ndBatch/ja_IR_v2%20(\", TRF_scale, \")/1/data.2d?raw=true\");\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"which can be loaded with functions implemented in this file:","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"include(string(pathof(MRIgeneralizedBloch), \"/../../docs/src/load_NMR_data.jl\"));\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_Data/#MnCl_2-Probe","page":"NMR Data Analysis","title":"MnCl_2 Probe","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_Data/#T_2{*,f}-Estimation","page":"NMR Data Analysis","title":"T_2^*f Estimation","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"We estimate T_2^*f by fitting a mono-exponential decay curve to the FID of the acquisition with T_textRF = 228μs and T_texti = 5s.","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"M = load_Data(MnCl2_data(1))\nM = M[:,1]; # select Ti = 5s\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"The data was measured at the following time points in units of seconds:","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"T_dwell = 100e-6 # s\nTE = T_dwell * ((1:length(M)) .+ 7) # s","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"Note that the signal is an FID, so the phrase echo time is a bit misleading.","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"The function curve_fit from the LsqFit.jl package is only implemented for real-valued models. To accommodate this, we need to split the data into its real and imaginary part:","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"TEreal = [TE;TE]\nMreal = [real(M);imag(M)];\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"Here, we are using a simple mono-exponential model with a complex-valued scaling factor p[1] + 1im p[2], the decay time T_2^*f = p[3], and the Larmor frequency p[4]:","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"FID_model(t, p) = @. [p[1] * exp(- t[1:end ÷ 2] / p[3]) * cos(p[4] * t[1:end ÷ 2]); p[2] * exp(- t[end ÷ 2 + 1:end] / p[3]) * sin(p[4] * t[end ÷ 2 + 1:end])];\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"Fitting this model to the NMR data estimates T_2^*f:","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"fit = curve_fit(FID_model, TEreal, Mreal, [1, 1, 0.1, 0])\nT2star_MnCl2 = fit.param[3] # s","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"seconds and its uncertainty (also in units of seconds)","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"stderror(fit)[3] # s","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"Visually, the plot and the data show good agreement:","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"Mfitted = FID_model(TEreal, fit.param)\nMfitted = Mfitted[1:end÷2] + 1im * Mfitted[end÷2+1:end]\np = plot(xlabel=\"TE [s]\", ylabel=\"|FID(TE)| [a.u.]\")\nplot!(p, TE, abs.(M), label=\"data\")\nplot!(p, TE, abs.(Mfitted), label=@sprintf(\"fit with T2* = %2.3f ms\", 1e3 * T2star_MnCl2))\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"The relative residual norm of the fit, i.e. residual_2M_2 is","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"norm(fit.resid) / norm(M)","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"Despite its small ell_2-norm, the Shapiro-Wilk test indicates that the residual is not Gaussian or normal distributed at a significance level of α=0.05","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"Pingouin.normality(fit.resid, α=0.05)","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"We note that mono-exponential T_2^* decays assume a Lorentzian distributed magnetic field, which is in general an assumption rather than a well-founded theory.","category":"page"},{"location":"build_literate/Analyze_NMR_Data/#Mono-Exponential-IR-Model","page":"NMR Data Analysis","title":"Mono-Exponential IR Model","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"We performed several experiments in which we inverted the thermal equilibrium magnetization with rectangular π-pulses with the following pulse durations (in seconds):","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"TRFmin = 22.8e-6 # s - shortest TRF possible on the NMR\nTRF_scale = [1;2;5:5:40] # scaling factor\nTRF = TRF_scale * TRFmin # s","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"and acquired inversion recovery data at exponentially spaced inversion times (in seconds):","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"Ti = exp.(range(log(3e-3), log(5), length=20)) # s\nTi .+= 12 * TRFmin + (13 * 15.065 - 5) * 1e-6 # s - correction factors","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"We calculate the Rabi frequencies of the RF pulses and a finer grid of T_texti to plot the IR model:","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"ω1 = π ./ TRF # rad/s\nTIplot = exp.(range(log(Ti[1]), log(Ti[end]), length=500)); # s\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"After loading and normalizing the data","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"M = zeros(Float64, length(Ti), length(TRF_scale))\nfor i = 1:length(TRF_scale)\n    M[:,i] = load_spectral_integral(MnCl2_data(TRF_scale[i]))\nend\nM ./= maximum(M);\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"we analyze each inversion recovery curve that corresponds to a different T_textRF separately. This allows us to fit a simple mono-exponential model","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"standard_IR_model(t, p) = @. p[1] - p[3] * exp(- t * p[2]);\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"where p[1] is the thermal equilibrium magnetization, p[2] = T_1, and p[1] - p[3] is the magnetization right after the inversion pulse or, equivalently, Minv = p[1] / p[3] - 1 is the inversion efficiency, which is 1 for an ideal π-pulse and smaller otherwise. The parameters are initialized with","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"p0 = [1.0, 1.0, 2.0];\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"and we can loop over T_textRF to perform the fits:","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"R1 = similar(M[1,:])\nresidual = similar(R1)\np = plot(xlabel=\"Ti [s]\", ylabel=\"zf(TRF, Ti) [a.u.]\")\nfor i = 1:length(TRF_scale)\n    Mi = @view M[:,i]\n\n    fit = curve_fit(standard_IR_model, Ti, Mi, p0)\n\n    R1[i] = fit.param[2]\n    Minv = fit.param[3] / fit.param[1] - 1\n\n    residual[i] = norm(fit.resid) / norm(Mi)\n\n    scatter!(p, Ti, Mi, label=@sprintf(\"TRF = %1.2es - data\", TRF[i]), color=i)\n    plot!(p, TIplot, standard_IR_model(TIplot, fit.param), label=@sprintf(\"fit with R1 = %.3f/s; MInv = %.3f\", R1[i], Minv), color=i)\nend\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"Here, the data measured with different T_textRF are indicated by markers in different colors, and the corresponding fits are the line plots in the same color. The fitted parameters are denoted in the legend and the mean value of all R1 estimates is","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"mean(R1) # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"1/s and its standard deviation in units of 1/s is","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"std(R1) # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"The relative residual norm of the fits is on average","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"mean(residual)","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"Further, we cannot reject the null hypothesis that the estimated R1 values are Gaussian distributed:","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"Pingouin.normality(R1, α=0.05)","category":"page"},{"location":"build_literate/Analyze_NMR_Data/#Global-IR-fit","page":"NMR Data Analysis","title":"Global IR fit","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"As an alternative to individual fits to the inversion recovery curves with different T_textRF, we can also perform a global fit that accounts for the T_2^*f decay during the inversion pulse. The model first simulates the T_2^*f decay during the inversion pulse, followed by T_1 recovery:","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"function Bloch_IR_model(p, TRF, Ti, T2)\n    (m0, m0_inv, R1) = p\n    R2 = 1 / T2\n\n    M = zeros(Float64, length(Ti), length(TRF))\n    for i = 1:length(TRF)\n        # simulate inversion pulse\n        ω1 = π / TRF[i]\n        H = [-R2 -ω1  0;\n              ω1 -R1 R1;\n               0   0  0]\n\n        m_inv = m0_inv * (exp(H * TRF[i]) * [0,1,1])[2]\n\n        # simulate T1 recovery\n        H = [-R1 R1 * m0;\n               0       0]\n\n        for j = 1:length(Ti)\n            M[j,i] = m0 * (exp(H .* (Ti[j] - TRF[i] / 2)) * [m_inv,1])[1]\n        end\n    end\n    return vec(M)\nend;\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"We use the previously estimated T_2^*f value for the fit:","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"fit = curve_fit((x, p) -> Bloch_IR_model(p, TRF, Ti, T2star_MnCl2), 1:length(M), vec(M), [ 1, .8, 1])\n\np = plot(xlabel=\"Ti [s]\", ylabel=\"zf(TRF, Ti) [a.u.]\")\nfor i=1:length(TRF)\n    scatter!(p, Ti, M[:,i], label=@sprintf(\"TRF = %1.2es\", TRF[i]), color=i)\n    plot!(p, TIplot, Bloch_IR_model(fit.param, TRF[i], TIplot, T2star_MnCl2), label=@sprintf(\"TRF = %1.2es\", TRF[i]), color=i)\nend\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"With this global fit, we get a very similar relaxation rate in units of 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"R1_MnCl2 = fit.param[3] # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"with an uncertainty (also in units of 1/s) of","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"stderror(fit)[3] # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"Note that the relative residual norm is somewhat increased compared to individual fits to each inversion recovery curve:","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"norm(fit.resid) / norm(M)","category":"page"},{"location":"build_literate/Analyze_NMR_Data/#Bovine-Serum-Albumin-Probe","page":"NMR Data Analysis","title":"Bovine Serum Albumin Probe","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_Data/#T_2{*,f}-Estimation-2","page":"NMR Data Analysis","title":"T_2^*f Estimation","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"We repeat the T_2^*f estimation for the bovine serum albumin (BSA) probe by fitting a mono-exponential decay curve to the FID of the acquisition with T_textRF = 228μs and T_texti = 5s.","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"M = load_Data(BSA_data(1));\nM = M[:,1] # select Ti = 5s\nMreal = [real(M);imag(M)]\n\nfit = curve_fit(FID_model, TEreal, Mreal, [1.0, 1.0, .1, 0.0]);\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"The estimated T_2^*f of the BSA probe is","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"T2star_BSA = fit.param[3] # s","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"seconds with an uncertainty of","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"stderror(fit)[3] # s","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"seconds.","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"Visually, the plot and the data align well for the BSA probe, too:","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"Mfitted = FID_model(TEreal, fit.param)\nMfitted = Mfitted[1:end÷2] + 1im * Mfitted[end÷2+1:end]\np = plot(xlabel=\"TE [s]\", ylabel=\"|FID(TE)| [a.u.]\")\nplot!(p, TE, abs.(M), label=\"data\")\nplot!(p, TE, abs.(Mfitted), label=@sprintf(\"fit with T2* = %2.3f ms\", 1e3 * T2star_BSA))\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"The relative residual norm (residual_2M_2) is","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"norm(fit.resid) / norm(M)","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"Despite the small residual, the Shapiro-Wilk test indicates that the residual is not normal distributed for this probe either:","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"Pingouin.normality(fit.resid, α=0.05)","category":"page"},{"location":"build_literate/Analyze_NMR_Data/#Mono-Exponential-IR-Model-2","page":"NMR Data Analysis","title":"Mono-Exponential IR Model","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"We also fit a mono-exponential model to each inversion recovery curve of the BSA data:","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"M = zeros(Float64, length(Ti), length(TRF_scale))\nfor i = 1:length(TRF_scale)\n    M[:,i] = load_spectral_integral(BSA_data(TRF_scale[i]))\nend\nM ./= maximum(M)\n\nR1 = similar(M[1,:])\nresidual = similar(R1)\np = plot(xlabel=\"Ti [s]\", ylabel=\"zf(TRF, Ti) [a.u.]\")\nfor i = 1:length(TRF_scale)\n    Mi = @view M[:,i]\n\n    fit = curve_fit(standard_IR_model, Ti, Mi, p0)\n\n    R1[i] = fit.param[2]\n    Minv = fit.param[3] / fit.param[1] - 1\n\n    residual[i] = norm(fit.resid) / norm(Mi)\n\n    scatter!(p, Ti, Mi, label=@sprintf(\"TRF = %1.2es - data\", TRF[i]), color=i)\n    plot!(p, TIplot, standard_IR_model(TIplot, fit.param), label=@sprintf(\"fit with R1 = %.3f/s; MInv = %.3f\", R1[i], Minv), color=i)\nend\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"Zooming into early phase of the recovery curve reveals the poor fit quality, in particular for long T_textRF. This is also reflected by a substantially larger relative residual norm compared to the MnCl_2 probe:","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"mean(residual)","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"The mean of all R1 fits in units of 1/s is","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"mean(R1) # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"and its standard deviation is substantially larger compared to the same fit of the MnCl_2 probe:","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"std(R1) # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"In contrast to the MnCl_2 probe, we can reject the null hypothesis that the R1 rates, estimated with a mono-exponential model from the BSA probe with different T_textRF, are Gaussian distributed:","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"Pingouin.normality(R1, α=0.05)","category":"page"},{"location":"build_literate/Analyze_NMR_Data/#Global-IR-Fit-Generalized-Bloch-Model","page":"NMR Data Analysis","title":"Global IR Fit - Generalized Bloch Model","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"In order to repeat the global fit that includes all T_textRF values, we have to account for the spin dynamics in the semi-solid pool during the RF-pulse. First, we do this with the proposed generalized Bloch model:","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"function gBloch_IR_model(p, G, TRF, TI, R2f)\n    (m0, m0f_inv, m0s, R1, T2s, Rx) = p\n    m0f = 1 - m0s\n    ω1 = π ./ TRF\n\n    m0vec = [0, 0, m0f, m0s, 1]\n    m_fun(p, t; idxs=nothing) = typeof(idxs) <: Number ? 0.0 : zeros(5)\n\n\n    H = [-R1 - m0s * Rx       m0f * Rx R1 * m0f;\n               m0s * Rx -R1 - m0f * Rx R1 * m0s;\n         0              0              0       ]\n\n    M = zeros(Float64, length(TI), length(TRF))\n    for i = 1:length(TRF)\n        m = solve(DDEProblem(apply_hamiltonian_gbloch!, m0vec, m_fun, (0.0, TRF[i]), (ω1[i], 1, 0, m0s, R1, R2f, T2s, Rx, G)))[end]\n\n        for j = 1:length(TI)\n            M[j,i] = m0 * (exp(H .* (TI[j] - TRF[i] / 2)) * [m0f_inv * m[3],m[4],1])[1]\n        end\n    end\n    return vec(M)\nend;\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"Here, we use assume a super-Lorentzian lineshape, whose Green's function is interpolated to speed up the fitting routine:","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"T2s_min = 5e-6 # s\nG_superLorentzian = interpolate_greens_function(greens_superlorentzian, 0, maximum(TRF)/T2s_min);\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"The fit is initialized with p0 = [m0, m0f_inv, m0_s, R1, T2_s, Rx] and set some reasonable bounds to the fitted parameters:","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"p0   = [  1, 0.932,  0.1,   1, 10e-6, 50];\npmin = [  0, 0.100,   .0, 0.3,  1e-9, 10];\npmax = [Inf,   Inf,  1.0, Inf, 20e-6,1e3];\n\nfit = curve_fit((x, p) -> gBloch_IR_model(p, G_superLorentzian, TRF, Ti, 1/T2star_BSA), [], vec(M), p0, lower=pmin, upper=pmax);\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"Visually, the plot and the data align well:","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"p = plot(xlabel=\"Ti [s]\", ylabel=\"zf(TRF, Ti) [a.u.]\")\nfor i=1:length(TRF)\n    scatter!(p, Ti, M[:,i], label=@sprintf(\"TRF = %1.2es\", TRF[i]), color=i)\n    plot!(p, TIplot, gBloch_IR_model(fit.param, G_superLorentzian, TRF[i], TIplot, 1/T2star_BSA), label=@sprintf(\"TRF = %1.2es\", TRF[i]), color=i)\nend\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"which becomes particularly apparent when zooming into the beginning of the inversion recovery curves. Further, the relative residual norm is much smaller compared to the mono-exponential fit:","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"norm(fit.resid) / norm(M)","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"The estimated parameters are","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"m0 = fit.param[1]","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"Minv = fit.param[2]","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"m0s = fit.param[3]","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"R1 = fit.param[4] # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"T2s = 1e6fit.param[5] # μs","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"Rx = fit.param[6] # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_Data/#Global-IR-Fit-Graham's-Single-Frequency-Approximation","page":"NMR Data Analysis","title":"Global IR Fit - Graham's Single Frequency Approximation","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"For comparison, we repeat the same fit with Graham's single frequency approximation:","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"function Graham_IR_model(p, TRF, TI, R2f)\n    (m0, m0f_inv, m0s, R1, T2s, Rx) = p\n    m0f = 1 - m0s\n    ω1 = π ./ TRF\n\n    m0vec = [0, 0, m0f, m0s, 1]\n\n    H = [-R1 - m0s * Rx       m0f * Rx R1 * m0f;\n               m0s * Rx -R1 - m0f * Rx R1 * m0s;\n         0              0              0       ]\n\n    M = zeros(Float64, length(TI), length(TRF))\n    for i = 1:length(TRF)\n        m = solve(ODEProblem(apply_hamiltonian_graham_superlorentzian!, m0vec, (0.0, TRF[i]), (ω1[i], 1, 0, TRF[i], m0s, R1, R2f, T2s, Rx)))[end]\n\n        for j = 1:length(TI)\n            M[j,i] = m0 * (exp(H .* (TI[j] - TRF[i] / 2)) * [m0f_inv * m[3],m[4],1])[1]\n        end\n    end\n    return vec(M)\nend;\n\nfit = curve_fit((x, p) -> Graham_IR_model(p, TRF, Ti, 1/T2star_BSA), [], vec(M), p0, lower=pmin, upper=pmax);\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"Visually, the plot and the data align substantially worse:","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"p = plot(xlabel=\"Ti [s]\", ylabel=\"zf(TRF, Ti) [a.u.]\")\nfor i=1:length(TRF)\n    scatter!(p, Ti, M[:,i], label=@sprintf(\"TRF = %1.2es\", TRF[i]), color=i)\n    plot!(p, TIplot, Graham_IR_model(fit.param, TRF[i], TIplot, 1/T2star_BSA), label=@sprintf(\"TRF = %1.2es\", TRF[i]), color=i)\nend\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"which becomes particularly apparent when zooming into the beginning of the inversion recovery curves. Further, the relative residual norm is much larger compared to the generalized Bloch fit:","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"norm(fit.resid) / norm(M)","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"The estimated parameters are","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"m0 = fit.param[1]","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"Minv = fit.param[2]","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"m0s = fit.param[3]","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"R1 = fit.param[4] # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"T2s = 1e6fit.param[5] # μs","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"Rx = fit.param[6] # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_Data/#Global-IR-Fit-Sled's-Model","page":"NMR Data Analysis","title":"Global IR Fit - Sled's Model","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"We also performed the fit with Sled's model:","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"function Sled_IR_model(p, G, TRF, TI, R2f)\n    (m0, m0f_inv, m0s, R1, T2s, Rx) = p\n    m0f = 1 - m0s\n    ω1 = π ./ TRF\n\n    m0vec = [0, 0, m0f, m0s, 1]\n\n    H = [-R1 - m0s * Rx       m0f * Rx R1 * m0f;\n               m0s * Rx -R1 - m0f * Rx R1 * m0s;\n         0              0              0       ]\n\n    M = zeros(Float64, length(TI), length(TRF))\n    for i = 1:length(TRF)\n        m = solve(ODEProblem(apply_hamiltonian_sled!, m0vec, (0.0, TRF[i]), (ω1[i], 1, 0, m0s, R1, R2f, T2s, Rx, G)))[end]\n\n        for j = 1:length(TI)\n            M[j,i] = m0 * (exp(H .* (TI[j] - TRF[i] / 2)) * [m0f_inv * m[3],m[4],1])[1]\n        end\n    end\n    return vec(M)\nend;\n\nfit = curve_fit((x, p) -> Sled_IR_model(p, G_superLorentzian, TRF, Ti, 1/T2star_BSA), [], vec(M), p0, lower=pmin, upper=pmax);\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"Visually, the plot and the data do align well either:","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"p = plot(xlabel=\"Ti [s]\", ylabel=\"zf(TRF, Ti) [a.u.]\")\nfor i=1:length(TRF)\n    scatter!(p, Ti, M[:,i], label=@sprintf(\"TRF = %1.2es\", TRF[i]), color=i)\n    plot!(p, TIplot, Sled_IR_model(fit.param, G_superLorentzian, TRF[i], TIplot, 1/T2star_BSA), label=@sprintf(\"TRF = %1.2es\", TRF[i]), color=i)\nend\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"which becomes particularly apparent when zooming into the beginning of the inversion recovery curves. Further, the relative residual norm is also large compared to the generalized Bloch fit:","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"norm(fit.resid) / norm(M)","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"The estimated parameters are","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"m0 = fit.param[1]","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"Minv = fit.param[2]","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"m0s = fit.param[3]","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"R1 = fit.param[4] # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"T2s = 1e6fit.param[5] # μs","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"Rx = fit.param[6] # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"","category":"page"},{"location":"build_literate/Analyze_NMR_Data/","page":"NMR Data Analysis","title":"NMR Data Analysis","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Author = \"Jakob Assländer\"\nCurrentModule = MRIgeneralizedBloch","category":"page"},{"location":"api/#MRIgeneralizedBloch.jl","page":"API","title":"MRIgeneralizedBloch.jl","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Documentation for MRIgeneralizedBloch.jl.","category":"page"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [MRIgeneralizedBloch]","category":"page"},{"location":"api/#MRIgeneralizedBloch.apply_hamiltonian_gbloch!-Tuple{Any, Any, Any, NTuple{10, Any}, Any}","page":"API","title":"MRIgeneralizedBloch.apply_hamiltonian_gbloch!","text":"apply_hamiltonian_gbloch!(∂m∂t, m, h, p, t)\n\nApply the generalized Bloch Hamiltonian to m and write the resulting derivative wrt. time into ∂m∂t.\n\nArguemnts\n\n∂m∂t::Vector{<:Number}: Vector describing to derivative of m wrt. time; this vector has to be of the same size as m, but can contain any value, which is replaced by H * m\nm::Vector{<:Number}: Vector the spin ensemble state of the form [xf, yf, zf, zs, 1] if now gradient is calculated or of the form [xf, yf, zf, zs, 1, ∂xf/∂θ1, ∂yf/∂θ1, ∂zf/∂θ1, ∂zs/∂θ1, 0, ..., ∂xf/∂θn, ∂yf/∂θn, ∂zf/∂θn, ∂zs/∂θn, 0] if n derivatives wrt. θn are calculated\nh: History fuction; can be initialized with h(p, t; idxs=nothing) = typeof(idxs) <: Number ? 0.0 : zeros(5n + 5) for n gradients, and is then updated by the delay differential equation solvers\np::NTuple{9,10, or 11, Any}: (ω1, B1, ω0, m0s, R1, R2f, T2s, Rx, g), with    -ω1::Number: Rabi frequency in rad/s (rotation about the y-axis)   -B1::Number: B1 scaling normalized so that B1=1 corresponds to a perfectly calibrated RF field   -ω0::Number: Larmor or off-resonance frequency in rad/s   -m0s::Number: Fractional semi-solid spin pool size in the range of 0 to 1   -R1::Number: Apparent longitudinal spin relaxation rate of both pools in 1/seconds   -R2f::Number: Trasversal spin relaxation rate of the free pool in 1/seconds   -T2s::Number: Trasversal spin relaxation time of the semi-solid pool in seconds   -Rx::Number: Exchange rate between the two pools in 1/seconds   -g::Function: Green's function of the form G(κ) = G((t-τ)/T2s)   or (ω1, B1, ω0, m0s, R1, R2f, T2s, Rx, zs_idx, g) with\nzs_idx::Integer: Index to be used history function to be used in the Green's function; Default is 4 (zs), and for derivatives 9, 14, ... are used\nor (ω1, B1, ω0, m0s, R1, R2f, T2s, Rx, g, dG_o_dT2s_x_T2s, grad_list) with\ndG_o_dT2s_x_T2s::Function: Derivative of the Green's function wrt. T2s, multiplied by T2s; of the form dG_o_dT2s_x_T2s(κ) = dG_o_dT2s_x_T2s((t-τ)/T2s)\ngrad_list::Vector{<:grad_param}: List of gradients to be calucualted; any subset of [grad_m0s(), grad_R1(), grad_R2f(), grad_Rx(), grad_T2s(), grad_ω0(), grad_B1()]; length of the vector must be n (cf. arguments m and ∂m∂t)\nt::Number: Time in seconds\n\nOptional:\n\npulsetype=:normal: Use default for a regular RF-pulse; the option pulsetype=:inversion should be handled with care as it is only inteded to calculate the saturation of the semi-solid pool and its derivative. \n\nExamples\n\njulia> using DifferentialEquations\n\njulia> α = π/2;\n\njulia> TRF = 100e-6;\n\njulia> ω1 = α/TRF;\n\njulia> B1 = 1;\n\njulia> ω0 = 0;\n\njulia> m0s = 0.1;\n\njulia> R1 = 1;\n\njulia> R2f = 15;\n\njulia> T2s = 10e-6;\n\njulia> Rx = 30;\n\njulia> G = interpolate_greens_function(greens_superlorentzian, 0, TRF / T2s);\n\n\njulia> u0 = [0; 0; 1-m0s; m0s; 1];\n\njulia> h(p, t; idxs=nothing) = typeof(idxs) <: Number ? 0.0 : zeros(5);\n\njulia> sol = solve(DDEProblem(apply_hamiltonian_gbloch!, u0, h, (0, TRF), (ω1, B1, ω0, m0s, R1, R2f, T2s, Rx, G)), MethodOfSteps(DP8()))\nretcode: Success\nInterpolation: specialized 7th order interpolation\nt: 6-element Vector{Float64}:\n 0.0\n 1.220281289257312e-7\n 8.541969024801185e-7\n 5.247209543806443e-6\n 3.160528539176439e-5\n 0.0001\nu: 6-element Vector{Vector{Float64}}:\n [0.0, 0.0, 0.9, 0.1, 1.0]\n [0.0017251293948764097, 0.0, 0.8999983466235149, 0.09999981629184612, 1.0]\n [0.012075484505676845, 0.0, 0.8999189860592341, 0.09999099950691269, 1.0]\n [0.07409379835118453, 0.0, 0.8969447198086778, 0.09966205538313169, 1.0]\n [0.42857865289497454, 0.0, 0.7913675966569867, 0.08937976862223226, 1.0]\n [0.8993472985166022, 0.0, 0.0004869430378807708, 0.04106841741188661, 1.0]\n\njulia> using Plots\n\njulia> plot(sol, labels=[\"xf\" \"yf\" \"zf\" \"zs\" \"1\"], xlabel=\"t (s)\", ylabel=\"m(t)\");\n\n\njulia> dG_o_dT2s_x_T2s = interpolate_greens_function(dG_o_dT2s_x_T2s_superlorentzian, 0, TRF / T2s);\n\n\njulia> grad_list = [grad_R2f(), grad_m0s()];\n\n\njulia> u0 = [0; 0; 1-m0s; m0s; 1; zeros(5*length(grad_list))];\n\n\njulia> h(p, t; idxs=nothing) = typeof(idxs) <: Number ? 0.0 : zeros(5 + 5*length(grad_list));\n\njulia> sol = solve(DDEProblem(apply_hamiltonian_gbloch!, u0, h, (0, TRF), (ω1, B1, ω0, m0s, R1, R2f, T2s, Rx, G, dG_o_dT2s_x_T2s, grad_list)), MethodOfSteps(DP8()));\n\n\njulia> plot(sol);\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.apply_hamiltonian_sled!-Tuple{Any, Any, NTuple{6, Any}, Any}","page":"API","title":"MRIgeneralizedBloch.apply_hamiltonian_sled!","text":"apply_hamiltonian_sled!(∂m∂t, m, p, t)\n\nApply Sled's Hamiltonian to m and write the resulting derivative wrt. time into ∂m∂t.\n\nArguemnts\n\n∂m∂t::Vector{<:Number}: Vector of length 1 describing to derivative of m wrt. time; this vector can contain any value, which is replaced by H * m\nm::Vector{<:Number}: Vector of length 1 describing the zs magnetization\np::NTuple{6 or 9, Any}: (ω1, B1, ω0, R1, T2s, g) for a simulating an isolated semi-solid pool or (ω1, B1, ω0, m0s, R1, R2f, T2s, Rx, g) for simulating a coupled spin system; with    -ω1::Number: Rabi frequency in rad/s (rotation about the y-axis)   -B1::Number: B1 scaling normalized so that B1=1 corresponds to a perfectly calibrated RF field   -ω0::Number: Larmor or off-resonance frequency in rad/s   -R1::Number: Longitudinal spin relaxation rate in 1/seconds   -R2f::Number: Trasversal spin relaxation rate of the free pool in 1/seconds   -T2s::Number: Trasversal spin relaxation time in seconds   -Rx::Number: Exchange rate between the two pools in 1/seconds   -g::Function: Green's function of the form G(κ) = G((t-τ)/T2s)\nt::Number: Time in seconds\n\nExamples\n\njulia> using DifferentialEquations\n\njulia> α = π/2;\n\njulia> TRF = 100e-6;\n\njulia> ω1 = α/TRF;\n\njulia> B1 = 1;\n\njulia> ω0 = 0;\n\njulia> R1 = 1;\n\njulia> T2s = 10e-6;\n\njulia> G = interpolate_greens_function(greens_superlorentzian, 0, TRF / T2s);\n\njulia> m0 = [1];\n\njulia> sol = solve(ODEProblem(apply_hamiltonian_sled!, m0, (0, TRF), (ω1, 1, ω0, R1, T2s, G)), Tsit5())\nretcode: Success\nInterpolation: specialized 4th order \"free\" interpolation\nt: 3-element Vector{Float64}:\n 0.0\n 7.475658194333419e-5\n 0.0001\nu: 3-element Vector{Vector{Float64}}:\n [1.0]\n [0.6313685535188782]\n [0.4895191983659201]\n\njulia> using Plots\n\njulia> plot(sol, labels=[\"zs\"], xlabel=\"t (s)\", ylabel=\"m(t)\");\n\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.calculatesignal_gbloch_ide-NTuple{10, Any}","page":"API","title":"MRIgeneralizedBloch.calculatesignal_gbloch_ide","text":"calculatesignal_gbloch_ide(α, TRF, TR, ω0, B1, m0s, R1, R2f, Rx, T2s[; grad_list, Ncyc=2, output=:complexsignal])\n\nCalculate the signal or magnetixation evolution with the full generalized Bloch model assuming a super-Lorentzian lineshape (slow).\n\nThe simulation assumes a sequence of rectangluar RF-pulses with varying flip angles α and RF-pulse durations TRF, but a fixed repetition time TR. Further, it assumes balanced gradient moments. \n\nArguemnts\n\nα::Vector{<:Number}: Array of flip angles in radians\nTRF::Vector{<:Number}: Array of the RF-pulse durations in seconds\nTR::Number: Repetition time in seconds\nω0::Number: Off-resonance frequency in rad/s \nB1::Number: Normalized transmit B1 field, i.e. B1 = 1 corresponds to a well-calibrated B1 field\nm0s::Number: Fractional size of the semi-solid pool; should be in range of 0 to 1\nR1::Number: Apparent longitudinal relaxation rate of the free and semi-solid pool in 1/seconds\nR2f::Number: Transversal relaxation rate of the free pool in 1/seconds\nRx::Number: Exchange rate between the two spin pools in 1/seconds\nT2s::Number: Transversal relaxationt time of the semi-solid pool in seconds\n\nOptional:\n\ngrad_list=[]: Vector to indicate which gradients should be calculated; the vector can either be empty [] for no gradient, or contain any subset/order of grad_list=[grad_m0s(), grad_R1(), grad_R2f(), grad_Rx(), grad_T2s(), grad_ω0(), grad_B1()]\nNcyc=2: The magnetization is initialized with thermal equilibrium and then performed Ncyc times and only the last cycle is stored. The default value is usually a good approximation for antiperiodic boundary conditions. Increase the number for higher precision at the cost of computation time. \noutput=:complexsignal: The defaul keywords triggers the function to output a complex-valued signal (xf + 1im yf); the keyword output=:realmagnetization triggers an output of the entire (real valued) vector [xf, yf, zf, xs, zs]\ngreens=(greens_superlorentzian, dG_o_dT2s_x_T2s_superlorentzian): Tuple of a Greens function G(κ) = G((t-τ)/T2s) and its partial derivative wrt. T2s, multiplied by T2s ∂G((t-τ)/T2s)/∂T2s * T2s. This package supplies the three Greens functions greens=(greens_superlorentzian, dG_o_dT2s_x_T2s_superlorentzian) (default), greens=(greens_lorentzian, dG_o_dT2s_x_T2s_lorentzian), and greens=(greens_gaussian, dG_o_dT2s_x_T2s_gaussian)\n\nExamples\n\njulia> calculatesignal_gbloch_ide(ones(100)*π/2, ones(100)*5e-4, 4e-3, 0, 1, 0.1, 1, 15, 30, 10e-6)\n100×1 Matrix{ComplexF64}:\n -0.024657762441422173 + 0.0im\n 0.0037348678313655374 - 0.0im\n -0.019057736703007203 + 0.0im\n  0.007146413346758786 - 0.0im\n -0.013913423956595965 + 0.0im\n  0.010291046549792262 - 0.0im\n -0.009153866378612974 + 0.0im\n  0.013213045210360628 - 0.0im\n -0.004734258510785933 + 0.0im\n   0.01593906991792926 - 0.0im\n                       ⋮\n  0.053218511651564396 - 0.0im\n   0.05261662009092078 + 0.0im\n   0.05338787446252438 - 0.0im\n     0.052832959843115 + 0.0im\n  0.053546314408472656 - 0.0im\n   0.05303472239762076 + 0.0im\n  0.053694532633733943 - 0.0im\n   0.05322289238188523 + 0.0im\n  0.053833185535691296 - 0.0im\n\njulia> calculatesignal_gbloch_ide(ones(100)*π/2, ones(100)*5e-4, 4e-3, 0, 1, 0.1, 1, 15, 30, 10e-6; grad_list=[grad_R1(), grad_T2s()], output=:realmagnetization)\n100×15 transpose(::Matrix{Float64}) with eltype Float64:\n -0.0246575    0.0   0.00191834  …   0.0    -8.09518  -146.358   0.0\n  0.00373479  -0.0  -0.0217727      -0.0    83.521    -135.807   0.0\n -0.0190576    0.0   0.00549726      0.0   -21.4616   -119.477   0.0\n  0.00714631  -0.0  -0.0164074      -0.0    64.4139   -106.11    0.0\n -0.0139133    0.0   0.0087715       0.0   -30.9968    -92.3956  0.0\n  0.0102909   -0.0  -0.0114604   …  -0.0    49.4596    -83.7202  0.0\n -0.00915379   0.0   0.0118022       0.0   -37.5344    -75.2901  0.0\n  0.0132129   -0.0  -0.00687472     -0.0    37.423     -71.2706  0.0\n -0.00473424   0.0   0.0146242       0.0   -42.288     -66.9254  0.0\n  0.0159389   -0.0  -0.00261256     -0.0    27.1804    -66.0774  0.0\n  ⋮                              ⋱\n  0.0532167   -0.0   0.0525262      -0.0  -206.85     -155.403   0.0\n  0.0526148    0.0   0.0533279       0.0  -210.517    -155.62    0.0\n  0.053386    -0.0   0.0527502      -0.0  -209.167    -155.899   0.0\n  0.0528312    0.0   0.0534917       0.0  -212.584    -156.103   0.0\n  0.0535445   -0.0   0.052959    …  -0.0  -211.372    -156.364   0.0\n  0.0530329    0.0   0.0536449       0.0  -214.557    -156.555   0.0\n  0.0536927   -0.0   0.0531539      -0.0  -213.471    -156.799   0.0\n  0.053221     0.0   0.0537883       0.0  -216.439    -156.979   0.0\n  0.0538313   -0.0   0.0533355      -0.0  -215.468    -157.207   0.0\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.calculatesignal_graham_ode-NTuple{10, Any}","page":"API","title":"MRIgeneralizedBloch.calculatesignal_graham_ode","text":"calculatesignal_graham_ode(α, TRF, TR, ω0, B1, m0s, R1, R2f, Rx, T2s[; grad_list, Ncyc=2, output=:complexsignal])\n\nCalculate the signal or magnetixation evolution with Graham's spectral model assuming a super-Lorentzian lineshape.\n\nThe simulation assumes a sequence of rectangluar RF-pulses with varying flip angles α and RF-pulse durations TRF, but a fixed repetition time TR. Further, it assumes balanced gradient moments. \n\nArguemnts\n\nα::Vector{<:Number}: Array of flip angles in radians\nTRF::Vector{<:Number}: Array of the RF-pulse durations in seconds\nTR::Number: Repetition time in seconds\nω0::Number: Off-resonance frequency in rad/s \nB1::Number: Normalized transmit B1 field, i.e. B1 = 1 corresponds to a well-calibrated B1 field\nm0s::Number: Fractional size of the semi-solid pool; should be in range of 0 to 1\nR1::Number: Apparent longitudinal relaxation rate of the free and semi-solid pool in 1/seconds\nR2f::Number: Transversal relaxation rate of the free pool in 1/seconds\nRx::Number: Exchange rate between the two spin pools in 1/seconds\nT2s::Number: Transversal relaxationt time of the semi-solid pool in seconds\n\nOptional:\n\ngrad_list=[]: Vector to indicate which gradients should be calculated; the vector can either be empty [] for no gradient, or contain any subset/order of grad_list=[grad_m0s(), grad_R1(), grad_R2f(), grad_Rx(), grad_T2s(), grad_ω0(), grad_B1()]\nNcyc=2: The magnetization is initialized with thermal equilibrium and then performed Ncyc times and only the last cycle is stored. The default value is usually a good approximation for antiperiodic boundary conditions. Increase the number for higher precision at the cost of computation time. \noutput=:complexsignal: The defaul keywords triggers the function to output a complex-valued signal (xf + 1im yf); the keyword output=:realmagnetization triggers an output of the entire (real valued) vector [xf, yf, zf, xs, zs]\n\nExamples\n\njulia> calculatesignal_graham_ode(ones(100)*π/2, ones(100)*5e-4, 4e-3, 0, 1, 0.1, 1, 15, 30, 10e-6)\n100×1 Matrix{ComplexF64}:\n -0.025070162833645618 + 0.0im\n  0.003743068709932302 - 0.0im\n -0.019432211972761584 + 0.0im\n  0.007158922245383879 - 0.0im\n    -0.014255325151365 + 0.0im\n  0.010307593338620604 - 0.0im\n -0.009486903618759873 + 0.0im\n  0.013252701136887497 - 0.0im\n  -0.00505007378048608 + 0.0im\n  0.015978096974037573 - 0.0im\n                       ⋮\n    0.0545210792217067 - 0.0im\n   0.05378824747233755 + 0.0im\n   0.05466774677353861 - 0.0im\n   0.05399168955011439 + 0.0im\n   0.05480524072601252 - 0.0im\n   0.05418157100952948 + 0.0im\n   0.05493412868432476 - 0.0im\n   0.05435879806126212 + 0.0im\n  0.055054944205796146 - 0.0im\n\njulia> calculatesignal_graham_ode(ones(100)*π/2, ones(100)*5e-4, 4e-3, 0, 1, 0.1, 1, 15, 30, 10e-6; grad_list=[grad_R1(), grad_T2s()], output=:realmagnetization)\n100×15 transpose(::Matrix{Float64}) with eltype Float64:\n -0.0249614    0.0   0.00192295  …   0.0    -7.79895  -141.002   0.0\n  0.00374263  -0.0  -0.0220613      -0.0    81.4297   -131.309   0.0\n -0.0193318    0.0   0.00550778      0.0   -20.7551   -116.146   0.0\n  0.00715882  -0.0  -0.0166685      -0.0    62.8368   -103.541   0.0\n -0.014162     0.0   0.00878636      0.0   -30.0836    -90.4788  0.0\n  0.010306    -0.0  -0.0117047   …  -0.0    48.2494    -81.8859  0.0\n -0.00938721   0.0   0.0118269       0.0   -36.5357    -73.5855  0.0\n  0.0132393   -0.0  -0.00710492     -0.0    36.5226    -69.4018  0.0\n -0.0049538    0.0   0.0146514       0.0   -41.1928    -65.1257  0.0\n  0.0159661   -0.0  -0.00282248     -0.0    26.5349    -64.1602  0.0\n  ⋮                              ⋱\n  0.0541053   -0.0   0.053379       -0.0  -202.073    -149.963   0.0\n  0.0535064    0.0   0.0541954       0.0  -205.711    -150.191   0.0\n  0.054291    -0.0   0.0536194      -0.0  -204.431    -150.476   0.0\n  0.0537389    0.0   0.054375        0.0  -207.825    -150.691   0.0\n  0.054465    -0.0   0.0538441   …  -0.0  -206.681    -150.958   0.0\n  0.0539561    0.0   0.0545433       0.0  -209.847    -151.16    0.0\n  0.0546281   -0.0   0.0540539      -0.0  -208.826    -151.411   0.0\n  0.054159     0.0   0.054701        0.0  -211.78     -151.601   0.0\n  0.0547809   -0.0   0.05425        -0.0  -210.87     -151.835   0.0\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.calculatesignal_linearapprox-NTuple{11, Any}","page":"API","title":"MRIgeneralizedBloch.calculatesignal_linearapprox","text":"calculatesignal_linearapprox(α, TRF, TR, ω0, B1, m0s, R1, R2f, Rx, T2s, R2slT[; grad_list=[undef], rfphase_increment=[π], m0=:antiperiodic, output=:complexsignal])\n\nCalculate the signal or magnetization evolution with the linear approximation of the generalized Bloch model assuming a super-Loretzian lineshape. \n\nThe simulation assumes a sequence of rectangluar RF-pulses with varying flip angles α and RF-pulse durations TRF, but a fixed repetition time TR. Further, it assumes balanced gradient moments. \n\nArguemnts\n\nα::Vector{<:Number}: Array of flip angles in radians\nTRF::Vector{<:Number}: Array of the RF-pulse durations in seconds\nTR::Number: Repetition time in seconds\nω0::Number: Off-resonance frequency in rad/s \nB1::Number: Normalized transmit B1 field, i.e. B1 = 1 corresponds to a well-calibrated B1 field\nm0s::Number: Fractional size of the semi-solid pool; should be in range of 0 to 1\nR1::Number: Apparent longitudinal relaxation rate of the free and semi-solid pool in 1/seconds\nR2f::Number: Transversal relaxation rate of the free pool in 1/seconds\nRx::Number: Exchange rate between the two spin pools in 1/seconds\nT2s::Number: Transversal relaxationt time of the semi-solid pool in seconds\nR2slT::NTuple{3, Function}: Tuple of three functions: R2sl(TRF, ω1, B1, T2s), dR2sldB1(TRF, ω1, B1, T2s), and R2sldT2s(TRF, ω1, B1, T2s). Can be generated with precompute_R2sl\n\nOptional:\n\ngrad_list=[undef]: Vector to indicate which gradients should be calculated; the vector elements can either be undef for no gradient, or any subset/order of grad_list=[grad_m0s(), grad_R1(), grad_R2f(), grad_Rx(), grad_T2s(), grad_ω0(), grad_B1()]\nrfphase_increment=[π]::Vector{<:Number}: Increment of the RF phase between consequtive pulses. The default value π, together with ω0=0 corresponds to the on-resonance condition. When more than one value is supplied, their resulting signal is stored along the second dimension of the output array. \nm0=:antiperiodic: With the default keyword :antiperiodic, the signal and their derivatives are calcualted assuming m(0) = -m(T), where T is the duration of the RF-train. With the keyword :thermal, the magnetization m(0) is initialized with thermal equilibrium [xf, yf, zf, xs, zs] = [0, 0, 1-m0s, 0, m0s], followed by a α[1]/2 - TR/2 prep pulse; and with the keyword :IR, this initalization is followed an inversion pulse of duration TRF[1], (set α[1]=π) and a α[2]/2 - TR/2 prep pulse.\noutput=:complexsignal: The defaul keywords triggers the function to output a complex-valued signal (xf + 1im yf); the keyword output=:realmagnetization triggers an output of the entire (real valued) vector [xf, yf, zf, xs, zs]\n\nExamples\n\njulia> R2slT = precompute_R2sl(4e-4, 6e-4, 5e-6, 15e-6, 0, π, 0.9, 1.1);\n\n\njulia> calculatesignal_linearapprox(ones(100)*π/2, ones(100)*5e-4, 4e-3, 0, 1, 0.1, 1, 15, 30, 10e-6, R2slT)\n100×1×1 Array{ComplexF64, 3}:\n[:, :, 1] =\n  -0.02534278046134154 - 4.577701626475585e-18im\n 0.0037475248549574324 + 1.388260871151897e-18im\n  -0.01968339070835049 - 8.75201971848235e-19im\n  0.007162011566093646 - 1.4459082011084229e-18im\n   -0.0144895176793448 + 2.1877205702266495e-18im\n  0.010305804983291568 - 3.731435622400897e-18im\n -0.009686634863202476 + 4.702732023294568e-18im\n  0.013225362349677862 - 5.546053844565051e-18im\n -0.005228086823125361 + 6.7483961018181305e-18im\n   0.01594849304619018 - 6.958370481047465e-18im\n                       ⋮\n   0.05320472714326831 + 1.3033374854610898e-18im\n  0.052585005751987685 + 4.908818038942329e-18im\n    0.0533741870254339 + 1.4418300667559059e-18im\n   0.05280280912207337 + 4.797934936029663e-18im\n  0.053532722870021004 + 1.5713757330471007e-18im\n   0.05300592940528556 + 4.694217819504405e-18im\n  0.053681035480811996 + 1.6924792846355247e-18im\n  0.053195358911463556 + 4.5972721120737284e-18im\n    0.0538197809698563 + 1.8056267663850037e-18im\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.dG_o_dT2s_x_T2s_gaussian-Tuple{Any}","page":"API","title":"MRIgeneralizedBloch.dG_o_dT2s_x_T2s_gaussian","text":"dG_o_dT2s_x_T2s_gaussian(κ)\n\nEvaluate the derivative of Green's function, corresponding to a Gaussian linshape, wrt. T2s at κ = (t-τ)/T2s and multiply it by T2s.\n\nThe multiplication is added so that the function merely depends on κ = (t-τ)/T2s. The actual derivative is given by dG_o_dT2s_x_T2s_gaussian((t-τ)/T2s)/T2s.\n\nExamples\n\njulia> t = 100e-6;\n\njulia> τ = 0;\n\njulia> T2s = 10e-6;\n\njulia> dGdT2s = dG_o_dT2s_x_T2s_gaussian((t-τ)/T2s)/T2s\n1.9287498479639177e-15\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.dG_o_dT2s_x_T2s_lorentzian-Tuple{Any}","page":"API","title":"MRIgeneralizedBloch.dG_o_dT2s_x_T2s_lorentzian","text":"dG_o_dT2s_x_T2s_lorentzian(κ)\n\nEvaluate the derivative of Green's function, corresponding to a Lorentzian linshape, wrt. T2s at κ = (t-τ)/T2s and multiply it by T2s.\n\nThe multiplication is added so that the function merely depends on κ = (t-τ)/T2s. The actual derivative is given by dG_o_dT2s_x_T2s_lorentzian((t-τ)/T2s)/T2s.\n\nExamples\n\njulia> t = 100e-6;\n\njulia> τ = 0;\n\njulia> T2s = 10e-6;\n\njulia> dGdT2s = dG_o_dT2s_x_T2s_lorentzian((t-τ)/T2s)/T2s\n45.39992976248485\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.dG_o_dT2s_x_T2s_superlorentzian-Tuple{Any}","page":"API","title":"MRIgeneralizedBloch.dG_o_dT2s_x_T2s_superlorentzian","text":"dG_o_dT2s_x_T2s_superlorentzian(κ)\n\nEvaluate the derivative of Green's function, corresponding to a super-Lorentzian linshape, wrt. T2s at κ = (t-τ)/T2s and multiply it by T2s.\n\nThe multiplication is added so that the function merely depends on κ = (t-τ)/T2s. The actual derivative is given by dG_o_dT2s_x_T2s_superlorentzian((t-τ)/T2s)/T2s.\n\nExamples\n\njulia> t = 100e-6;\n\njulia> τ = 0;\n\njulia> T2s = 10e-6;\n\njulia> dGdT2s = dG_o_dT2s_x_T2s_superlorentzian((t-τ)/T2s)/T2s\n15253.095033670965\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.greens_gaussian-Tuple{Any}","page":"API","title":"MRIgeneralizedBloch.greens_gaussian","text":"greens_gaussian(κ)\n\nEvaluate the Green's function corresponding to a Gaussian linshape at κ = (t-τ)/T2s.\n\nExamples\n\njulia> t = 100e-6;\n\njulia> τ = 0;\n\njulia> T2s = 10e-6;\n\njulia> greens_gaussian((t-τ)/T2s)\n1.9287498479639178e-22\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.greens_lorentzian-Tuple{Any}","page":"API","title":"MRIgeneralizedBloch.greens_lorentzian","text":"greens_lorentzian(κ)\n\nEvaluate the Green's function corresponding to a Lorentzian linshape at κ = (t-τ)/T2s.\n\nExamples\n\njulia> t = 100e-6;\n\njulia> τ = 0;\n\njulia> T2s = 10e-6;\n\njulia> greens_lorentzian((t-τ)/T2s)\n4.5399929762484854e-5\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.greens_superlorentzian-Tuple{Any}","page":"API","title":"MRIgeneralizedBloch.greens_superlorentzian","text":"greens_superlorentzian(κ)\n\nEvaluate the Green's function corresponding to a super-Lorentzian linshape at κ = (t-τ)/T2s.\n\nExamples\n\njulia> t = 100e-6;\n\njulia> τ = 0;\n\njulia> T2s = 10e-6;\n\njulia> greens_superlorentzian((t-τ)/T2s)\n0.1471246868094442\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.hamiltonian_linear-NTuple{9, Any}","page":"API","title":"MRIgeneralizedBloch.hamiltonian_linear","text":"hamiltonian_linear(ω1, B1, ω0, T, m0s, R1, R2f, Rx, R2s[, dR2sdT2s, dR2sdB1, grad_type])\n\nCalculate the hamiltonian of the linear approximation of the generalized Bloch model. \n\nIf no gradient is supplied, it returns a 6x6 (static) matrix with the dimensions (in this order) [xf, yf, zf, xs, zs, 1]; the attached 1 is a mathematical trick to allow for T_1 relaxation to a non-zero thermal equilibrium. If a gradient is supplied, it returns a 11x11 (static) matrix with the dimensions (in this order) [xf, yf, zf, xs, zs, dxf/dθ, dyf/dθ, dzf/dθ, dxs/dθ, dzs/dθ,  1], where θ is the parameter specified by grad_type\n\nArguemnts\n\nω1::Number: Rabi frequency in rad/s (rotation about the y-axis)\nB1::Number: Normalized transmit B1 field, i.e. B1 = 1 corresponds to a well-calibrated B1 field\nω0::Number: Larmor (or off-resonance) frequency in rad/s (rotation about the z-axis)\nT::Number: Time in seconds; this can, e.g., be the RF-pulse duration, or the time of free precession with ω1=0\nm0s::Number: Fractional size of the semi-solid pool; should be in range of 0 to 1\nR1::Number: Apparent longitudinal relaxation rate of the free and semi-solid pool in 1/seconds\nR2f::Number: Transversal relaxation rate of the free pool in 1/seconds\nRx::Number: Exchange rate between the two spin pools in 1/seconds\nR2s::Number: Transversal relaxationt rate of the semi-solid pool in 1/seconds; this number can be calcualated with the first function returned by precompute_R2sl to implement the linear approximation described in the generalized Bloch paper\n\nOptional:\n\ndR2sdT2s::Number: Derivative of linearized R2sl wrt. the actual T2s; only required if grad_type = grad_T2s(); this number can be calcualated with the second function returned by precompute_R2sl\ndR2sdB1::Number: Derivative of linearized R2sl wrt. B1; only required if grad_type = grad_B1(); this number can be calcualated with the third function returned by precompute_R2sl\ngrad_type::grad_param: grad_m0s(), grad_R1(), grad_R2f(), grad_Rx(), grad_T2s(), grad_ω0(), or grad_B1(); create one hamiltonian for each desired gradient\n\nExamples\n\njulia> α = π;\n\njulia> T = 500e-6;\n\njulia> ω1 = α/T;\n\njulia> B1 = 1;\n\njulia> ω0 = 0;\n\njulia> m0s = 0.1;\n\njulia> R1 = 1;\n\njulia> R2f = 15;\n\njulia> Rx = 30;\n\njulia> R2s = 1e5;\n\njulia> m0 = [0, 0, 1-m0s, 0, m0s, 1];\n\njulia> (xf, yf, zf, xs, zs, _) = exp(hamiltonian_linear(ω1, B1, ω0, T, m0s, R1, R2f, Rx, R2s)) * m0\n6-element StaticArrays.SVector{6, Float64} with indices SOneTo(6):\n  0.0010646925712316385\n  0.0\n -0.8957848933541458\n  0.005125086137871531\n  0.08119617921987107\n  1.0\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.interpolate_greens_function-Tuple{Any, Any, Any}","page":"API","title":"MRIgeneralizedBloch.interpolate_greens_function","text":"interpolate_greens_function(f, κmin, κmax)\n\nInterpolate the Green's function f in the range between κmin and κmax.\n\nThe interpolation uses the ApproxFun.jl package that incorporates Chebyshev polynomials and ensures an approximation to machine precision. \n\nExamples\n\njulia> t = 100e-6;\n\njulia> τ = 0;\n\njulia> T2s = 10e-6;\n\njulia> greens_superlorentzian((t-τ)/T2s)\n0.1471246868094442\n\njulia> Gint = interpolate_greens_function(greens_superlorentzian, 0, 20);\n\n\njulia> Gint((t-τ)/T2s)\n0.14712468680944407\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.precompute_R2sl-NTuple{8, Any}","page":"API","title":"MRIgeneralizedBloch.precompute_R2sl","text":"precompute_R2sl(TRF_min, TRF_max, T2s_min, T2s_max, α_min, α_max, B1_min, B1_max[; greens=greens_superlorentzian])\n\nPre-compute and interpolate the linearized R2sl(TRF, α, B1, T2s) and its derivatives dR2sldB1(TRF, α, B1, T2s) and R2sldT2s(TRF, α, B1, T2s) in the range specified by the arguments.\n\nThe function solves the generalized Bloch equations of an isolated semi-solid pool for values in the specified range, calulates the linearized R2sl that minimizes the error of zs at the end of the RF-pulse, and interpolates between the different samples. \n\nArguemnts\n\nTRF_min::Number: lower bound of the RF-pulse duration range in seconds\nTRF_max::Number: upper bound of the RF-pulse duration range in seconds\nT2s_min::Number: lower bound of the T2s range in seconds\nT2s_max::Number: upper bound of the T2s range in seconds\nα_min::Number: lower bound of the flip angle range in radians\nα_max::Number: upper bound of the flip angle range in radians\nB1_min::Number: lower bound of the B1 range, normalized so that B1 = 1 corresponds to a perfectly calibrated RF field\nB1_max::Number: upper bound of the B1 range, normalized so that B1 = 1 corresponds to a perfectly calibrated RF field\n\nOptional:\n\ngreens=greens_superlorentzian: Greens function in the form G(κ) = G((t-τ)/T2s). This package supplies the three Greens functions greens=greens_superlorentzian (default), greens=greens_lorentzian, and greens=greens_gaussian\n\nExamples\n\njulia> (R2sl, dR2sldB1, R2sldT2s) = precompute_R2sl(100e-6, 1e-3, 5e-6, 15e-6, 0, π, 0.7, 1.3);\n\n\njulia> (R2sl, dR2sldB1, R2sldT2s) = precompute_R2sl(100e-6, 1e-3, 5e-6, 15e-6, 0, π, 0.7, 1.3; greens=greens_gaussian);\n\n\n\n\n\n\n","category":"method"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"EditURL = \"https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/master/docs/src/Simulation_ContinuousWave.jl\"","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"(Image: ) (Image: )","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/#Continuous-Wave-Simulation","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"","category":"section"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"The following code replicates the continuous wave simulation of Fig. 2 and is slightly more comprehensive in the sense that all discussed models are simulated.","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"For these simulations we need the following packages:","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"using MRIgeneralizedBloch\nusing DifferentialEquations\nusing QuadGK\nusing Plots\nplotlyjs(bg = RGBA(31/255,36/255,36/255,1.0), ticks=:native);\nnothing #hide","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"and we simulate an isolated semi-solid spin pool with the following parameters:","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"R1 = 1.0 # 1/s\nT2s = 10e-6 # s\nz0 = [1.0] # initial z-magnetization\nz_fun(p, t) = [1.0] # initialize history function (will be populated with an interpolation by the differential equation solver)\n\nω1 = 2000π # rad/s\nω0 = 200π # rad/s\nTRF = .002 # s\n\n\nt = range(0, TRF, length=1001) # plot points\ntspan = (0.0, TRF); # simulation range\nnothing #hide","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"These parameters correspond to Fig. 2b, the parameters for replicating Fig. 2a are ω1 = 200π, ω0 = 2000π, and TRF = 1.","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/#Lorentzian-lineshape","page":"Continuous Wave Simulation","title":"Lorentzian lineshape","text":"","category":"section"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"In this script, we simulate the three lineshapes separately, starting with the Lorentzian lineshape for which the Bloch model provides a ground truth.","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/#Bloch-model","page":"Continuous Wave Simulation","title":"Bloch model","text":"","category":"section"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"We can formulate the Bloch model as","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"partial_t beginpmatrix x  y  z  1 endpmatrix = beginpmatrix\n-R_2  -ω_0  ω_1  0 \nω_0  -R_2  0  0 \n-ω_1  0  -R_1  R_1 \n0  0  0  0\nendpmatrix beginpmatrix x  y  z  1 endpmatrix ","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"where the matrix is the Hamiltonian of the Bloch model. For a constant ω_0 and ω_1, we can evaluate the Bloch model by taking the  matrix exponential of its Hamiltonian:","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"H(ω1, ω0, R2, R1) = [-R2  -ω0  ω1  0;\n                       ω0 -R2   0  0;\n                      -ω1   0 -R1 R1;\n                        0   0   0  0]\n\nz_Bloch = similar(t)\nfor i = 1:length(t)\n    (_, _, z_Bloch[i], _) = exp(H(ω1, ω0, 1 / T2s, R1) * t[i]) * [0; 0; 1; 1]\nend","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/#Henkelman's-steady-state-solution","page":"Continuous Wave Simulation","title":"Henkelman's steady-state solution","text":"","category":"section"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"When assuming an isolated semi-solid pool, Eq. (9) in Henkelman, R. Mark, et al. \"Quantitative interpretation of magnetization transfer.\" Magnetic resonance in medicine 29.6 (1993): 759-766 reduces to","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"g_Lorentzian(ω0) = T2s / π / (1 + (T2s * ω0)^2)\nz_steady_state_Lorentzian = R1 / (R1 + π * ω1^2 * g_Lorentzian(ω0))","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"where g_Lorentzian(ω0) is the Lorentzian lineshape.","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/#Graham's-single-frequency-approximation","page":"Continuous Wave Simulation","title":"Graham's single frequency approximation","text":"","category":"section"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"The lineshape is also used to calculate Graham's single frequency approximation, which describes an exponential decay with the RF-induced saturation rate Rrf:","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"Rrf = π * ω1^2 * g_Lorentzian(ω0)\nz_Graham_Lorentzian = @. (Rrf * exp(-t * (R1 + Rrf)) + R1) / (R1 + Rrf);\nnothing #hide","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/#Sled's-model","page":"Continuous Wave Simulation","title":"Sled's model","text":"","category":"section"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"Sled's model is given by the ordinary differential equation (ODE)","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"partial_t z(t) = left(-pi int_0^t G(t-τ) omega_1(τ)^2 dτ right) z(t)  + R_1 (1-z)","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"where G(t-τ) is the Green's function. The Hamiltonian of this ODE is implemented in apply_hamiltonian_sled! and can be solve the ODE solver of the DifferentialEquations.jl package:","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"z_Sled_Lorentzian = solve(ODEProblem(apply_hamiltonian_sled!, z0, tspan, (ω1, 1, ω0, R1, T2s, greens_lorentzian)));\nnothing #hide","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/#generalized-Bloch-model","page":"Continuous Wave Simulation","title":"generalized Bloch model","text":"","category":"section"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"The generalized Bloch model is given by the integro-differential equation (IDE)","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"partial_t z(t) = - ω_y(t) int_0^t G(tτ) ω_y(τ) z(τ) dτ - ω_x(t) int_0^t G(tτ) ω_x(τ) z(τ) dτ + R_1 (1 - z(t)) ","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"where we explicitly denote the ω_x and ω_y components of the Rabi frequency. The Hamiltonian of the IDE is implemented in apply_hamiltonian_gbloch! and we can solve this IDE with the delay-differential equation (DDE) solver of the DifferentialEquations.jl package:","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"z_gBloch_Lorentzian = solve(DDEProblem(apply_hamiltonian_gbloch!, z0, z_fun, tspan, (ω1, 1, ω0, R1, T2s, greens_lorentzian)));\nnothing #hide","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"Now that we have solved all five models, we can plot the solutions for comparison:","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"p = plot(xlabel=\"t [ms]\", ylabel=\"zs(t)\")\nplot!(p, 1e3t, z_Bloch, label=\"Bloch model\")\nplot!(p, 1e3t, zero(similar(t)) .+ z_steady_state_Lorentzian, label=\"Henkelman's steady-state\")\nplot!(p, 1e3t, z_Graham_Lorentzian, label=\"Graham's model\")\nplot!(p, 1e3t, (hcat(z_Sled_Lorentzian(t).u...)'), label=\"Sled's model\")\nplot!(p, 1e3t, (hcat(z_gBloch_Lorentzian(t).u...)'), label=\"generalized Bloch model\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"Zooming into the plot, reveals virtually perfect (besides numerical differences) agreement between Bloch and generalized Bloch model and subtle, but existing differences when compared to the other models. Choosing a longer T2s amplifies these differences.","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/#Gaussian-lineshape","page":"Continuous Wave Simulation","title":"Gaussian lineshape","text":"","category":"section"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"We can repeat the same simulation (with the exception of the Bloch model) for the Gaussian lineshape:","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"g_Gaussian(ω0) = T2s / sqrt(2π) * exp(-(T2s * ω0)^2 / 2)\nz_steady_state_Gaussian = R1 / (R1 + π * ω1^2 * g_Gaussian(ω0))\n\nRrf = π * ω1^2 * g_Gaussian(ω0)\nz_Graham_Gaussian = @. (Rrf * exp(-t * (R1 + Rrf)) + R1) / (R1 + Rrf)\n\nz_gBloch_Gaussian = solve(DDEProblem(apply_hamiltonian_gbloch!, z0, z_fun, tspan, (ω1, 1, ω0, R1, T2s, greens_gaussian)))\n\nz_Sled_Gaussian = solve(ODEProblem(apply_hamiltonian_sled!, z0, tspan, (ω1, 1, ω0, R1, T2s, greens_gaussian)))\n\np = plot(xlabel=\"t [ms]\", ylabel=\"zs(t)\")\nplot!(p, 1e3t, zero(similar(t)) .+ z_steady_state_Gaussian, label=\"Henkelman's steady-state\")\nplot!(p, 1e3t, z_Graham_Gaussian, label=\"Graham' model\")\nplot!(p, 1e3t, (hcat(z_Sled_Gaussian(t).u...)'), label=\"Sled's model\")\nplot!(p, 1e3t, (hcat(z_gBloch_Gaussian(t).u...)'), label=\"generalized Bloch model\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/#super-Lorentzian-lineshape","page":"Continuous Wave Simulation","title":"super-Lorentzian lineshape","text":"","category":"section"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"And we can repeat the same simulation (with the exception of the Bloch model) for the super-Lorentzian lineshape, which reveals the most pronounced deviations between the models due to the substantially slower decay of the Green's function:","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"g_superLorentzian(ω0) = sqrt(2 / π) * T2s * quadgk(ct -> exp(-2 * (T2s * ω0 / abs(3 * ct^2 - 1))^2) / abs(3 * ct^2 - 1), 0.0, sqrt(1 / 3), 1)[1]\nz_steady_state_superLorentzian = R1 / (R1 + π * ω1^2 * g_superLorentzian(ω0))\n\nRrf = π * ω1^2 * g_superLorentzian(ω0)\nz_Graham_superLorentzian = @. (Rrf * exp(-t * (R1 + Rrf)) + R1) / (R1 + Rrf)\n\nG_superLorentzian = interpolate_greens_function(greens_superlorentzian, 0, TRF/T2s)\nz_gBloch_superLorentzian = solve(DDEProblem(apply_hamiltonian_gbloch!, z0, z_fun, tspan, (ω1, 1, ω0, R1, T2s, G_superLorentzian)))\n\nz_Sled_superLorentzian = solve(ODEProblem(apply_hamiltonian_sled!, z0, tspan, (ω1, 1, ω0, R1, T2s, G_superLorentzian)))\n\np = plot(xlabel=\"t [ms]\", ylabel=\"zs(t)\")\nplot!(p, 1e3t, zero(similar(t)) .+ z_steady_state_superLorentzian, label=\"Henkelman's steady-state (super-Lorentzian)\")\nplot!(p, 1e3t, z_Graham_superLorentzian, label=\"Graham super-Lorentzian\")\nplot!(p, 1e3t, (hcat(z_gBloch_superLorentzian(t).u...)'), label=\"gBloch super-Lorentzian\")\nplot!(p, 1e3t, (hcat(z_Sled_superLorentzian(t).u...)'), label=\"Sled super-Lorentzian\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"EditURL = \"https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/master/docs/src/Greens_functions.jl\"","category":"page"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"(Image: ) (Image: )","category":"page"},{"location":"build_literate/Greens_functions/#Green's-Functions","page":"Green's Functions","title":"Green's Functions","text":"","category":"section"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"The Green's functions are given by the Fourier transform of lineshapes. For a Lorentzian lineshape, the Green's function is","category":"page"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"\tG(ttau) = exp (-R_2^s (t-tau))  forall  t geq tau","category":"page"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"for a Gaussian lineshape it is","category":"page"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"\tG(ttau) = exp(- R_2^s^2 (t-tau)^2  2))","category":"page"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"and for super-Lorentzian it is","category":"page"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"\tG(ttau) = int_0^1 exp left(- R_2^s^2 (t - tau)^2 cdot  frac(3 zeta^2 - 1)^28 right) dzeta","category":"page"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"As evident from these equations, the Green's functions are merely a function of kappa = R_2^s cdot (t - tau) = (t - tau)  T_2^s, and in this package we implemented the functions as such: greens_lorentzian(κ), greens_gaussian(κ), and greens_superlorentzian(κ). These functions can be used to reproduce Fig. 1 in the generalized Bloch paper:","category":"page"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"using MRIgeneralizedBloch\nusing Plots\nplotlyjs(bg = RGBA(31/255,36/255,36/255,1.0), ticks=:native);\nnothing #hide","category":"page"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"T2s = 10e-6 # s\nt = 0 : 1e-6 : 1e-3\np = plot(1e3t, greens_lorentzian.(t ./ T2s), yaxis=:log, ylim=(1e-6,1), label=\"Lorentzian lineshape\", xlabel=\"(t-τ) [ms]\", ylabel=\"G((t-τ)/T2s)\")\np = plot!(1e3t, greens_gaussian.(t ./ T2s), label=\"Gaussian lineshape\")\np = plot!(1e3t, greens_superlorentzian.(t ./ T2s), label=\"super-Lorentzian l.\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"","category":"page"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"EditURL = \"https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/master/docs/src/Simulation_Pulse.jl\"","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"(Image: ) (Image: )","category":"page"},{"location":"build_literate/Simulation_Pulse/#RF-Pulse-Simulation","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"","category":"section"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"The following code replicates the RF-pulse simulation of Fig. 3 and plots the z^s-magnetization at the end of respective pulse.","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"For these simulations we need the following packages:","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"using MRIgeneralizedBloch\nusing QuadGK\nusing DifferentialEquations\nusing SpecialFunctions\nusing Plots\nplotlyjs(bg = RGBA(31/255,36/255,36/255,1.0), ticks=:native);\nnothing #hide","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"and we simulate an isolated semi-solid spin pool with the following parameters:","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"α = π\nTRF = exp.(range(log(2e-7), log(1e-1), length=100)) # s\nω1 = α ./ TRF # rad/s\nω0 = 0 # rad/s\nR1 = 1 # 1/s\nT2s = 10e-6 # s\nz0 = [1] # initial z-magnetization\nz_fun(p, t) = [1.0]; # initialize history function (will be populated with an interpolation by the differential equation solver)\nnothing #hide","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"Here, we simulate a π-pulse. Replace first line with α = π/4 or α = π/2 to simulate the other two rows of Fig. 3.","category":"page"},{"location":"build_literate/Simulation_Pulse/#Lorentzian-lineshape","page":"RF-Pulse Simulation","title":"Lorentzian lineshape","text":"","category":"section"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"In this script, we simulate the three lineshapes separately, starting with the Lorentzian lineshape for which the Bloch model provides a ground truth.","category":"page"},{"location":"build_literate/Simulation_Pulse/#Bloch-model","page":"RF-Pulse Simulation","title":"Bloch model","text":"","category":"section"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"We can formulate the Bloch model as","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"partial_t beginpmatrix x  y  z  1 endpmatrix = beginpmatrix\n-R_2  -ω_0  ω_1  0 \nω_0  -R_2  0  0 \n-ω_1  0  -R_1  R_1 \n0  0  0  0\nendpmatrix beginpmatrix x  y  z  1 endpmatrix ","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"where the matrix is the Hamiltonian of the Bloch model. For a constant ω_0 and ω_1, we can evaluate the Bloch model by taking the  matrix exponential of its Hamiltonian:","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"H(ω1, ω0, R2, R1) = [-R2 -ω0  ω1  0;\n                      ω0 -R2   0  0;\n                     -ω1   0 -R1 R1;\n                       0   0   0  0]\n\nz_Bloch = similar(TRF)\nfor i = 1:length(TRF)\n    (_, _, z_Bloch[i], _)  = exp(H(ω1[i], ω0, 1 / T2s, R1) * TRF[i]) * [0; 0; 1; 1]\nend","category":"page"},{"location":"build_literate/Simulation_Pulse/#Graham's-spectral-model","page":"RF-Pulse Simulation","title":"Graham's spectral model","text":"","category":"section"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"Graham's spectral model is derived by integrating over the lineshape multiplied by the spectral response function of the RF-pulse. This results in the RF-induced saturation rate Rrf that is used in an exponential model:","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"Rrf = @. ω1^2 * T2s * ((exp(-TRF / T2s) -1) * T2s + TRF) / TRF\nz_Graham_spec_Lorentzian = @. (Rrf * exp(-TRF * (R1 + Rrf)) + R1) / (R1 + Rrf);\nnothing #hide","category":"page"},{"location":"build_literate/Simulation_Pulse/#Graham's-single-frequency-approximation","page":"RF-Pulse Simulation","title":"Graham's single frequency approximation","text":"","category":"section"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"In the single frequency approximation, Graham assumes that the RF-pulse has only a single frequency, which reduces Rrf to","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"g_Lorentzian(ω0) = T2s / π ./ (1 .+ (T2s .* ω0).^2)\nRrf = @. π * ω1^2 * g_Lorentzian(ω0)\nz_Graham_SF_approx_Lorentzian = @. (Rrf * exp(-TRF * (R1 + Rrf)) + R1) / (R1 + Rrf);\nnothing #hide","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"where g_Lorentzian(ω0) denotes the Lorentzian lineshape.","category":"page"},{"location":"build_literate/Simulation_Pulse/#Sled's-model","page":"RF-Pulse Simulation","title":"Sled's model","text":"","category":"section"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"Sled's model is given by the ordinary differential equation (ODE)","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"partial_t z(t) = left(-pi int_0^t G(t-τ) omega_1(τ)^2 dτ right) z(t)  + R_1 (1-z)","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"where G(t-τ) is the Green's function. The Hamiltonian of this ODE is implemented in apply_hamiltonian_sled! and can be solve the ODE solver of the DifferentialEquations.jl package:","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"z_Sled_Lorentzian = similar(TRF)\nfor i = 1:length(TRF)\n    z_Sled_Lorentzian[i] = solve(ODEProblem(apply_hamiltonian_sled!, z0, (0, TRF[i]), (ω1[i], 1, ω0, R1, T2s, greens_lorentzian)), Tsit5())[end][1]\nend","category":"page"},{"location":"build_literate/Simulation_Pulse/#generalized-Bloch-model","page":"RF-Pulse Simulation","title":"generalized Bloch model","text":"","category":"section"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"The generalized Bloch model is given by the intgro-differential equation (IDE)","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"partial_t z(t) = - ω_y(t) int_0^t G(tτ) ω_y(τ) z(τ) dτ - ω_x(t) int_0^t G(tτ) ω_x(τ) z(τ) dτ + R_1 (1 - z(t)) ","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"where we explicitly denote the ω_x and ω_y components of the Rabi frequency. The Hamiltonian of the IDE is implemented in apply_hamiltonian_gbloch! and we can solve this IDE with the delay-differential equation (DDE) solver of the DifferentialEquations.jl package:","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"z_gBloch_Lorentzian = similar(TRF)\nfor i = 1:length(TRF)\n    z_gBloch_Lorentzian[i] = solve(DDEProblem(apply_hamiltonian_gbloch!, z0, z_fun, (0, TRF[i]), (ω1[i], 1, ω0, R1, T2s, greens_lorentzian)), MethodOfSteps(DP8()))[end][1]\nend","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"Now we have solved all five models and can plot the solutions for comparison:","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"p = plot(xaxis=:log, legend=:bottomright, xlabel=\"TRF [s]\", ylabel=\"zs(TRF)\")\nplot!(p, TRF, z_gBloch_Lorentzian, label=\"generalized Bloch model\")\nplot!(p, TRF, TRF .* 0 .+ cos(α), label=\"cos(α)\")\nplot!(p, TRF, z_Sled_Lorentzian, label=\"Sled's model\")\nplot!(p, TRF, z_Graham_spec_Lorentzian, label=\"Graham's spectral model\")\nplot!(p, TRF, z_Graham_SF_approx_Lorentzian, label=\"Graham's single frequency approximation\")\nplot!(p, TRF, z_Bloch, label=\"Bloch simulation\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Simulation_Pulse/#Gaussian-lineshape","page":"RF-Pulse Simulation","title":"Gaussian lineshape","text":"","category":"section"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"We can repeat the same simulation (with the exception of the Bloch model) for the Gaussian lineshape:","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"Rrf = @. ω1^2 * T2s * (2 * T2s * (exp(-(TRF/T2s)^2/2)-1) + sqrt(2π) * TRF * erf(TRF/T2s/sqrt(2))) / (2 * TRF)\nz_Graham_spec_Gaussian = @. (Rrf * exp(-TRF * (R1 + Rrf)) + R1) / (R1 + Rrf)\n\ng_Gaussian(ω0) = T2s / sqrt(2π) * exp(-(T2s * ω0)^2 / 2) # lineshape\nRrf = @. π * ω1^2 * g_Gaussian(ω0)\nz_Graham_SF_approx_Gaussian = @. (Rrf * exp(-TRF * (R1 + Rrf)) + R1) / (R1 + Rrf)\n\nz_Sled_Gaussian = similar(TRF)\nfor i = 1:length(TRF)\n    z_Sled_Gaussian[i] = solve(ODEProblem(apply_hamiltonian_sled!, z0, (0, TRF[i]), (ω1[i], 1, ω0, R1, T2s, greens_gaussian)), Tsit5())[end][1]\nend\n\nz_gBloch_Gaussian = similar(TRF)\nfor i = 1:length(TRF)\n    z_gBloch_Gaussian[i] = solve(DDEProblem(apply_hamiltonian_gbloch!, z0, z_fun, (0, TRF[i]), (ω1[i], 1, ω0, R1, T2s, greens_gaussian)), MethodOfSteps(DP8()))[end][1]\nend\n\np = plot(xaxis=:log, legend=:bottomright, xlabel=\"TRF [s]\", ylabel=\"zs(TRF)\")\nplot!(p, TRF, z_gBloch_Gaussian, label=\"generalized Bloch model\")\nplot!(p, TRF, TRF .* 0 .+ cos(α), label=\"cos(α)\")\nplot!(p, TRF, z_Sled_Gaussian, label=\"Sled's model\")\nplot!(p, TRF, z_Graham_spec_Gaussian, label=\"Graham's spectral model\")\nplot!(p, TRF, z_Graham_SF_approx_Gaussian, label=\"Graham's single frequency approximation\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Simulation_Pulse/#super-Lorentzian-lineshape","page":"RF-Pulse Simulation","title":"super-Lorentzian lineshape","text":"","category":"section"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"Further, we can repeat the same simulation for the super-Lorentzian lineshape with the exception of Graham's single frequency approximation, as the super-Lorentzian lineshape diverges at ω_0  0.","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"G_superLorentzian = interpolate_greens_function(greens_superlorentzian, 0, maximum(TRF)/T2s)\n\nf_PSD(τ) = quadgk(ct -> (4 / τ / abs(1 - 3 * ct^2) * (exp(- τ^2 / 8 * (1 - 3 * ct^2)^2) - 1) + sqrt(2π) * erf(τ / 2 / sqrt(2) * abs(1 - 3 * ct^2))) / abs(1 - 3 * ct^2), 0.0, 1.0)[1]\nRrf = @. f_PSD(TRF / T2s) * ω1^2 * T2s\nz_Graham_spec_superLorentzian = @. (Rrf * exp(-TRF * (R1 + Rrf)) + R1) / (R1 + Rrf)\n\nz_Sled_superLorentzian = similar(TRF)\nfor i = 1:length(TRF)\n    z_Sled_superLorentzian[i] = solve(ODEProblem(apply_hamiltonian_sled!, z0, (0, TRF[i]), (ω1[i], 1, ω0, R1, T2s, G_superLorentzian)), Tsit5())[end][1]\nend\n\nz_gBloch_superLorentzian = similar(TRF)\nfor i = 1:length(TRF)\n    z_gBloch_superLorentzian[i] = solve(DDEProblem(apply_hamiltonian_gbloch!, z0, z_fun, (0, TRF[i]), (ω1[i], 1, ω0, R1, T2s, G_superLorentzian)), MethodOfSteps(DP8()))[end][1]\nend\n\np = plot(xaxis=:log, legend=:bottomright, xlabel=\"TRF [s]\", ylabel=\"zs(TRF)\")\nplot!(p, TRF, z_gBloch_superLorentzian, label=\"generalized Bloch model\")\nplot!(p, TRF, TRF .* 0 .+ cos(α), label=\"cos(α)\")\nplot!(p, TRF, z_Sled_superLorentzian, label=\"Sled's model\")\nplot!(p, TRF, z_Graham_spec_superLorentzian, label=\"Graham's spectral model\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"This simulation reveals the most pronounced deviations of the generalized Bloch model from established models due to the slower decay of the super-Lorentzian Green's function.","category":"page"},{"location":"build_literate/Simulation_Pulse/#Error-analysis","page":"RF-Pulse Simulation","title":"Error analysis","text":"","category":"section"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"Assuming a super-Lorentzian lineshape, we quantify the deviations of Sled's model from the generalized Bloch model:","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"TRF_i = 1e-3 # s\nω1_i = α / TRF_i # rad/s\nz_Sled_superLorentzian_i = solve(ODEProblem(apply_hamiltonian_sled!, z0, (0, TRF_i), (ω1_i, 1, ω0, R1, T2s, G_superLorentzian)), Tsit5())[end][1]\nz_gBloch_superLorentzian_i = solve(DDEProblem(apply_hamiltonian_gbloch!, z0, z_fun, (0, TRF_i), (ω1_i, 1, ω0, R1, T2s, G_superLorentzian)), MethodOfSteps(DP8()))[end][1]\nz_Sled_superLorentzian_i - z_gBloch_superLorentzian_i","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"For T_textRF = 1ms, the deviations are small compared to the thermal equilibrium magnetization z^s_0 = 1, but with T_textRF = 01ms, this deviation becomes sizable:","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"TRF_i = 1e-4 # s\nω1_i = α / TRF_i # rad/s\nz_Sled_superLorentzian_i = solve(ODEProblem(apply_hamiltonian_sled!, z0, (0, TRF_i), (ω1_i, 1, ω0, R1, T2s, G_superLorentzian)), Tsit5())[end][1]\nz_gBloch_superLorentzian_i = solve(DDEProblem(apply_hamiltonian_gbloch!, z0, z_fun, (0, TRF_i), (ω1_i, 1, ω0, R1, T2s, G_superLorentzian)), MethodOfSteps(DP8()))[end][1]\nz_Sled_superLorentzian_i - z_gBloch_superLorentzian_i","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MRIgeneralizedBloch","category":"page"},{"location":"#MRIgeneralizedBloch.jl","page":"Home","title":"MRIgeneralizedBloch.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MRIgeneralizedBloch.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"tutorial/#Quick-Start-Tutorial","page":"Quick Start Tutorial","title":"Quick Start Tutorial","text":"","category":"section"},{"location":"tutorial/#Single-RF-Pulse","page":"Quick Start Tutorial","title":"Single RF-Pulse","text":"","category":"section"},{"location":"tutorial/","page":"Quick Start Tutorial","title":"Quick Start Tutorial","text":"The core of generalized Bloch model is implemented in the function apply_hamiltonian_gbloch!, which calculates the derivative ∂m/∂t for a given magnetization vector m and stores it in-place in the the variable ∂m∂t. The function interface is written in a way that we can directly feed it into the a differential equation solver of DifferentialEquations.jl: ","category":"page"},{"location":"tutorial/","page":"Quick Start Tutorial","title":"Quick Start Tutorial","text":"using MRIgeneralizedBloch\nusing DifferentialEquations\nusing Plots\nplotlyjs(bg = RGBA(31/255,36/255,36/255,1.0), ticks=:native) #hide\n\nα = π\nTRF = 100e-6\nω1 = α/TRF\nB1 = 1\nω0 = 0\nm0s = 0.15\nR1 = 1\nR2f = 15\nT2s = 10e-6\nRx = 30\nG = interpolate_greens_function(greens_superlorentzian, 0, TRF / T2s)\nm0 = [0; 0; 1-m0s; m0s; 1]\nm(p, t; idxs=nothing) = typeof(idxs) <: Number ? m0[idxs] : m0\np = (ω1, B1, ω0, m0s, R1, R2f, T2s, Rx, G)\nsol = solve(DDEProblem(apply_hamiltonian_gbloch!, m0, m, (0, TRF), p), MethodOfSteps(DP8()))\nplot(sol, labels=[\"xf\" \"yf\" \"zf\" \"zs\" \"1\"], xlabel=\"t [s]\", ylabel=\"m(t)\")\nsavefig(\"m_single_pulse.html\"); nothing #hide","category":"page"},{"location":"tutorial/","page":"Quick Start Tutorial","title":"Quick Start Tutorial","text":"<object type=\"text/html\" data=\"m_single_pulse.html\" style=\"width:100%;height:450px;\"></object>","category":"page"},{"location":"tutorial/","page":"Quick Start Tutorial","title":"Quick Start Tutorial","text":"The generalized Bloch model is a so-called integro-differential equation where the derivative mt at the time t_1 does not just depend on m(t_1), but on m(t) for t in 0 t_1. This is solved with a delay differential equation solver that stores an interpolated history function m(p, t) that needs to be initialized with m(p, 0) = m0. ","category":"page"},{"location":"tutorial/","page":"Quick Start Tutorial","title":"Quick Start Tutorial","text":"As our own work focuses on using on-resonant RF pulses to excite the free pool and simultaneously saturate the semi-solid pool, we assume the pulses to be on-resonant for the semi-solid pool, i.e., ω_0 ll 1T_2^s. If you want to simulate off-resonant RF-pulses with the generalized Bloch model, please contact me and I can incorporate this functionality.","category":"page"}]
}
