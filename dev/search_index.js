var documenterSearchIndex = {"docs":
[{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"EditURL = \"https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/master/docs/src/Linear_Approximation.jl\"","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"(Image: )","category":"page"},{"location":"build_literate/Linear_Approximation/#Linear-Approximation","page":"Linear Approximation","title":"Linear Approximation","text":"","category":"section"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"The following code demonstrates the linear approximation of the generalized Bloch model and replicates Figs. 7 and 8 in the paper.","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"For this analysis we need the following packages:","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"using DifferentialEquations\nusing BenchmarkTools\nusing LinearAlgebra\nusing MRIgeneralizedBloch\nusing Plots\nplotlyjs(bg = RGBA(31/255,36/255,36/255,1.0), ticks=:native); #hide\nnothing #hide","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"and we simulate a coupled spin system with the following parameters:","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"m₀ˢ = 0.1\nm₀ᶠ = 1-m₀ˢ\nR₁ = 1 # 1/s\nR₂ᶠ = 1 / 50e-3 # 1/s\nRₓ = 70; # 1/s\nnothing #hide","category":"page"},{"location":"build_literate/Linear_Approximation/#Linearized-T_2{s,l}","page":"Linear Approximation","title":"Linearized T_2^sl","text":"","category":"section"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"We demonstrate the linear approximation at the example of the Green's function corresponding to the super-Lorentzian lineshape, which we interpolate to improve the perfomance:","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"G = interpolate_greens_function(greens_superlorentzian, 0, 1e-3 / 5e-6);\nnothing #hide","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"The function precompute_R2sl returns another function, R₂ˢˡ(Tʳᶠ, α, B1, T₂ˢ), that interpolates the linearized relaxation rate, as well as functions that describe its derivatives wrt. T_2^s and B_1, respectively:","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"R₂ˢˡ, ∂R₂ˢˡ∂T₂ˢ, ∂R₂ˢˡ∂B₁ = precompute_R2sl(TRF_min=5, TRF_max=100, T2s_min=1, T2s_max=1, ω1_max=π/5, B1_max=1, greens=G);\nnothing #hide","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"The derivatives are not used here and are just assigned for demonstration purposes.","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"In order to replicate Fig. 7, we plot R₂ˢˡ(Tʳᶠ, α, B₁, T₂ˢ) for a varying α and T_textRFT_2^s:","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"α = (0.01:.01:1) * π\nTʳᶠoT₂ˢ = 5:100\n\nTʳᶠoT₂ˢ_m = repeat(reshape(TʳᶠoT₂ˢ, 1, :), length(α), 1)\nα_m = repeat(α, 1, size(TʳᶠoT₂ˢ_m, 2))\n\np = plot(xlabel=\"Tʳᶠ/T₂ˢ\", ylabel=\"α/π\", colorbar_title=\"T₂ˢˡ/T₂ˢ\")\ncontour!(p, TʳᶠoT₂ˢ, α ./ π, 1 ./ R₂ˢˡ.(TʳᶠoT₂ˢ_m, α_m, 1, 1), fill = true)\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Linear_Approximation/#Spin-Dynamics-during-a-single-RF-Pulse","page":"Linear Approximation","title":"Spin Dynamics during a single RF Pulse","text":"","category":"section"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"To replicate Fig. 8a, we simulate and plot the dynamics of a coupled spin system during a single π-pulse, starting from thermal equilibrium.","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"Tʳᶠ = 100e-6 # s\nT₂ˢ = 10e-6 # μs\nm0_5D = [0,0,m₀ᶠ,m₀ˢ,1]\nmfun(p, t; idxs=nothing) = typeof(idxs) <: Number ? 0 : m0_5D; # intialize history function, here with the ability to just call a single index\nnothing #hide","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"The full generalized Bloch model is solved by","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"param = (π/Tʳᶠ, 1, 0, m₀ˢ, R₁, R₂ᶠ, Rₓ, R₁, T₂ˢ, G)\nprob = DDEProblem(apply_hamiltonian_gbloch!, m0_5D, mfun, (0.0, Tʳᶠ), param)\nsol_pi_full = solve(prob);\nnothing #hide","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"and we evaluate the interpolated solution at the following time points:","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"t = (0:.01:1) * Tʳᶠ # s\nMpi_full = zeros(length(t),4)\nfor i in eachindex(t)\n    Mpi_full[i,:] = sol_pi_full(t[i])[1:4]\nend","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"Further, we calculate the linear approximation, which is simulated in a 6D-space as it explicitly models x^s:","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"m0_6D = [0,0,m₀ᶠ,0,m₀ˢ,1]\n\nMpi_appx = similar(Mpi_full)\nfor i in eachindex(t)\n    H = exp(hamiltonian_linear(π/Tʳᶠ, 1, 0, t[i], m₀ˢ, R₁, Rₓ, R₁, R₂ᶠ, R₂ˢˡ(Tʳᶠ, π, 1, T₂ˢ)))\n    Mpi_appx[i,:] = (H * m0_6D)[[1:3;5]]\nend","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"and plot the original generalized Bloch model and its linear approximation for comparison:","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"p = plot(xlabel=\"t [s]\", ylabel=\"m/m₀\")\nplot!(p, t, Mpi_full[:,1] / m₀ᶠ, label=\"xᶠ/m₀ᶠ original model\")\nplot!(p, t, Mpi_appx[:,1] / m₀ᶠ, label=\"xᶠ/m₀ᶠ linear approximation\")\nplot!(p, t, Mpi_full[:,3] / m₀ᶠ, label=\"zᶠ/m₀ᶠ original model\")\nplot!(p, t, Mpi_appx[:,3] / m₀ᶠ, label=\"zᶠ/m₀ᶠ linear approximation\")\nplot!(p, t, Mpi_full[:,4] / m₀ˢ, label=\"zˢ/m₀ˢ original model\")\nplot!(p, t, Mpi_appx[:,4] / m₀ˢ, label=\"zˢ/m₀ˢ linear approximation\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"We observe slight deviations of zˢ during the pulse, but a virtually perfect match at the end of the RF pulse.","category":"page"},{"location":"build_literate/Linear_Approximation/#RF-Pulses-with-Different-Flip-Angles","page":"Linear Approximation","title":"RF Pulses with Different Flip Angles","text":"","category":"section"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"To replicate Fig. 8b, we simulate the spin dynamics during multiple RF pulses with different flip angles α, each simulation starting from thermal equilibrium, and analyze the magnetization at the end of each pulse:","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"α = (.01:.01:1) * π\n\nM_full = zeros(length(α), 4)\nM_appx = similar(M_full)\nfor i in eachindex(α)\n    param = (α[i]/Tʳᶠ, 1, 0, m₀ˢ, R₁, R₂ᶠ, Rₓ, R₁, T₂ˢ, G)\n    prob = DDEProblem(apply_hamiltonian_gbloch!, m0_5D, mfun, (0.0, Tʳᶠ), param)\n    M_full[i,:] = solve(prob)[end][1:4]\n\n    u = exp(hamiltonian_linear(α[i]/Tʳᶠ, 1, 0, Tʳᶠ, m₀ˢ, R₁, R₂ᶠ, Rₓ, R₁, R₂ˢˡ(Tʳᶠ, α[i], 1, T₂ˢ))) * m0_6D\n    M_appx[i,:] = u[[1:3;5]]\nend\n\np = plot(xlabel=\"α/π\", ylabel=\"m/m₀\")\nplot!(p, α/π, M_appx[:,1] / m₀ᶠ, label=\"xᶠ/m₀ˢ original model\")\nplot!(p, α/π, M_full[:,1] / m₀ᶠ, label=\"xᶠ/m₀ˢ linear approximation\")\nplot!(p, α/π, M_appx[:,3] / m₀ᶠ, label=\"zᶠ/m₀ˢ original model\")\nplot!(p, α/π, M_full[:,3] / m₀ᶠ, label=\"zᶠ/m₀ˢ linear approximation\")\nplot!(p, α/π, M_appx[:,4] / m₀ˢ, label=\"zˢ/m₀ˢ original model\")\nplot!(p, α/π, M_full[:,4] / m₀ˢ, label=\"zˢ/m₀ˢ linear approximation\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"Visually, the linear approximation matches the full simulation well. The normalized root-mean-squared error of the linear approximation for x^f is","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"norm(M_appx[:,1] .- M_full[:,1]) / norm(M_full[:,1])","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"for z^f it is","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"norm(M_appx[:,3] .- M_full[:,3]) / norm(M_full[:,3])","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"and for z^s it is","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"norm(M_appx[:,4] .- M_full[:,4]) / norm(M_full[:,4])","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"which confirms the good concordance.","category":"page"},{"location":"build_literate/Linear_Approximation/#Benchmark","page":"Linear Approximation","title":"Benchmark","text":"","category":"section"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"We analyze the execution time for solving the full integro-differential equation:","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"param = (α[end]/Tʳᶠ, 1, 0, m₀ˢ, R₁, R₂ᶠ, Rₓ, R₁, T₂ˢ, G)\nprob = DDEProblem(apply_hamiltonian_gbloch!, m0_5D, mfun, (0.0, Tʳᶠ), param)\n@benchmark solve($prob)","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"The $ symbol interpolates the variable, which improves the accuracy of the timing measurement. We can compare this time to the time it takes to calculate the linear approximation, including the time it takes to evaluate the interpolated R₂ˢˡ:","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"@benchmark exp(hamiltonian_linear($(α[end]/Tʳᶠ), 1, 0, $Tʳᶠ, $m₀ˢ, $R₁, $R₂ᶠ, $Rₓ, $R₁, R₂ˢˡ($Tʳᶠ, $α[end], 1, $T₂ˢ))) * $m0_6D","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"We can see that linear approximation is about 4 orders of magnitude faster compared to the full model.","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"EditURL = \"https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/master/docs/src/tutorial_pulsetrain.jl\"","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"(Image: )","category":"page"},{"location":"build_literate/tutorial_pulsetrain/#Balanced-Hybrid-State-Free-Precession-Pulse-Sequence","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"","category":"section"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"This section explains the interface for calculating the spin evolution during a train of RF pulses, assuming balanced gradient moments (cf. Hybrid-state free precession in nuclear magnetic resonance). For this, we need the following packages:","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"using MRIgeneralizedBloch\nusing MAT\nusing Plots\nplotlyjs(bg = RGBA(31/255,36/255,36/255,1.0), ticks=:native); #hide\nnothing #hide","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"and we use the pulse train described in the paper Rapid quantitative magnetization transfer imaging: utilizing the hybrid state and the generalized Bloch model:","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"control = matread(normpath(joinpath(pathof(MRIgeneralizedBloch), \"../../docs/control_MT_v3p2_TR3p5ms_discretized.mat\")))\nα   = control[\"alpha\"]\nTRF = control[\"TRF\"]","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"and setting TR...","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"TR = 3.5e-3\nt = TR .* (1:length(TRF))\n\np1 = plot(t, α/π, ylabel=\"α/π\", label=:none)\np2 = plot(t, TRF, xlabel=\"t (s)\", ylabel=\"TRF (s)\", label=:none)\np = plot(p1, p2, layout=(2,1))\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"We simulate the signal for the following biophysical parameters:","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"m0s = 0.15\nR1f = 0.5   # 1/s\nR2f = 15    # 1/s\nRx = 30     # 1/s\nR1s = 3     # 1/s\nT2s = 10e-6 # s\nω0 = 0      # rad/s\nB1 = 1;     # in units of B1_nominal\nnothing #hide","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"For speed purposes, it is advisable to use the linear approximation of the generalized Bloch model, which requires a precomputed R_2^sl","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"R2slT = precompute_R2sl();\nnothing #hide","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"Now we have everything set up to calculate the signal. By default, the output is a complex valued array where each element describes the transversal magnetization x^f + i y^f of the free spin pool in each T_textR:","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"s_linapp = calculatesignal_linearapprox(α, TRF, TR, ω0, B1, m0s, R1f, R2f, Rx, R1s, T2s, R2slT)\n\np = plot(xlabel=\"t (s)\", ylabel=\"signal (normalized)\"; legend=:topleft)\nplot!(p, t, real.(vec(s_linapp)), label=\"Re(s); lin. approx.\")\nplot!(p, t, imag.(vec(s_linapp)), label=\"Im(s); lin. approx.\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"For comparison, we can also solve the full integro-differential equation (IDE) for each RF pulse, which is more accurate, but much slower:","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"s_ide = calculatesignal_gbloch_ide(α, TRF, TR, ω0, B1, m0s, R1f, R2f, Rx, R1s, T2s)\n\nplot!(p, t, real.(vec(s_ide)), label=\"Re(s); IDE\")\nplot!(p, t, imag.(vec(s_ide)), label=\"Im(s); IDE\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"Clicking on the legend entries allows to select and de-select individual graphs.","category":"page"},{"location":"build_literate/tutorial_pulsetrain/#Real-valued-magnetization-vector","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Real-valued magnetization vector","text":"","category":"section"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"As an alternative to the complex-valued signal, we can also calculate the full mangetization vector (x^f y^f z^f x^s z^s 1) by supplying the keyword argument output=:realmagnetization. Here, x, y, z denote the dimensions in space, the superscripts f and s denote the free and the semi-solid spin pool, respectively. We neglect the y^s component, assuming (without loss of generality) ωₓ = 0 and given that R_2^sl gg ω_0.","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"m_linapp = calculatesignal_linearapprox(α, TRF, TR, ω0, B1, m0s, R1f, R2f, Rx, R1s, T2s, R2slT;\n    output=:realmagnetization)\n\np = plot(xlabel=\"t (s)\", ylabel=\"magnetization (normalized)\"; legend=:topleft)\nplot!(p, t, [m_linapp[i][1] for i=1:size(m_linapp,1)] ./ (1 - m0s), label=\"xᶠ / m₀ᶠ\")\nplot!(p, t, [m_linapp[i][2] for i=1:size(m_linapp,1)] ./ (1 - m0s), label=\"yᶠ / m₀ᶠ\")\nplot!(p, t, [m_linapp[i][3] for i=1:size(m_linapp,1)] ./ (1 - m0s), label=\"zᶠ / m₀ᶠ\")\nplot!(p, t, [m_linapp[i][4] for i=1:size(m_linapp,1)] ./      m0s , label=\"xˢ / m₀ˢ\")\nplot!(p, t, [m_linapp[i][5] for i=1:size(m_linapp,1)] ./      m0s , label=\"zˢ / m₀ˢ\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/tutorial_pulsetrain/#Gradients","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Gradients","text":"","category":"section"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"The same interface can also be used to calculate the derivatives of the signal wrt. the biophysical parameters. One can specify any subset of derivatives in any order with a vector of identifyer objects:","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"grad_list=[grad_m0s(), grad_R1f(), grad_R2f(), grad_Rx(), grad_R1s(), grad_T2s(), grad_ω0(), grad_B1()];\nnothing #hide","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"Calling the function calculatesignal_linearapprox with the keyword argument grad_list and this vector","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"s_linapp = calculatesignal_linearapprox(α, TRF, TR, ω0, B1, m0s, R1f, R2f, Rx, R1s, T2s, R2slT;\n    grad_list=grad_list);\nnothing #hide","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"returns the derivatives in the specified order:","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"p = plot(xlabel=\"t (s)\", ylabel=\"signal (normalized)\"; legend=:topleft)\nplot!(p, t, real.(s_linapp[:,1,1]       ), label=\"Re(∂s/∂M₀ )*M₀\")\nplot!(p, t, real.(s_linapp[:,1,2] .* m0s), label=\"Re(∂s/∂m₀ˢ)*m₀ˢ\")\nplot!(p, t, real.(s_linapp[:,1,3] .* R1f), label=\"Re(∂s/∂R₁ᶠ)*R₁ᶠ\")\nplot!(p, t, real.(s_linapp[:,1,4] .* R2f), label=\"Re(∂s/∂R₂ᶠ)*R₂ᶠ\")\nplot!(p, t, real.(s_linapp[:,1,5] .* Rx ), label=\"Re(∂s/∂Rₓ )*Rₓ \")\nplot!(p, t, real.(s_linapp[:,1,6] .* R1s), label=\"Re(∂s/∂R₁ˢ)*R₁ˢ\")\nplot!(p, t, real.(s_linapp[:,1,7] .* T2s), label=\"Re(∂s/∂T₂ˢ)*T₂ˢ\")\nplot!(p, t, real.(s_linapp[:,1,8] .* ω0 ), label=\"Re(∂s/∂ω₀ )*ω₀ \")\nplot!(p, t, real.(s_linapp[:,1,9] .* B1 ), label=\"Re(∂s/∂B₁ )*B₁ \")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"Note that the first row is always the signal itself, which is equivalent to ∂s/∂M₀, as this toolbox always assumens M₀ = 1.","category":"page"},{"location":"build_literate/tutorial_pulsetrain/#Apparent-R","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Apparent R₁","text":"","category":"section"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"Above code calculates separate derivatives for R_1^f and R_1^s. Yet, many publications, including our own paper \"Rapid quantitative magnetization transfer imaging: utilizing the hybrid state and the generalized Bloch model\" assumes an apparent longitudinal relaxation rate R_1^a = R_1^f = R_1^f. The derivatives wrt. this apparent relaxation rate can be calcuated with","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"R1a = 1 # 1/s\ngrad_list=[grad_R1a()]\ns_linapp = calculatesignal_linearapprox(α, TRF, TR, ω0, B1, m0s, R1a, R2f, Rx, R1a, T2s, R2slT;\n    grad_list=grad_list)\n\np = plot(xlabel=\"t (s)\", ylabel=\"signal (normalized)\"; legend=:topleft)\nplot!(p, t, real.(s_linapp[:,1,1]       ), label=\"Re(∂s/∂M₀)/M₀\")\nplot!(p, t, real.(s_linapp[:,1,2] .* R1a), label=\"Re(∂s/∂R₁ᵃ)*R₁ᵃ\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"Note that R1a appears here twice in the arguments of the calculatesignal_linearapprox in place of R1f and R1s.","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"This page was generated using Literate.jl.","category":"page"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"EditURL = \"https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/master/docs/src/Greens_functions.jl\"","category":"page"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"(Image: )","category":"page"},{"location":"build_literate/Greens_functions/#Green's-Functions","page":"Green's Functions","title":"Green's Functions","text":"","category":"section"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"The Green's functions are given by the Fourier transform of the corresponding lineshapes. For a Lorentzian lineshape, the Green's function is","category":"page"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"\tG(ttau) = exp (-R_2^s (t-tau))  forall  t geq tau","category":"page"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"for a Gaussian lineshape it is","category":"page"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"\tG(ttau) = exp(- R_2^s^2 (t-tau)^2  2))","category":"page"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"and for super-Lorentzian lineshape it is","category":"page"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"\tG(ttau) = int_0^1 exp left(- R_2^s^2 (t - tau)^2 cdot  frac(3 zeta^2 - 1)^28 right) dzeta","category":"page"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"As evident from these equations, the Green's functions are merely a function of kappa = R_2^s cdot (t - tau) = (t - tau)  T_2^s, and in this package we implemented the functions as such: greens_lorentzian(κ), greens_gaussian(κ), and greens_superlorentzian(κ). These functions can be used to reproduce Fig. 1 in the generalized Bloch paper:","category":"page"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"using MRIgeneralizedBloch\nusing Plots\nplotlyjs(bg = RGBA(31/255,36/255,36/255,1.0), ticks=:native); #hide\nnothing #hide","category":"page"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"T₂ˢ = 10e-6 # s\nt = 0 : 1e-6 : 1e-3\np = plot(yaxis=:log, ylim=(1e-6,1), xlabel=\"(t-τ) [ms]\", ylabel=\"G((t-τ)/T₂ˢ)\")\nplot!(p, 1e3t, greens_lorentzian.(t ./ T₂ˢ), label=\"Lorentzian lineshape\")\nplot!(p, 1e3t, greens_gaussian.(t ./ T₂ˢ), label=\"Gaussian lineshape\")\nplot!(p, 1e3t, greens_superlorentzian.(t ./ T₂ˢ), label=\"super-Lorentzian l.\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"","category":"page"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"EditURL = \"https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/master/docs/src/tutorial_singlepulse.jl\"","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"(Image: )","category":"page"},{"location":"build_literate/tutorial_singlepulse/#Simulation-of-a-Single-RF-Pulse","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"","category":"section"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"The core of generalized Bloch model is implemented in the function apply_hamiltonian_gbloch!(∂m∂t, m, mfun, p, t), which calculates the derivative ∂m/∂t for a given magnetization vector m and stores it in-place in the the variable ∂m∂t. The function interface is written in a way that we can directly feed it into a differential equation solver of the DifferentialEquations.jl package.","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"For this example, we need the following packages:","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"using MRIgeneralizedBloch\nusing DifferentialEquations\nusing Plots\nplotlyjs(bg = RGBA(31/255,36/255,36/255,1.0), ticks=:native); #hide\nnothing #hide","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"We simulate the dynamics of a coupled spin system with the following parameters:","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"m0s = 0.15\nR1f = 0.3 # 1/s\nR2f = 15 # 1/s\nR1s = 2 # 1/s\nT2s = 10e-6 # s\nRx = 30; # 1/s\nnothing #hide","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"and the thermal equilibrium of the magnetization m = [xf; yf; zf; zs; 1]:","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"m0 = [0; 0; 1-m0s; m0s; 1];\nnothing #hide","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"during a rectangular RF-pulse with the flip angle and pulse duration","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"α = π\nTRF = 100e-6; # s\nnothing #hide","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"Further, we assume a perfectly calibrated, on-resonant RF-pulse:","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"B1 = 1\nω0 = 0; # rad/s\nnothing #hide","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"as well as a super-Lorentzian lineshape. We interpolate the corresponding Green's function to improve performance:","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"G = interpolate_greens_function(greens_superlorentzian, 0, TRF / T2s);\nnothing #hide","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"The generalized Bloch model is a so-called integro-differential equation where the derivative mt at the time t_1 does not just depend on m(t_1), but on m(t) for t in 0 t_1. This is solved with a delay differential equation (DDE) solver that stores an interpolated history function mfun(p, t), which we use in the apply_hamiltonian_gbloch! function to evaluate the integral. This history function has to be initialized with mfun(p, 0) = m0. Here, we use a slightly more complicated initialization that allows us to index the history function in apply_hamiltonian_gbloch!, which improves performance:","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"mfun(p, t; idxs=nothing) = typeof(idxs) <: Number ? m0[idxs] : m0;\nnothing #hide","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"With this, we are ready to formulate and solve the differential equation:","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"param = (α/TRF, B1, ω0, m0s, R1f, R2f, Rx, R1s, T2s, G) # defined by apply_hamiltonian_gbloch!\nprob = DDEProblem(apply_hamiltonian_gbloch!, m0, mfun, (0, TRF), param)\nsol = solve(prob)","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"The plot function is implemented for such solution objects and we can plot the solution simply with","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"p = plot(sol, labels=[\"xᶠ\" \"yᶠ\" \"zᶠ\" \"zˢ\" \"1\"], xlabel=\"t [s]\", ylabel=\"m(t)\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"More details on the interface, including the linear approximation of the generalized Bloch model can found in the following scripts that replicate all simulations, data analyses, and figures of the generalized Bloch paper.","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"This page was generated using Literate.jl.","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"EditURL = \"https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/master/docs/src/Simulation_Pulse.jl\"","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"(Image: )","category":"page"},{"location":"build_literate/Simulation_Pulse/#RF-Pulse-Simulation","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"","category":"section"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"The following code replicates the RF-pulse simulation of Fig. 3 and plots the z^s-magnetization at the end of respective pulse.","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"For these simulations we need the following packages:","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"using MRIgeneralizedBloch\nusing QuadGK\nusing DifferentialEquations\nusing SpecialFunctions\nusing Plots\nplotlyjs(bg = RGBA(31/255,36/255,36/255,1.0), ticks=:native); #hide\nnothing #hide","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"and we simulate an isolated semi-solid spin pool with the following parameters:","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"R₁ = 1 # 1/s\nT₂ˢ = 10e-6; # s\nnothing #hide","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"Here, we simulate π-pulses with the following parameters:","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"α = π\nTʳᶠ = exp.(range(log(2e-7), log(1e-1), length=100)) # s\nω₁ = α ./ Tʳᶠ # rad/s\nω₀ = 0; # rad/s\nnothing #hide","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"Replace first line with α = π/4 or α = π/2 to simulate the other two rows of Fig. 3.","category":"page"},{"location":"build_literate/Simulation_Pulse/#Lorentzian-Lineshape","page":"RF-Pulse Simulation","title":"Lorentzian Lineshape","text":"","category":"section"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"In this script, we simulate the three lineshapes separately, starting with the Lorentzian lineshape for which the Bloch model provides a ground truth.","category":"page"},{"location":"build_literate/Simulation_Pulse/#Bloch-Model","page":"RF-Pulse Simulation","title":"Bloch Model","text":"","category":"section"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"We can formulate the Bloch model as","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"partial_t beginpmatrix x  y  z  1 endpmatrix = beginpmatrix\n-R_2  -ω_0  ω_1  0 \nω_0  -R_2  0  0 \n-ω_1  0  -R_1  R_1 \n0  0  0  0\nendpmatrix beginpmatrix x  y  z  1 endpmatrix ","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"where the matrix is the Hamiltonian of the Bloch model. For a constant ω_0 and ω_1, we can evaluate the Bloch model by taking the  matrix exponential of its Hamiltonian:","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"H(ω₁, ω₀, R₂, R₁) = [-R₂ -ω₀  ω₁  0;\n                      ω₀ -R₂   0  0;\n                     -ω₁   0 -R₁ R₁;\n                       0   0   0  0]\n\nz_Bloch = similar(Tʳᶠ)\nfor i = 1:length(Tʳᶠ)\n    (_, _, z_Bloch[i], _)  = exp(H(ω₁[i], ω₀, 1 / T₂ˢ, R₁) * Tʳᶠ[i]) * [0; 0; 1; 1]\nend","category":"page"},{"location":"build_literate/Simulation_Pulse/#Graham's-Spectral-Model","page":"RF-Pulse Simulation","title":"Graham's Spectral Model","text":"","category":"section"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"Graham's spectral model is derived by integrating over the lineshape multiplied by the spectral response function of the RF-pulse. This results in the RF-induced saturation rate Rʳᶠ that is used in an exponential model:","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"Rʳᶠ = @. ω₁^2 * T₂ˢ * ((exp(-Tʳᶠ / T₂ˢ) -1) * T₂ˢ + Tʳᶠ) / Tʳᶠ\nz_Graham_spec_Lorentzian = @. (Rʳᶠ * exp(-Tʳᶠ * (R₁ + Rʳᶠ)) + R₁) / (R₁ + Rʳᶠ);\nnothing #hide","category":"page"},{"location":"build_literate/Simulation_Pulse/#Graham's-Single-Frequency-Approximation","page":"RF-Pulse Simulation","title":"Graham's Single Frequency Approximation","text":"","category":"section"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"In the single frequency approximation, Graham assumes that the RF-pulse has only a single frequency, which reduces Rʳᶠ to","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"g_Lorentzian(ω₀) = T₂ˢ / π ./ (1 .+ (T₂ˢ .* ω₀).^2)\nRʳᶠ = @. π * ω₁^2 * g_Lorentzian(ω₀)\nz_Graham_SF_approx_Lorentzian = @. (Rʳᶠ * exp(-Tʳᶠ * (R₁ + Rʳᶠ)) + R₁) / (R₁ + Rʳᶠ);\nnothing #hide","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"where g_Lorentzian(ω₀) denotes the Lorentzian lineshape.","category":"page"},{"location":"build_literate/Simulation_Pulse/#Sled's-Model","page":"RF-Pulse Simulation","title":"Sled's Model","text":"","category":"section"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"Sled's model is given by the ordinary differential equation (ODE)","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"partial_t z(t) = left(-pi int_0^t G(t-τ) omega_1(τ)^2 dτ right) z(t)  + R_1 (1-z)","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"where G(t-τ) is the Green's function. The Hamiltonian of this ODE is implemented in apply_hamiltonian_sled! and the ODE can be solved with the DifferentialEquations.jl package:","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"z₀ = [1] # initial z-magnetization\nz_Sled_Lorentzian = similar(Tʳᶠ)\nfor i = 1:length(Tʳᶠ)\n    param = (ω₁[i], 1, ω₀, R₁, T₂ˢ, greens_lorentzian)\n    prob = ODEProblem(apply_hamiltonian_sled!, z₀, (0, Tʳᶠ[i]), param)\n    z_Sled_Lorentzian[i] = solve(prob)[end][1]\nend","category":"page"},{"location":"build_literate/Simulation_Pulse/#Generalized-Bloch-Model","page":"RF-Pulse Simulation","title":"Generalized Bloch Model","text":"","category":"section"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"The generalized Bloch model is given by the integro-differential equation (IDE)","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"partial_t z(t) = - ω_1(t) int_0^t G(tτ) ω_1(τ) z(τ) dτ + R_1 (1 - z(t)) ","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"or by","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"partial_t z(t) = - ω_y(t) int_0^t G(tτ) ω_y(τ) z(τ) dτ - ω_x(t) int_0^t G(tτ) ω_x(τ) z(τ) dτ + R_1 (1 - z(t)) ","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"for off-resonant RF-pulses with ω_1 = ω_x + i ω_y. The Hamiltonian of the IDE is implemented in apply_hamiltonian_gbloch! and we can solve this IDE with the delay-differential equation (DDE) solver of the DifferentialEquations.jl package:","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"z_fun(p, t) = [1.0]; # initialize history function (will be populated with an interpolation by the DDE solver)\n\nz_gBloch_Lorentzian = similar(Tʳᶠ)\nfor i = 1:length(Tʳᶠ)\n    param = (ω₁[i], 1, ω₀, R₁, T₂ˢ, greens_lorentzian)\n    prob = DDEProblem(apply_hamiltonian_gbloch!, z₀, z_fun, (0, Tʳᶠ[i]), param)\n    z_gBloch_Lorentzian[i] = solve(prob)[end][1]\nend","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"Now we have solved all five models and can plot the solutions for comparison:","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"p = plot(xaxis=:log, legend=:bottomright, xlabel=\"Tʳᶠ [s]\", ylabel=\"zˢ(Tʳᶠ)\")\nplot!(p, Tʳᶠ, z_gBloch_Lorentzian, label=\"generalized Bloch model\")\nplot!(p, Tʳᶠ, Tʳᶠ .* 0 .+ cos(α), label=\"cos(α)\")\nplot!(p, Tʳᶠ, z_Sled_Lorentzian, label=\"Sled's model\")\nplot!(p, Tʳᶠ, z_Graham_spec_Lorentzian, label=\"Graham's spectral model\")\nplot!(p, Tʳᶠ, z_Graham_SF_approx_Lorentzian, label=\"Graham's single frequency approximation\")\nplot!(p, Tʳᶠ, z_Bloch, label=\"Bloch model\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Simulation_Pulse/#Gaussian-Lineshape","page":"RF-Pulse Simulation","title":"Gaussian Lineshape","text":"","category":"section"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"We can repeat these simulations (with the exception of the Bloch model) for the Gaussian lineshape:","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"Rʳᶠ = @. ω₁^2 * T₂ˢ * (2 * T₂ˢ * (exp(-(Tʳᶠ/T₂ˢ)^2/2)-1) + sqrt(2π) * Tʳᶠ * erf(Tʳᶠ/T₂ˢ/sqrt(2))) / (2 * Tʳᶠ)\nz_Graham_spec_Gaussian = @. (Rʳᶠ * exp(-Tʳᶠ * (R₁ + Rʳᶠ)) + R₁) / (R₁ + Rʳᶠ)\n\ng_Gaussian(ω₀) = T₂ˢ / sqrt(2π) * exp(-(T₂ˢ * ω₀)^2 / 2) # lineshape\nRʳᶠ = @. π * ω₁^2 * g_Gaussian(ω₀)\nz_Graham_SF_approx_Gaussian = @. (Rʳᶠ * exp(-Tʳᶠ * (R₁ + Rʳᶠ)) + R₁) / (R₁ + Rʳᶠ)\n\nz_Sled_Gaussian = similar(Tʳᶠ)\nfor i = 1:length(Tʳᶠ)\n    param = (ω₁[i], 1, ω₀, R₁, T₂ˢ, greens_gaussian)\n    prob = ODEProblem(apply_hamiltonian_sled!, z₀, (0, Tʳᶠ[i]), param)\n    z_Sled_Gaussian[i] = solve(prob)[end][1]\nend\n\nz_gBloch_Gaussian = similar(Tʳᶠ)\nfor i = 1:length(Tʳᶠ)\n    param = (ω₁[i], 1, ω₀, R₁, T₂ˢ, greens_gaussian)\n    prob = DDEProblem(apply_hamiltonian_gbloch!, z₀, z_fun, (0, Tʳᶠ[i]), param)\n    z_gBloch_Gaussian[i] = solve(prob)[end][1]\nend\n\np = plot(xaxis=:log, legend=:bottomright, xlabel=\"Tʳᶠ [s]\", ylabel=\"zˢ(Tʳᶠ)\")\nplot!(p, Tʳᶠ, z_gBloch_Gaussian, label=\"generalized Bloch model\")\nplot!(p, Tʳᶠ, Tʳᶠ .* 0 .+ cos(α), label=\"cos(α)\")\nplot!(p, Tʳᶠ, z_Sled_Gaussian, label=\"Sled's model\")\nplot!(p, Tʳᶠ, z_Graham_spec_Gaussian, label=\"Graham's spectral model\")\nplot!(p, Tʳᶠ, z_Graham_SF_approx_Gaussian, label=\"Graham's single frequency approximation\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Simulation_Pulse/#Super-Lorentzian-Lineshape","page":"RF-Pulse Simulation","title":"Super-Lorentzian Lineshape","text":"","category":"section"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"Further, we can repeat these simulations for the super-Lorentzian lineshape with the exception of Graham's single frequency approximation, as the super-Lorentzian lineshape diverges at ω_0  0.","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"G_superLorentzian = interpolate_greens_function(greens_superlorentzian, 0, maximum(Tʳᶠ)/T₂ˢ)\n\nf_PSD(τ) = quadgk(ct -> (4 / τ / abs(1 - 3 * ct^2) * (exp(- τ^2 / 8 * (1 - 3 * ct^2)^2) - 1) + sqrt(2π) * erf(τ / 2 / sqrt(2) * abs(1 - 3 * ct^2))) / abs(1 - 3 * ct^2), 0.0, 1.0)[1]\nRʳᶠ = @. f_PSD(Tʳᶠ / T₂ˢ) * ω₁^2 * T₂ˢ\nz_Graham_spec_superLorentzian = @. (Rʳᶠ * exp(-Tʳᶠ * (R₁ + Rʳᶠ)) + R₁) / (R₁ + Rʳᶠ)\n\nz_Sled_superLorentzian = similar(Tʳᶠ)\nfor i = 1:length(Tʳᶠ)\n    param = (ω₁[i], 1, ω₀, R₁, T₂ˢ, G_superLorentzian)\n    prob = ODEProblem(apply_hamiltonian_sled!, z₀, (0, Tʳᶠ[i]), param)\n    z_Sled_superLorentzian[i] = solve(prob)[end][1]\nend\n\nz_gBloch_superLorentzian = similar(Tʳᶠ)\nfor i = 1:length(Tʳᶠ)\n    param = (ω₁[i], 1, ω₀, R₁, T₂ˢ, G_superLorentzian)\n    prob = DDEProblem(apply_hamiltonian_gbloch!, z₀, z_fun, (0, Tʳᶠ[i]), param)\n    z_gBloch_superLorentzian[i] = solve(prob)[end][1]\nend\n\np = plot(xaxis=:log, legend=:bottomright, xlabel=\"Tʳᶠ [s]\", ylabel=\"zˢ(Tʳᶠ)\")\nplot!(p, Tʳᶠ, z_gBloch_superLorentzian, label=\"generalized Bloch model\")\nplot!(p, Tʳᶠ, Tʳᶠ .* 0 .+ cos(α), label=\"cos(α)\")\nplot!(p, Tʳᶠ, z_Sled_superLorentzian, label=\"Sled's model\")\nplot!(p, Tʳᶠ, z_Graham_spec_superLorentzian, label=\"Graham's spectral model\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"This simulation reveals the most pronounced deviations of the generalized Bloch model from established models due to the slower decay of the super-Lorentzian Green's function.","category":"page"},{"location":"build_literate/Simulation_Pulse/#Error-Analysis","page":"RF-Pulse Simulation","title":"Error Analysis","text":"","category":"section"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"Assuming a super-Lorentzian lineshape, we quantify the deviations of Sled's model from the generalized Bloch model:","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"Tʳᶠᵢ = 1e-3 # s\nω₁ᵢ = α / Tʳᶠᵢ # rad/s\nparam = (ω₁ᵢ, 1, ω₀, R₁, T₂ˢ, G_superLorentzian)\n\nprob = ODEProblem(apply_hamiltonian_sled!, z₀, (0, Tʳᶠᵢ), param)\nz_Sled_superLorentzian_i = solve(prob)[end][1]\n\nprob = DDEProblem(apply_hamiltonian_gbloch!, z₀, z_fun, (0, Tʳᶠᵢ), param)\nz_gBloch_superLorentzian_i = solve(prob)[end][1]\n\nz_Sled_superLorentzian_i - z_gBloch_superLorentzian_i","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"For T_textRF = 1ms, the deviations are small compared to the thermal equilibrium magnetization z^s_0 = 1, but with T_textRF = 01ms, this deviation becomes sizable:","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"Tʳᶠᵢ = 1e-4 # s\nω₁ᵢ = α / Tʳᶠᵢ # rad/s\nparam = (ω₁ᵢ, 1, ω₀, R₁, T₂ˢ, G_superLorentzian)\n\nprob = ODEProblem(apply_hamiltonian_sled!, z₀, (0, Tʳᶠᵢ), param)\nz_Sled_superLorentzian_i = solve(prob)[end][1]\n\nprob = DDEProblem(apply_hamiltonian_gbloch!, z₀, z_fun, (0, Tʳᶠᵢ), param)\nz_gBloch_superLorentzian_i = solve(prob)[end][1]\n\nz_Sled_superLorentzian_i - z_gBloch_superLorentzian_i","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"EditURL = \"https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/master/docs/src/Simulation_ContinuousWave.jl\"","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"(Image: )","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/#Continuous-Wave-Simulation","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"","category":"section"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"The following code replicates the continuous wave simulation of Fig. 2 and is slightly more comprehensive in the sense that all discussed models are simulated.","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"For these simulations we need the following packages:","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"using MRIgeneralizedBloch\nusing DifferentialEquations\nusing QuadGK\nusing Plots\nplotlyjs(bg = RGBA(31/255,36/255,36/255,1.0), ticks=:native); #hide\nnothing #hide","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"and we simulate an isolated semi-solid spin pool with the following parameters:","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"R₁ = 1.0 # 1/s\nT₂ˢ = 10e-6 # s\n\nTʳᶠ = 2e-3 # s\nω₁ = 2000π # rad/s\nω₀ = 200π # rad/s\n\nt = range(0, Tʳᶠ, length=1001) # time points for plotting\ntspan = (0.0, Tʳᶠ); # simulation range\nnothing #hide","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"These parameters correspond to Fig. 2b, the parameters for replicating Fig. 2a are ω₁ = 200π and Tʳᶠ = 1s.","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/#Lorentzian-Lineshape","page":"Continuous Wave Simulation","title":"Lorentzian Lineshape","text":"","category":"section"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"In this script, we simulate the three lineshapes separately, starting with the Lorentzian lineshape for which the Bloch model provides a ground truth.","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/#Bloch-Model","page":"Continuous Wave Simulation","title":"Bloch Model","text":"","category":"section"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"We can formulate the Bloch model as","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"partial_t beginpmatrix x  y  z  1 endpmatrix = beginpmatrix\n-R_2  -ω_0  ω_1  0 \nω_0  -R_2  0  0 \n-ω_1  0  -R_1  R_1 \n0  0  0  0\nendpmatrix beginpmatrix x  y  z  1 endpmatrix ","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"where the matrix is the Hamiltonian of the Bloch model. For a constant ω_0 and ω_1, we can evaluate the Bloch model by taking the  matrix exponential of its Hamiltonian:","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"H(ω₁, ω₀, R₂, R₁) = [-R₂  -ω₀  ω₁  0;\n                       ω₀ -R₂   0  0;\n                      -ω₁   0 -R₁ R₁;\n                        0   0   0  0]\n\nz_Bloch = similar(t)\nfor i = 1:length(t)\n    (_, _, z_Bloch[i], _) = exp(H(ω₁, ω₀, 1 / T₂ˢ, R₁) * t[i]) * [0; 0; 1; 1]\nend","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/#Henkelman's-Steady-State-Solution","page":"Continuous Wave Simulation","title":"Henkelman's Steady-State Solution","text":"","category":"section"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"When assuming an isolated semi-solid pool, Eq. (9) in Henkelman, R. Mark, et al. \"Quantitative interpretation of magnetization transfer.\" Magnetic resonance in medicine 29.6 (1993): 759-766 reduces to","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"g_Lorentzian(ω₀) = T₂ˢ / π / (1 + (T₂ˢ * ω₀)^2)\nz_steady_state_Lorentzian = R₁ / (R₁ + π * ω₁^2 * g_Lorentzian(ω₀))","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"where g_Lorentzian(ω₀) is the Lorentzian lineshape.","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/#Graham's-Single-Frequency-Approximation","page":"Continuous Wave Simulation","title":"Graham's Single Frequency Approximation","text":"","category":"section"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"The lineshape is also used to calculate Graham's single frequency approximation, which describes an exponential decay with the RF-induced saturation rate Rʳᶠ:","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"Rʳᶠ = π * ω₁^2 * g_Lorentzian(ω₀)\nz_Graham_Lorentzian = @. (Rʳᶠ * exp(-t * (R₁ + Rʳᶠ)) + R₁) / (R₁ + Rʳᶠ);\nnothing #hide","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/#Sled's-Model","page":"Continuous Wave Simulation","title":"Sled's Model","text":"","category":"section"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"Sled's model is given by the ordinary differential equation (ODE)","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"partial_t z(t) = left(-pi int_0^t G(t-τ) omega_1(τ)^2 dτ right) z(t)  + R_1 (1-z)","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"where G(t-τ) is the Green's function. The Hamiltonian of this ODE is implemented in apply_hamiltonian_sled! and we solve this ODE with the DifferentialEquations.jl package:","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"z₀ = [1.0] # initial z-magnetization\nparam = (ω₁, 1, ω₀, R₁, T₂ˢ, greens_lorentzian) # defined by apply_hamiltonian_sled!\nprob = ODEProblem(apply_hamiltonian_sled!, z₀, tspan, param)\nz_Sled_Lorentzian = solve(prob);\nnothing #hide","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/#Generalized-Bloch-Model","page":"Continuous Wave Simulation","title":"Generalized Bloch Model","text":"","category":"section"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"The generalized Bloch model is an integro-differential equation (IDE) as it depends on z(τ) instead of z(t):","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"partial_t z(t) = - ω_1(t) int_0^t G(tτ) ω_1(τ) z(τ) dτ + R_1 (1 - z(t)) ","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"For off-resonant RF-pulses with ω_1 = ω_x + i ω_y, it is given by","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"partial_t z(t) = - ω_y(t) int_0^t G(tτ) ω_y(τ) z(τ) dτ - ω_x(t) int_0^t G(tτ) ω_x(τ) z(τ) dτ + R_1 (1 - z(t)) ","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"The Hamiltonian of the IDE is implemented in apply_hamiltonian_gbloch! and we can solve this IDE with the delay-differential equation (DDE) solver of the DifferentialEquations.jl package:","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"zfun(p, t) = [1.0] # initialize history function (will be populated with an interpolation by the DDE solver)\n\nparam = (ω₁, 1, ω₀, R₁, T₂ˢ, greens_lorentzian) # defined by apply_hamiltonian_gbloch!\nprob = DDEProblem(apply_hamiltonian_gbloch!, z₀, zfun, tspan, param)\nz_gBloch_Lorentzian = solve(prob);\nnothing #hide","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"Now that we have solved all five models, we can plot the solutions for comparison:","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"p = plot(xlabel=\"t [ms]\", ylabel=\"zˢ(t)\")\nplot!(p, 1e3t, zero(similar(t)) .+ z_steady_state_Lorentzian, label=\"Henkelman's steady-state\")\nplot!(p, 1e3t, z_Graham_Lorentzian, label=\"Graham's model\")\nplot!(p, 1e3t, (hcat(z_Sled_Lorentzian(t).u...)'), label=\"Sled's model\")\nplot!(p, 1e3t, (hcat(z_gBloch_Lorentzian(t).u...)'), label=\"generalized Bloch model\")\nplot!(p, 1e3t, z_Bloch, label=\"Bloch model\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"Zooming into the plot, reveals virtually perfect (besides numerical differences) agreement between Bloch and generalized Bloch model and subtle, but existing differences when compared to the other models. Choosing a longer T₂ˢ amplifies these differences.","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/#Gaussian-Lineshape","page":"Continuous Wave Simulation","title":"Gaussian Lineshape","text":"","category":"section"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"We can repeat these simulations (with the exception of the Bloch model) for the Gaussian lineshape:","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"g_Gaussian(ω₀) = T₂ˢ / sqrt(2π) * exp(-(T₂ˢ * ω₀)^2 / 2)\nz_steady_state_Gaussian = R₁ / (R₁ + π * ω₁^2 * g_Gaussian(ω₀))\n\nRʳᶠ = π * ω₁^2 * g_Gaussian(ω₀)\nz_Graham_Gaussian = @. (Rʳᶠ * exp(-t * (R₁ + Rʳᶠ)) + R₁) / (R₁ + Rʳᶠ)\n\nparam = (ω₁, 1, ω₀, R₁, T₂ˢ, greens_gaussian) # defined by apply_hamiltonian_sled!\nprob = ODEProblem(apply_hamiltonian_sled!, z₀, tspan, param)\nz_Sled_Gaussian = solve(prob)\n\nprob = DDEProblem(apply_hamiltonian_gbloch!, z₀, zfun, tspan, param)\nz_gBloch_Gaussian = solve(prob)\n\np = plot(xlabel=\"t [ms]\", ylabel=\"zˢ(t)\")\nplot!(p, 1e3t, zero(similar(t)) .+ z_steady_state_Gaussian, label=\"Henkelman's steady-state\")\nplot!(p, 1e3t, z_Graham_Gaussian, label=\"Graham' model\")\nplot!(p, 1e3t, (hcat(z_Sled_Gaussian(t).u...)'), label=\"Sled's model\")\nplot!(p, 1e3t, (hcat(z_gBloch_Gaussian(t).u...)'), label=\"generalized Bloch model\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/#Super-Lorentzian-Lineshape","page":"Continuous Wave Simulation","title":"Super-Lorentzian Lineshape","text":"","category":"section"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"And we can repeat these simulations (with the exception of the Bloch model) for the super-Lorentzian lineshape, which reveals the most pronounced deviations between the models due to the substantially slower decay of the Green's function:","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"g_superLorentzian(ω₀) = sqrt(2 / π) * T₂ˢ * quadgk(ct -> exp(-2 * (T₂ˢ * ω₀ / abs(3 * ct^2 - 1))^2) / abs(3 * ct^2 - 1), 0.0, sqrt(1 / 3), 1)[1]\nz_steady_state_superLorentzian = R₁ / (R₁ + π * ω₁^2 * g_superLorentzian(ω₀))\n\nRʳᶠ = π * ω₁^2 * g_superLorentzian(ω₀)\nz_Graham_superLorentzian = @. (Rʳᶠ * exp(-t * (R₁ + Rʳᶠ)) + R₁) / (R₁ + Rʳᶠ)\n\nG_superLorentzian = interpolate_greens_function(greens_superlorentzian, 0, Tʳᶠ/T₂ˢ)\n\nparam = (ω₁, 1, ω₀, R₁, T₂ˢ, G_superLorentzian)\nprob = ODEProblem(apply_hamiltonian_sled!, z₀, tspan, param)\nz_Sled_superLorentzian = solve(prob)\n\nprob = DDEProblem(apply_hamiltonian_gbloch!, z₀, zfun, tspan, param)\nz_gBloch_superLorentzian = solve(prob)\n\n\np = plot(xlabel=\"t [ms]\", ylabel=\"zˢ(t)\")\nplot!(p, 1e3t, zero(similar(t)) .+ z_steady_state_superLorentzian, label=\"Henkelman's steady-state\")\nplot!(p, 1e3t, z_Graham_superLorentzian, label=\"Graham's model\")\nplot!(p, 1e3t, (hcat(z_Sled_superLorentzian(t).u...)'), label=\"Sled's model\")\nplot!(p, 1e3t, (hcat(z_gBloch_superLorentzian(t).u...)'), label=\"generalized Bloch model\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"EditURL = \"https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/master/docs/src/NLLS.jl\"","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"(Image: )","category":"page"},{"location":"build_literate/NLLS/#Non-Linear-Least-Square-Fitting","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"","category":"section"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"This section gives a brief overview of the interface to fit the generalized Bloch model to hybrid-state free precession data. We use the LsqFit.jl package and supply the algorithm with analytic gradients that are calcualted with the calculatesignal_linearapprox function that implements the linear approximation of the generalized Bloch model for a train of rectangular RF pulses.","category":"page"},{"location":"build_literate/NLLS/#Basic-Interface","page":"Non-Linear Least Square Fitting","title":"Basic Interface","text":"","category":"section"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"This tutorial uses the following packages:","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"using MRIgeneralizedBloch\nusing MAT\nusing LinearAlgebra\nusing Plots\nplotlyjs(bg = RGBA(31/255,36/255,36/255,1.0), ticks=:native); #hide\nnothing #hide","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"and we demonstrate the concept at the example of the RF pulse train that we publised in the paper Rapid quantitative magnetization transfer imaging: utilizing the hybrid state and the generalized Bloch model:","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"control = matread(normpath(joinpath(pathof(MRIgeneralizedBloch), \"../../docs/control_MT_v3p2_TR3p5ms_discretized.mat\")))\nα   = control[\"alpha\"]\nTRF = control[\"TRF\"]\n\nTR = 3.5e-3\nt = TR .* (1:length(TRF));\nnothing #hide","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"As an example we can assume the following ground truth parameters","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"m0s = 0.15\nR1f = 0.5 # 1/s\nR2f = 17 # 1/s\nRx = 30 # 1/s\nR1s = 3 # 1/s\nT2s = 12e-6 # s\nω0 = 100 # rad/s\nB1 = 0.9; # in units of B1_nominal\nnothing #hide","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"precomupte the linear approximation","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"R2slT = precompute_R2sl();\nnothing #hide","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"and simulate the signal:","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"s = calculatesignal_linearapprox(α, TRF, TR, ω0, B1, m0s, R1f, R2f, Rx, R1s, T2s, R2slT)\ns = vec(s)","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"To make this example a bit more realistic, we add complex valued Gaussian noise:","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"s .+= 0.01 * randn(ComplexF64, size(s));\nnothing #hide","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"Now we can fit the model to the noisy data:","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"qM = fit_gBloch(s, α, TRF, TR; R2slT=R2slT)","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"The last keyword argument is optional. It allows to recycle the precomputed R2sl, which improves speed. If not specified, it is re-calculated internally.","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"We can access the fitted parameters with","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"qM.m0s","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"qM.R1f # 1/s","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"qM.R2f # 1/s","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"qM.Rx # 1/s","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"qM.R1s # 1/s","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"1e6qM.T2s # μs","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"qM.ω0 # rad/s","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"qM.B1 # 1/B1_nominal","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"We can also simulate the signal wiht the fitted parameters","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"s_fitted = calculatesignal_linearapprox(α, TRF, TR, qM.ω0, qM.B1, qM.m0s, qM.R1f, qM.R2f, qM.Rx, qM.R1s, qM.T2s, R2slT)\ns_fitted = vec(s_fitted);\nnothing #hide","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"and compare it to the noisy data:","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"p = plot(xlabel=\"t (s)\", ylabel=\"signal (normalized)\", legend=:topleft)\nplot!(p, t, real.(s), label=\"Re(s)\")\nplot!(p, t, imag.(s), label=\"Im(s)\")\nplot!(p, t, real.(s_fitted), label=\"Re(s_fitted)\")\nplot!(p, t, imag.(s_fitted), label=\"Im(s_fitted)\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/NLLS/#Bounds-and-Fixed-Parameters","page":"Non-Linear Least Square Fitting","title":"Bounds and Fixed Parameters","text":"","category":"section"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"Above example uses the default bounds","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"reM0 = (-Inf,   1,  Inf)","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"imM0 = (-Inf,   0,  Inf)","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"m0s  = (   0, 0.2,    1)","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"R1f  = (   0, 0.3,  Inf)","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"R2f  = (   0,  15,  Inf)","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"Rx   = (   0,  20,  Inf)","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"R1s  = (   0,   3,  Inf)","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"T2s  = (8e-6,1e-5,12e-6)","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"ω0   = (-Inf,   0,  Inf)","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"B1   = (   0,   1,  1.5)","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"where the three entries refer to (minimum, start_value, maximum)","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"With keywords, one can modify each of these bounds. For example:","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"qM = fit_gBloch(s, α, TRF, TR; R2slT=R2slT, m0s  = (0.1, 0.3, 0.5));\nnothing #hide","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"starts the fit at m0s = 0.3 and uses a lower bound of 0.1 and an upper bound of 0.5. Alternatively, one also fix parameters to specified values:","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"qM = fit_gBloch(s, α, TRF, TR; R2slT=R2slT, ω0 = 0, B1 = 1);\nnothing #hide","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"In this case, the graients wrt. ω0 and B1 are not calculated and the result is accordingly","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"qM.ω0","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"qM.B1","category":"page"},{"location":"build_literate/NLLS/#Linear-Compression","page":"Non-Linear Least Square Fitting","title":"Linear Compression","text":"","category":"section"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"As originally suggested by McGivney et al. for MR Fingerprinting, the manifold of signal evolution or fingerprints is low rank and it is often beneficial to reconstruct images directly in this domain. We can calculate the corresponding basis functions with","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"sv = Array{ComplexF64}(undef, length(s), 50)\nfor i=1:size(sv,2)\n    sv[:,i] = calculatesignal_linearapprox(α, TRF, TR, 500randn(), 0.8 + 0.4rand(), rand(), rand(), 20rand(), 30rand(), 3rand(), 8e-6+5e-6rand(), R2slT)\nend\nu, _, _ = svd(sv)\nu = u[:,1:9];\nnothing #hide","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"where the rank 9 was chosen heuristically. We can compress the noisy signal with","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"sc = u' * s","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"and fit it by calling fit_gBloch with the keyword argument u=u:","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"qM = fit_gBloch(sc, α, TRF, TR; R2slT=R2slT, u=u)","category":"page"},{"location":"build_literate/NLLS/#Apparent-R1","page":"Non-Linear Least Square Fitting","title":"Apparent R1","text":"","category":"section"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"Above fits tread R1f and R1s of the free and the semi-solid as independant parameters. As we discussed in our paper, many publications in the literature assume an apparent R1a = R1f = R1s. The corresponding model can be fitted by specifying fit_apparentR1=true:","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"R1a = 1 # 1/s\ns = calculatesignal_linearapprox(α, TRF, TR, ω0, B1, m0s, R1a, R2f, Rx, R1a, T2s, R2slT)\nqM = fit_gBloch(vec(s), α, TRF, TR; fit_apparentR1=true, R1a = (0, 0.7, Inf), R2slT=R2slT)","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"Here, we specified the limits of R1a explicitely, which is optional.","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Author = \"Jakob Assländer\"\nCurrentModule = MRIgeneralizedBloch","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"In the following, you find the documentation of all exported functions of the MRIgeneralizedBloch.jl package:","category":"page"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [MRIgeneralizedBloch]","category":"page"},{"location":"api/#MRIgeneralizedBloch.RF_power!-NTuple{4, Any}","page":"API","title":"MRIgeneralizedBloch.RF_power!","text":"F = RFpower!(gradω1, grad_TRF, ω1, TRF; λ=1, Pmax=3e6, TR=3.5e-3)\n\nCalculate RF power penalty and over-write the gradients in place.\n\nArguments\n\ngrad_ω1::Vector{<:Number}: Gradient of control, which will be over-written in place\ngrad_TRF::Vector{<:Number}: Gradient of control, which will be over-written in place\nω1::Vector{<:Number}: Control vector\nTRF::Vector{<:Number}: Control vector\n\nOptional Keyword Arguments:\n\nλ::Number: regularization parameter\nPmax::Number: Maximum average power deposition in (rad/s)²; everything above this value will be penalized and with an appropriate λ, the resulting power should be equal or less than this value.\nTR::Number: Repetition time of the pulse sequence\n\nExamples\n\njulia> using MRIgeneralizedBloch\n\njulia> ω1 = 4000π * rand(100);\n\njulia> TRF = 500e-6 * rand(100);\n\njulia> grad_ω1 = similar(ω1);\n\njulia> grad_TRF = similar(ω1);\n\njulia> F = MRIgeneralizedBloch.RF_power!(grad_ω1, grad_TRF, ω1, TRF; λ=1e3, Pmax=3e5)\n9.54432950518758e15\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.TRF_TV!-Tuple{Any, Any, Any}","page":"API","title":"MRIgeneralizedBloch.TRF_TV!","text":"F = TRF_TV!(grad_TRF, ω1, TRF; λ = 1)\n\nCalculate the total variation penalty of TRF and over-write the TRF gradient in place.\n\nArguments\n\ngrad_TRF::Vector{<:Number}: Gradient of control, which will be over-written in place\nω1::Vector{<:Number}: Control vector\nTRF::Vector{<:Number}: Control vector\n\nOptional Keyword Arguments:\n\nλ::Number: regularization parameter\n\nExamples\n\njulia> using MRIgeneralizedBloch\n\njulia> ω1 = 4000π * rand(100);\n\njulia> TRF = 500e-6 * rand(100);\n\njulia> grad_TRF = similar(ω1);\n\njulia> F = MRIgeneralizedBloch.TRF_TV!(grad_TRF, ω1, TRF; λ = 1e-3)\n1.826335488333797e-5\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.apply_hamiltonian_gbloch!-Tuple{Any, Any, Any, NTuple{11, Any}, Any}","page":"API","title":"MRIgeneralizedBloch.apply_hamiltonian_gbloch!","text":"apply_hamiltonian_gbloch!(∂m∂t, m, mfun, p, t)\n\nApply the generalized Bloch Hamiltonian to m and write the resulting derivative wrt. time into ∂m∂t.\n\nArguments\n\n∂m∂t::Vector{<:Number}: Vector describing to derivative of m wrt. time; this vector has to be of the same size as m, but can contain any value, which is replaced by H * m\nm::Vector{<:Number}: Vector the spin ensemble state of the form [xf, yf, zf, zs, 1] if now gradient is calculated or of the form [xf, yf, zf, zs, 1, ∂xf/∂θ1, ∂yf/∂θ1, ∂zf/∂θ1, ∂zs/∂θ1, 0, ..., ∂xf/∂θn, ∂yf/∂θn, ∂zf/∂θn, ∂zs/∂θn, 0] if n derivatives wrt. θn are calculated\nmfun: History fuction; can be initialized with mfun(p, t; idxs=nothing) = typeof(idxs) <: Number ? 0.0 : zeros(5n + 5) for n gradients, and is then updated by the delay differential equation solvers\np::NTuple{9,10, or 11, Any}: (ω1, B1, ω0, m0s, R1f, R2f, Rx, R1s, T2s, g), with    -ω1::Number: Rabi frequency in rad/s (rotation about the y-axis)   -B1::Number: B1 scaling normalized so that B1=1 corresponds to a perfectly calibrated RF field   -ω0::Number: Larmor or off-resonance frequency in rad/s   -m0s::Number: Fractional semi-solid spin pool size in the range of 0 to 1   -R1f::Number: Longitudinal spin relaxation rate of the free pool in 1/seconds   -R2f::Number: Trasversal spin relaxation rate of the free pool in 1/seconds   -Rx::Number: Exchange rate between the two pools in 1/seconds   -R1s::Number: Longitudinal spin relaxation rate of the semi-solid pool in 1/seconds   -T2s::Number: Trasversal spin relaxation time of the semi-solid pool in seconds   -g::Function: Green's function of the form G(κ) = G((t-τ)/T2s)   or (ω1, B1, ω0, m0s, R1f, R2f, Rx, R1s, T2s, zs_idx, g) with\nzs_idx::Integer: Index to be used history function to be used in the Green's function; Default is 4 (zs), and for derivatives 9, 14, ... are used\nor (ω1, B1, ω0, m0s, R1f, R2f, Rx, R1s, T2s, g, dG_o_dT2s_x_T2s, grad_list) with\ndG_o_dT2s_x_T2s::Function: Derivative of the Green's function wrt. T2s, multiplied by T2s; of the form dG_o_dT2s_x_T2s(κ) = dG_o_dT2s_x_T2s((t-τ)/T2s)\ngrad_list::Vector{<:grad_param}: List of gradients to be calucualted; any subset of [grad_m0s(), grad_R1f(), grad_R2f(), grad_Rx(), grad_R1s(), grad_T2s(), grad_ω0(), grad_B1()]; length of the vector must be n (cf. arguments m and ∂m∂t); ; the derivative wrt. to apparent R1a = R1f = R1s can be calculated with grad_R1a()\nt::Number: Time in seconds\n\nOptional:\n\npulsetype=:normal: Use default for a regular RF-pulse; the option pulsetype=:inversion should be handled with care as it is only inteded to calculate the saturation of the semi-solid pool and its derivative. \n\nExamples\n\njulia> using DifferentialEquations\n\n\njulia> α = π/2;\n\njulia> TRF = 100e-6;\n\njulia> ω1 = α/TRF;\n\njulia> B1 = 1;\n\njulia> ω0 = 0;\n\njulia> m0s = 0.2;\n\njulia> R1f = 1/3;\n\njulia> R2f = 15;\n\njulia> R1s = 2;\n\njulia> T2s = 10e-6;\n\njulia> Rx = 30;\n\njulia> G = interpolate_greens_function(greens_superlorentzian, 0, TRF / T2s);\n\n\njulia> m0 = [0; 0; 1-m0s; m0s; 1];\n\njulia> mfun(p, t; idxs=nothing) = typeof(idxs) <: Number ? 0.0 : zeros(5);\n\njulia> sol = solve(DDEProblem(apply_hamiltonian_gbloch!, m0, mfun, (0, TRF), (ω1, B1, ω0, m0s, R1f, R2f, Rx, R1s, T2s, G)))\nretcode: Success\nInterpolation: specialized 4th order \"free\" interpolation, specialized 2nd order \"free\" stiffness-aware interpolation\nt: 9-element Vector{Float64}:\n 0.0\n 1.375006182301112e-7\n 1.512506800531223e-6\n 8.042561696923577e-6\n 2.107848894861101e-5\n 3.911414415070652e-5\n 6.26879093553081e-5\n 9.147705752659822e-5\n 0.0001\nu: 9-element Vector{Vector{Float64}}:\n [0.0, 0.0, 0.8, 0.2, 1.0]\n [0.0017278806030763402, 0.0, 0.7999981340131751, 0.19999953350448, 1.0]\n [0.019004717382235078, 0.0, 0.7997742277135814, 0.19994357804868362, 1.0]\n [0.10079111348917136, 0.0, 0.7936248122939504, 0.19842287240365722, 1.0]\n [0.26002578672576243, 0.0, 0.7565529666157937, 0.18981913039644657, 1.0]\n [0.4610419882566734, 0.0, 0.6537242214798688, 0.16937688382096108, 1.0]\n [0.6661738538876186, 0.0, 0.44261236945975563, 0.1358931514238721, 1.0]\n [0.7923116826717905, 0.0, 0.10713144280454787, 0.09390268562369869, 1.0]\n [0.7994211188440815, 0.0, 0.0004403374355099447, 0.08214809683848684, 1.0]\n\njulia> using Plots\n\njulia> plot(sol, labels=[\"xf\" \"yf\" \"zf\" \"zs\" \"1\"], xlabel=\"t (s)\", ylabel=\"m(t)\");\n\n\n\n\njulia> dG_o_dT2s_x_T2s = interpolate_greens_function(dG_o_dT2s_x_T2s_superlorentzian, 0, TRF / T2s);\n\n\njulia> grad_list = [grad_R2f(), grad_m0s()];\n\n\njulia> m0 = [0; 0; 1-m0s; m0s; 1; zeros(5*length(grad_list))];\n\n\njulia> mfun(p, t; idxs=nothing) = typeof(idxs) <: Number ? 0.0 : zeros(5 + 5*length(grad_list));\n\njulia> sol = solve(DDEProblem(apply_hamiltonian_gbloch!, m0, mfun, (0, TRF), (ω1, B1, ω0, m0s, R1f, R2f, Rx, R1s, T2s, G, dG_o_dT2s_x_T2s, grad_list)));\n\n\n\n\njulia> plot(sol);\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.apply_hamiltonian_sled!-Tuple{Any, Any, NTuple{6, Any}, Any}","page":"API","title":"MRIgeneralizedBloch.apply_hamiltonian_sled!","text":"apply_hamiltonian_sled!(∂m∂t, m, p, t)\n\nApply Sled's Hamiltonian to m and write the resulting derivative wrt. time into ∂m∂t.\n\nArguments\n\n∂m∂t::Vector{<:Number}: Vector of length 1 describing to derivative of m wrt. time; this vector can contain any value, which is replaced by H * m\nm::Vector{<:Number}: Vector of length 1 describing the zs magnetization\np::NTuple{6 or 10, Any}: (ω1, B1, ω0, R1s, T2s, g) for a simulating an isolated semi-solid pool or (ω1, B1, ω0, m0s, R1f, R2f, Rx, R1s, T2s, g) for simulating a coupled spin system; with    -ω1::Number: Rabi frequency in rad/s (rotation about the y-axis)   -B1::Number: B1 scaling normalized so that B1=1 corresponds to a perfectly calibrated RF field   -ω0::Number: Larmor or off-resonance frequency in rad/s   -R1f::Number: Longitudinal spin relaxation rate of the free pool in 1/seconds   -R2f::Number: Trasversal spin relaxation rate of the free pool in 1/seconds   -R1s::Number: Longitudinal spin relaxation rate of the semi-solid in 1/seconds   -Rx::Number: Exchange rate between the two pools in 1/seconds   -T2s::Number: Trasversal spin relaxation time in seconds   -g::Function: Green's function of the form G(κ) = G((t-τ)/T2s)\nt::Number: Time in seconds\n\nExamples\n\njulia> using DifferentialEquations\n\n\njulia> α = π/2;\n\njulia> TRF = 100e-6;\n\njulia> ω1 = α/TRF;\n\njulia> B1 = 1;\n\njulia> ω0 = 0;\n\njulia> R1s = 2;\n\njulia> T2s = 10e-6;\n\njulia> G = interpolate_greens_function(greens_superlorentzian, 0, TRF / T2s);\n\njulia> m0 = [1];\n\njulia> sol = solve(ODEProblem(apply_hamiltonian_sled!, m0, (0, TRF), (ω1, 1, ω0, R1s, T2s, G)), Tsit5())\nretcode: Success\nInterpolation: specialized 4th order \"free\" interpolation\nt: 3-element Vector{Float64}:\n 0.0\n 7.475414666720001e-5\n 0.0001\nu: 3-element Vector{Vector{Float64}}:\n [1.0]\n [0.631392823181197]\n [0.48953654496619187]\n\njulia> using Plots\n\njulia> plot(sol, labels=[\"zs\"], xlabel=\"t (s)\", ylabel=\"m(t)\");\n\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.bound_ω1_TRF!-Tuple{Any, Any}","page":"API","title":"MRIgeneralizedBloch.bound_ω1_TRF!","text":"x = bound_ω1_TRF!(ω1, TRF; ω1_min = 0, ω1_max = 2e3π, TRF_min = 100e-6, TRF_max = 500e-6)\n\nBound the controls ω1 and TRF in place and return a vector of length 2Npulses with values in the range [-Inf, Inf] that relates to the bounded ω1 and TRF via the tanh function\n\nArguments\n\nω1::Vector{<:Number}: Control vector of length = Npulses\nTRF::Vector{<:Number}: Control vector of length = Npulses\n\nOptional Keyword Arguments:\n\nω1_min::Number: lower bound for ω1\nω1_max::Number: upper bound for ω1\nTRF_min::Number: lower bound for TRF\nTRF_max::Number: upper bound for TRF\n\nExamples\n\njulia> using MRIgeneralizedBloch\n\njulia> ω1 = 4000π * rand(100);\n\njulia> TRF = 500e-6 * rand(100);\n\njulia> x = MRIgeneralizedBloch.bound_ω1_TRF!(ω1, TRF)\n200-element Vector{Float64}:\n  Inf\n   0.16123919298957837\n  Inf\n  Inf\n  Inf\n  Inf\n   0.17719147195925186\n   0.33617937553604216\n  -1.1288911659500056\n  Inf\n   ⋮\n -Inf\n  -0.5475311433614531\n  -0.6572991695812251\n -Inf\n  -0.5487931795341404\n  -2.097250369053942\n -Inf\n  -1.1536520473794025\n   0.07161170293075586\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.calculatesignal_gbloch_ide-NTuple{11, Any}","page":"API","title":"MRIgeneralizedBloch.calculatesignal_gbloch_ide","text":"calculatesignal_gbloch_ide(α, TRF, TR, ω0, B1, m0s, R1f, R2f, Rx, R1s, T2s[; grad_list, Ncyc=2, output=:complexsignal])\n\nCalculate the signal or magnetixation evolution with the full generalized Bloch model assuming a super-Lorentzian lineshape (slow).\n\nThe simulation assumes a sequence of rectangluar RF-pulses with varying flip angles α and RF-pulse durations TRF, but a fixed repetition time TR. Further, it assumes balanced gradient moments. \n\nArguments\n\nα::Vector{<:Number}: Array of flip angles in radians\nTRF::Vector{<:Number}: Array of the RF-pulse durations in seconds\nTR::Number: Repetition time in seconds\nω0::Number: Off-resonance frequency in rad/s \nB1::Number: Normalized transmit B1 field, i.e. B1 = 1 corresponds to a well-calibrated B1 field\nm0s::Number: Fractional size of the semi-solid pool; should be in range of 0 to 1\nR1f::Number: Longitudinal relaxation rate of the free pool in 1/seconds\nR2f::Number: Transversal relaxation rate of the free pool in 1/seconds\nRx::Number: Exchange rate between the two spin pools in 1/seconds\nR1s::Number: Longitudinal relaxation rate of the semi-solid pool in 1/seconds\nT2s::Number: Transversal relaxationt time of the semi-solid pool in seconds\n\nOptional:\n\ngrad_list=[]: Vector to indicate which gradients should be calculated; the vector can either be empty [] for no gradient, or contain any subset/order of grad_list=[grad_m0s(), grad_R1s(), grad_R2f(), grad_Rx(), grad_R1s(), grad_T2s(), grad_ω0(), grad_B1()]; the derivative wrt. to apparent R1a = R1f = R1s can be calculated with grad_R1a()\nNcyc=2: The magnetization is initialized with thermal equilibrium and then performed Ncyc times and only the last cycle is stored. The default value is usually a good approximation for antiperiodic boundary conditions. Increase the number for higher precision at the cost of computation time. \noutput=:complexsignal: The defaul keywords triggers the function to output a complex-valued signal (xf + 1im yf); the keyword output=:realmagnetization triggers an output of the entire (real valued) vector [xf, yf, zf, xs, zs]\ngreens=(greens_superlorentzian, dG_o_dT2s_x_T2s_superlorentzian): Tuple of a Greens function G(κ) = G((t-τ)/T2s) and its partial derivative wrt. T2s, multiplied by T2s ∂G((t-τ)/T2s)/∂T2s * T2s. This package supplies the three Greens functions greens=(greens_superlorentzian, dG_o_dT2s_x_T2s_superlorentzian) (default), greens=(greens_lorentzian, dG_o_dT2s_x_T2s_lorentzian), and greens=(greens_gaussian, dG_o_dT2s_x_T2s_gaussian)\n\nExamples\n\njulia> calculatesignal_gbloch_ide(ones(100)*π/2, ones(100)*5e-4, 4e-3, 0, 1, 0.2, 0.3, 15, 20, 2, 10e-6)\n100×1 Matrix{ComplexF64}:\n  -0.007966316445016917 + 0.0im\n  0.0012590590419314762 - 0.0im\n  -0.006088855588122765 + 0.0im\n  0.0024187389404174905 - 0.0im\n  -0.004361339395232529 + 0.0im\n  0.0034891358210049914 - 0.0im\n -0.0027633710614652324 + 0.0im\n   0.004483217941394411 - 0.0im\n -0.0012812573517353436 + 0.0im\n   0.005408854034677167 - 0.0im\n                        ⋮\n   0.017760808273048677 - 0.0im\n   0.017576118974646303 + 0.0im\n   0.017813950945910262 - 0.0im\n   0.017643856335506514 + 0.0im\n   0.017863575855931582 - 0.0im\n   0.017706926033852457 + 0.0im\n   0.017909914934081783 - 0.0im\n    0.01776565037329605 + 0.0im\n    0.01795318489371729 - 0.0im\n\njulia> calculatesignal_gbloch_ide(ones(100)*π/2, ones(100)*5e-4, 4e-3, 0, 1, 0.2, 0.3, 15, 20, 2, 10e-6; grad_list=[grad_R1f(), grad_T2s()], output=:realmagnetization)\n100×15 transpose(::Matrix{Float64}) with eltype Float64:\n -0.00796627   0.0   0.000637773  …   0.0   -10.8757  -335.26   0.0\n  0.00125903  -0.0  -0.00700671      -0.0   125.882   -326.977  0.0\n -0.00608882   0.0   0.00185086       0.0   -30.4187  -317.56   0.0\n  0.00241873  -0.0  -0.00520622      -0.0    96.1776  -309.906  0.0\n -0.00436133   0.0   0.00296471       0.0   -47.5803  -302.948  0.0\n  0.003489    -0.0  -0.00354518   …  -0.0    69.5148  -298.697  0.0\n -0.00276366   0.0   0.00399588       0.0   -62.8453  -294.886  0.0\n  0.00448273  -0.0  -0.00200673      -0.0    45.3179  -292.783  0.0\n -0.00128187   0.0   0.00495478       0.0   -76.6573  -290.321  0.0\n  0.00540814  -0.0  -0.000578836     -0.0    23.1756  -289.245  0.0\n  ⋮                               ⋱\n  0.0177563   -0.0   0.0175372       -0.0  -290.779   -349.855  0.0\n  0.0175716    0.0   0.0177845        0.0  -295.347   -350.002  0.0\n  0.0178094   -0.0   0.0176073       -0.0  -292.44    -350.163  0.0\n  0.0176393    0.0   0.0178359        0.0  -296.668   -350.3    0.0\n  0.017859    -0.0   0.0176727    …  -0.0  -294.001   -350.451  0.0\n  0.0177024    0.0   0.0178838        0.0  -297.914   -350.579  0.0\n  0.0179053   -0.0   0.0177335       -0.0  -295.467   -350.72   0.0\n  0.0177611    0.0   0.0179286        0.0  -299.09    -350.84   0.0\n  0.0179486   -0.0   0.0177902       -0.0  -296.845   -350.972  0.0\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.calculatesignal_graham_ode-NTuple{11, Any}","page":"API","title":"MRIgeneralizedBloch.calculatesignal_graham_ode","text":"calculatesignal_graham_ode(α, TRF, TR, ω0, B1, m0s, R1f, R2f, Rx, R1s, T2s[; grad_list, Ncyc=2, output=:complexsignal])\n\nCalculate the signal or magnetixation evolution with Graham's spectral model assuming a super-Lorentzian lineshape.\n\nThe simulation assumes a sequence of rectangluar RF-pulses with varying flip angles α and RF-pulse durations TRF, but a fixed repetition time TR. Further, it assumes balanced gradient moments. \n\nArguments\n\nα::Vector{<:Number}: Array of flip angles in radians\nTRF::Vector{<:Number}: Array of the RF-pulse durations in seconds\nTR::Number: Repetition time in seconds\nω0::Number: Off-resonance frequency in rad/s \nB1::Number: Normalized transmit B1 field, i.e. B1 = 1 corresponds to a well-calibrated B1 field\nm0s::Number: Fractional size of the semi-solid pool; should be in range of 0 to 1\nR1f::Number: Longitudinal relaxation rate of the free pool in 1/seconds\nR2f::Number: Transversal relaxation rate of the free pool in 1/seconds\nRx::Number: Exchange rate between the two spin pools in 1/seconds\nR1s::Number: Longitudinal relaxation rate of the semi-solid pool in 1/seconds\nT2s::Number: Transversal relaxationt time of the semi-solid pool in seconds\n\nOptional:\n\ngrad_list=[]: Vector to indicate which gradients should be calculated; the vector can either be empty [] for no gradient, or contain any subset/order of grad_list=[grad_m0s(), grad_R1f(), grad_R2f(), grad_Rx(), grad_R1s(), grad_T2s(), grad_ω0(), grad_B1(), grad_R1a()]\nNcyc=2: The magnetization is initialized with thermal equilibrium and then performed Ncyc times and only the last cycle is stored. The default value is usually a good approximation for antiperiodic boundary conditions. Increase the number for higher precision at the cost of computation time. \noutput=:complexsignal: The defaul keywords triggers the function to output a complex-valued signal (xf + 1im yf); the keyword output=:realmagnetization triggers an output of the entire (real valued) vector [xf, yf, zf, xs, zs]\n\nExamples\n\njulia> calculatesignal_graham_ode(ones(100)*π/2, ones(100)*5e-4, 4e-3, 0, 1, 0.2, 0.3, 15, 20, 2, 10e-6)\n100×1 Matrix{ComplexF64}:\n  -0.008073451191813547 + 0.0im\n    0.00126864329048296 - 0.0im\n  -0.006178694437239949 + 0.0im\n   0.002435865817867096 - 0.0im\n  -0.004437476277201384 + 0.0im\n  0.0035164646498403165 - 0.0im\n -0.0028315542520438355 + 0.0im\n   0.004523902250379148 - 0.0im\n -0.0013422299483389299 + 0.0im\n   0.005454562034842184 - 0.0im\n                        ⋮\n   0.018148222040953982 - 0.0im\n    0.01795769661414948 + 0.0im\n    0.01820486087666198 - 0.0im\n   0.018029363102618986 + 0.0im\n   0.018257820142562945 - 0.0im\n    0.01809616891246802 + 0.0im\n   0.018307337729977703 - 0.0im\n   0.018158444501177453 + 0.0im\n   0.018353636229654635 - 0.0im\n\njulia> calculatesignal_graham_ode(ones(100)*π/2, ones(100)*5e-4, 4e-3, 0, 1, 0.2, 0.3, 15, 20, 2, 10e-6; grad_list=[grad_R1f(), grad_T2s()], output=:realmagnetization)\n100×15 transpose(::Matrix{Float64}) with eltype Float64:\n -0.0080756    0.0   0.000643162  …   0.0   -10.4986  -323.634  0.0\n  0.00126867  -0.0  -0.00710692      -0.0   123.078   -316.358  0.0\n -0.00618067   0.0   0.00186482       0.0   -29.4458  -307.862  0.0\n  0.00243634  -0.0  -0.0052899       -0.0    94.1692  -300.821  0.0\n -0.00443746   0.0   0.00298646       0.0   -46.1422  -294.116  0.0\n  0.00351386  -0.0  -0.00361718   …  -0.0    68.262   -289.421  0.0\n -0.00282882   0.0   0.00402793       0.0   -61.0236  -285.242  0.0\n  0.00451808  -0.0  -0.00206741      -0.0    44.7888  -282.867  0.0\n -0.00133608   0.0   0.00499316       0.0   -74.4075  -280.79   0.0\n  0.00544896  -0.0  -0.00062663      -0.0    23.2536  -280.148  0.0\n  ⋮                               ⋱\n  0.0181755   -0.0   0.0179431       -0.0  -285.071   -337.48   0.0\n  0.0179911    0.0   0.0181963        0.0  -289.591   -337.634  0.0\n  0.0182343   -0.0   0.018019        -0.0  -286.777   -337.804  0.0\n  0.0180645    0.0   0.0182531        0.0  -290.964   -337.948  0.0\n  0.0182893   -0.0   0.0180898    …  -0.0  -288.383   -338.106  0.0\n  0.0181329    0.0   0.0183062        0.0  -292.261   -338.241  0.0\n  0.0183407   -0.0   0.0181559       -0.0  -289.895   -338.39   0.0\n  0.0181968    0.0   0.0183559        0.0  -293.488   -338.516  0.0\n  0.0183888   -0.0   0.0182175       -0.0  -291.318   -338.656  0.0\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.calculatesignal_linearapprox-NTuple{12, Any}","page":"API","title":"MRIgeneralizedBloch.calculatesignal_linearapprox","text":"calculatesignal_linearapprox(α, TRF, TR, ω0, B1, m0s, R1f, R2f, Rx, R1s, T2s, R2slT[; grad_list=[undef], rfphase_increment=[π], m0=:antiperiodic, output=:complexsignal])\n\nCalculate the signal or magnetization evolution with the linear approximation of the generalized Bloch model assuming a super-Loretzian lineshape.\n\nThe simulation assumes a sequence of rectangluar RF-pulses with varying flip angles α and RF-pulse durations TRF, but a fixed repetition time TR. Further, it assumes balanced gradient moments.\n\nArguments\n\nα::Vector{<:Number}: Array of flip angles in radians\nTRF::Vector{<:Number}: Array of the RF-pulse durations in seconds\nTR::Number: Repetition time in seconds\nω0::Number: Off-resonance frequency in rad/s\nB1::Number: Normalized transmit B1 field, i.e. B1 = 1 corresponds to a well-calibrated B1 field\nm0s::Number: Fractional size of the semi-solid pool; should be in range of 0 to 1\nR1f::Number: Longitudinal relaxation rate of the free pool in 1/seconds\nR2f::Number: Transversal relaxation rate of the free pool in 1/seconds\nRx::Number: Exchange rate between the two spin pools in 1/seconds\nR1f::Number: Longitudinal relaxation rate of the semi-solid pool in 1/seconds\nT2s::Number: Transversal relaxationt time of the semi-solid pool in seconds\nR2slT::NTuple{3, Function}: Tuple of three functions: R2sl(TRF, ω1, B1, T2s), dR2sldB1(TRF, ω1, B1, T2s), and R2sldT2s(TRF, ω1, B1, T2s). Can be generated with precompute_R2sl\n\nOptional:\n\ngrad_list=[undef]: Vector to indicate which gradients should be calculated; the vector elements can either be undef for no gradient, or any subset/order of grad_list=[grad_m0s(), grad_R1f(), grad_R2f(), grad_Rx(), grad_R1s(), grad_T2s(), grad_ω0(), grad_B1()]; the derivative wrt. to apparent R1a = R1f = R1s can be calculated with grad_R1a()\nrfphase_increment=[π]::Vector{<:Number}: Increment of the RF phase between consequtive pulses. The default value π, together with ω0=0 corresponds to the on-resonance condition. When more than one value is supplied, their resulting signal is stored along the second dimension of the output array.\nm0=:antiperiodic: With the default keyword :antiperiodic, the signal and their derivatives are calcualted assuming m(0) = -m(T), where T is the duration of the RF-train. With the keyword :thermal, the magnetization m(0) is initialized with thermal equilibrium [xf, yf, zf, xs, zs] = [0, 0, 1-m0s, 0, m0s], followed by a α[1]/2 - TR/2 prep pulse; and with the keyword :IR, this initalization is followed an inversion pulse of duration TRF[1], (set α[1]=π) and a α[2]/2 - TR/2 prep pulse.\noutput=:complexsignal: The defaul keywords triggers the function to output a complex-valued signal (xf + 1im yf); the keyword output=:realmagnetization triggers an output of the entire (real valued) vector [xf, yf, zf, xs, zs]\n\nExamples\n\njulia> R2slT = precompute_R2sl();\n\n\njulia> calculatesignal_linearapprox(ones(100)*π/2, ones(100)*5e-4, 4e-3, 0, 1, 0.1, 1, 15, 30, 6.5, 10e-6, R2slT)\n100×1×1 Array{ComplexF64, 3}:\n[:, :, 1] =\n  -0.029305987774458163 - 2.6090233074873602e-18im\n   0.004329424678273618 - 9.228587093606358e-19im\n  -0.022761409373843695 + 1.3684406715212817e-18im\n   0.008280330224850314 - 3.913888063486213e-18im\n  -0.016751305727868086 + 4.640955399485587e-18im\n   0.011921649143708494 - 6.302663734240699e-18im\n   -0.01119057989041819 + 7.310583447081545e-18im\n   0.015305608440952356 - 8.175490153983926e-18im\n -0.0060267918180664974 + 9.464626759459644e-18im\n   0.018463027499697613 - 9.608537136498027e-18im\n                        ⋮\n   0.061531473509660414 + 1.4962743251121995e-18im\n    0.06081400768357244 + 5.6874647068595666e-18im\n     0.0617257515931871 + 1.6576028430814591e-18im\n   0.061064216222629225 + 5.55793788363693e-18im\n     0.0619074570531536 + 1.8084438857930338e-18im\n    0.06129750535994419 + 5.436837755621582e-18im\n   0.062077399758002534 + 1.9493976022865502e-18im\n   0.061515021919442275 + 5.323692528202896e-18im\n    0.06223633770306246 + 2.0810405785134972e-18im\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.dG_o_dT2s_x_T2s_gaussian-Tuple{Any}","page":"API","title":"MRIgeneralizedBloch.dG_o_dT2s_x_T2s_gaussian","text":"dG_o_dT2s_x_T2s_gaussian(κ)\n\nEvaluate the derivative of Green's function, corresponding to a Gaussian lineshape, wrt. T2s at κ = (t-τ)/T2s and multiply it by T2s.\n\nThe multiplication is added so that the function merely depends on κ = (t-τ)/T2s. The actual derivative is given by dG_o_dT2s_x_T2s_gaussian((t-τ)/T2s)/T2s.\n\nExamples\n\njulia> t = 100e-6;\n\njulia> τ = 0;\n\njulia> T2s = 10e-6;\n\njulia> dGdT2s = dG_o_dT2s_x_T2s_gaussian((t-τ)/T2s)/T2s\n1.9287498479639177e-15\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.dG_o_dT2s_x_T2s_lorentzian-Tuple{Any}","page":"API","title":"MRIgeneralizedBloch.dG_o_dT2s_x_T2s_lorentzian","text":"dG_o_dT2s_x_T2s_lorentzian(κ)\n\nEvaluate the derivative of Green's function, corresponding to a Lorentzian lineshape, wrt. T2s at κ = (t-τ)/T2s and multiply it by T2s.\n\nThe multiplication is added so that the function merely depends on κ = (t-τ)/T2s. The actual derivative is given by dG_o_dT2s_x_T2s_lorentzian((t-τ)/T2s)/T2s.\n\nExamples\n\njulia> t = 100e-6;\n\njulia> τ = 0;\n\njulia> T2s = 10e-6;\n\njulia> dGdT2s = dG_o_dT2s_x_T2s_lorentzian((t-τ)/T2s)/T2s\n45.39992976248485\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.dG_o_dT2s_x_T2s_superlorentzian-Tuple{Any}","page":"API","title":"MRIgeneralizedBloch.dG_o_dT2s_x_T2s_superlorentzian","text":"dG_o_dT2s_x_T2s_superlorentzian(κ)\n\nEvaluate the derivative of Green's function, corresponding to a super-Lorentzian lineshape, wrt. T2s at κ = (t-τ)/T2s and multiply it by T2s.\n\nThe multiplication is added so that the function merely depends on κ = (t-τ)/T2s. The actual derivative is given by dG_o_dT2s_x_T2s_superlorentzian((t-τ)/T2s)/T2s.\n\nExamples\n\njulia> t = 100e-6;\n\njulia> τ = 0;\n\njulia> T2s = 10e-6;\n\njulia> dGdT2s = dG_o_dT2s_x_T2s_superlorentzian((t-τ)/T2s)/T2s\n15253.095033670965\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.fit_gBloch-NTuple{4, Any}","page":"API","title":"MRIgeneralizedBloch.fit_gBloch","text":"fit_gBloch(data, α, TRF, TR;\n    reM0 = (-Inf,   1,  Inf),\n    imM0 = (-Inf,   0,  Inf),\n    m0s  = (   0, 0.2,    1),\n    R1f  = (   0, 0.3,  Inf),\n    R2f  = (   0,  15,  Inf),\n    Rx   = (   0,  20,  Inf),\n    R1s  = (   0,   3,  Inf),\n    T2s  = (8e-6,1e-5,12e-6),\n    ω0   = (-Inf,   0,  Inf),\n    B1   = (   0,   1,  1.5),\n    R1a  = (   0, 0.7,  Inf),\n    u=1,\n    fit_apparentR1=false,\n    show_trace=false,\n    maxIter=100,\n    R2slT = precompute_R2sl(TRF_min=minimum(TRF), TRF_max=maximum(TRF), T2s_min=minimum(T2s), T2s_max=maximum(T2s), ω1_max=maximum(α ./ TRF), B1_max=maximum(B1)),\n    )\n\nFit the generalized Bloch model for a train of RF pulses and balanced gradient moments to data.\n\nArguments\n\ndata::Vector{<:Number}: Array of measured data points, either in the time or a compressed domain (cf. u)\nα::Vector{<:Number}: Array of flip angles in radians\nTRF::Vector{<:Number}: Array of the RF-pulse durations in seconds\nTR::Number: Repetition time in seconds\nω0::Number: Off-resonance frequency in rad/s\n\nOptional Keyword Arguments:\n\nreM0::Union{Number, Tuple{Number, Number, Number}}: Real part of M0; either fixed value as a single number or fit limits thereof in the order (min, start, max)\nimM0::Union{Number, Tuple{Number, Number, Number}}: Imaginary part of M0; either fixed value as a single number or fit limits thereof in the order (min, start, max)\nm0s::Union{Number, Tuple{Number, Number, Number}}: Fractional size of the semi-solid pool (should be in range of 0 to 1); either fixed value as a single number or fit limits thereof in the order (min, start, max)\nR1f::Union{Number, Tuple{Number, Number, Number}}: Longitudinal relaxation rate of the free pool in 1/s; only used in combination with fit_apparentR1=false; either fixed value as a single number or fit limits thereof in the order (min, start, max)\nR2f::Union{Number, Tuple{Number, Number, Number}}: Transversal relaxation rate of the free pool in 1/s; either fixed value as a single number or fit limits thereof in the order (min, start, max)\nRx::Union{Number, Tuple{Number, Number, Number}}: Exchange rate between the two spin pools in 1/s; either fixed value as a single number or fit limits thereof in the order (min, start, max)\nR1s::Union{Number, Tuple{Number, Number, Number}}: Longitudinal relaxation rate of the semi-solid pool in 1/s; only used in combination with fit_apparentR1=false; either fixed value as a single number or fit limits thereof in the order (min, start, max)\nT2s::Union{Number, Tuple{Number, Number, Number}}: Transversal relaxationt time of the semi-solid pool in s; either fixed value as a single number or fit limits thereof in the order (min, start, max)\nω0::Union{Number, Tuple{Number, Number, Number}}: Off-resonance frequency in rad/s; either fixed value as a single number or fit limits thereof in the order (min, start, max)\nB1::Union{Number, Tuple{Number, Number, Number}}: Normalized transmit B1 field, i.e. B1 = 1 corresponds to a well-calibrated B1 field; either fixed value as a single number or fit limits thereof in the order (min, start, max)\nR1a::Union{Number, Tuple{Number, Number, Number}}: Apparent longitudinal relaxation rate in 1/s; only used in combination with fit_apparentR1=true; either fixed value as a single number or fit limits thereof in the order (min, start, max)\nu::Union{Number, Matrix}: Compression matrix that transform the simulated time series to a series of coefficients. Set to 1 by default to enable the fitting in the time domain\nfit_apparentR1::Bool: Switch between fitting R1f and R1s separately (false; default) and an apparant R1a = R1f = R1s (true)\nshow_trace::Bool: print output during the optimization; default=false\nmaxIter::Int: Maximum number of iteration; default=100\nR2slT::NTuple{3, Function}: Tuple of three functions: R2sl(TRF, ω1, B1, T2s), dR2sldB1(TRF, ω1, B1, T2s), and R2sldT2s(TRF, ω1, B1, T2s). By default generated with precompute_R2sl\n\nExamples\n\nc.f. Non-Linear Least Square Fitting\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.get_bounded_ω1_TRF-Tuple{Any}","page":"API","title":"MRIgeneralizedBloch.get_bounded_ω1_TRF","text":"ω1, TRF = get_bounded_ω1_TRF(x; ω1_min = 0, ω1_max = 2e3π, TRF_min = 100e-6, TRF_max = 500e-6)\n\nTransform a vector of length 2Npulses with values in the range [-Inf, Inf] into two vectors of length Npulses that represent the bounded controls ω1 and TRF.\n\nArguments\n\nx::Vector{<:Number}: Control vector of length = 2Npulses with values in the range [-Inf, Inf]\n\nOptional Keyword Arguments:\n\nω1_min::Number: lower bound for ω1\nω1_max::Number: upper bound for ω1\nTRF_min::Number: lower bound for TRF\nTRF_max::Number: upper bound for TRF\n\nExamples\n\njulia> using MRIgeneralizedBloch\n\njulia> x = 1000 * randn(2 * 100);\n\njulia> ω1, TRF = MRIgeneralizedBloch.get_bounded_ω1_TRF(x)\n([6283.185307179586, 0.0, 6283.185307179586, 0.0, 6283.185307179586, 0.0, 6283.185307179586, 0.0, 6283.185307179586, 6283.185307179586  …  6283.185307179586, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 6283.185307179586, 0.0, 0.0], [0.0005, 0.0005, 0.0005, 0.0001, 0.0005, 0.0001, 0.0001, 0.0005, 0.0005, 0.0005  …  0.0001, 0.0001, 0.0005, 0.0005, 0.0001, 0.0005, 0.0001, 0.0005, 0.0001, 0.0001])\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.greens_gaussian-Tuple{Any}","page":"API","title":"MRIgeneralizedBloch.greens_gaussian","text":"greens_gaussian(κ)\n\nEvaluate the Green's function corresponding to a Gaussian lineshape at κ = (t-τ)/T2s.\n\nExamples\n\njulia> t = 100e-6;\n\njulia> τ = 0;\n\njulia> T2s = 10e-6;\n\njulia> greens_gaussian((t-τ)/T2s)\n1.9287498479639178e-22\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.greens_lorentzian-Tuple{Any}","page":"API","title":"MRIgeneralizedBloch.greens_lorentzian","text":"greens_lorentzian(κ)\n\nEvaluate the Green's function corresponding to a Lorentzian lineshape at κ = (t-τ)/T2s.\n\nExamples\n\njulia> t = 100e-6;\n\njulia> τ = 0;\n\njulia> T2s = 10e-6;\n\njulia> greens_lorentzian((t-τ)/T2s)\n4.5399929762484854e-5\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.greens_superlorentzian-Tuple{Any}","page":"API","title":"MRIgeneralizedBloch.greens_superlorentzian","text":"greens_superlorentzian(κ)\n\nEvaluate the Green's function corresponding to a super-Lorentzian lineshape at κ = (t-τ)/T2s.\n\nExamples\n\njulia> t = 100e-6;\n\njulia> τ = 0;\n\njulia> T2s = 10e-6;\n\njulia> greens_superlorentzian((t-τ)/T2s)\n0.1471246868094442\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.hamiltonian_linear-NTuple{10, Any}","page":"API","title":"MRIgeneralizedBloch.hamiltonian_linear","text":"hamiltonian_linear(ω1, B1, ω0, T, m0s, R1f, R2f, Rx, R1s, R2s[, dR2sdT2s, dR2sdB1, grad_type])\n\nCalculate the hamiltonian of the linear approximation of the generalized Bloch model. \n\nIf no gradient is supplied, it returns a 6x6 (static) matrix with the dimensions (in this order) [xf, yf, zf, xs, zs, 1]; the attached 1 is a mathematical trick to allow for T_1 relaxation to a non-zero thermal equilibrium. If a gradient is supplied, it returns a 11x11 (static) matrix with the dimensions (in this order) [xf, yf, zf, xs, zs, dxf/dθ, dyf/dθ, dzf/dθ, dxs/dθ, dzs/dθ,  1], where θ is the parameter specified by grad_type\n\nArguments\n\nω1::Number: Rabi frequency in rad/s (rotation about the y-axis)\nB1::Number: Normalized transmit B1 field, i.e. B1 = 1 corresponds to a well-calibrated B1 field\nω0::Number: Larmor (or off-resonance) frequency in rad/s (rotation about the z-axis)\nT::Number: Time in seconds; this can, e.g., be the RF-pulse duration, or the time of free precession with ω1=0\nm0s::Number: Fractional size of the semi-solid pool; should be in range of 0 to 1\nR1f::Number: Longitudinal relaxation rate of the free pool in 1/seconds\nR2f::Number: Transversal relaxation rate of the free pool in 1/seconds\nRx::Number: Exchange rate between the two spin pools in 1/seconds\nR1s::Number: Longitudinal relaxation rate of the semi-solid pool in 1/seconds\nR2s::Number: Transversal relaxationt rate of the semi-solid pool in 1/seconds; this number can be calcualated with the first function returned by precompute_R2sl to implement the linear approximation described in the generalized Bloch paper\n\nOptional:\n\ndR2sdT2s::Number: Derivative of linearized R2sl wrt. the actual T2s; only required if grad_type = grad_T2s(); this number can be calcualated with the second function returned by precompute_R2sl\ndR2sdB1::Number: Derivative of linearized R2sl wrt. B1; only required if grad_type = grad_B1(); this number can be calcualated with the third function returned by precompute_R2sl\ngrad_type::grad_param: grad_m0s(), grad_R1f(), grad_R1s(), grad_R2f(), grad_Rx(), grad_T2s(), grad_ω0(), or grad_B1(); create one hamiltonian for each desired gradient\n\nExamples\n\njulia> α = π;\n\njulia> T = 500e-6;\n\njulia> ω1 = α/T;\n\njulia> B1 = 1;\n\njulia> ω0 = 0;\n\njulia> m0s = 0.1;\n\njulia> R1f = 1;\n\njulia> R2f = 15;\n\njulia> Rx = 30;\n\njulia> R1s = 6.5;\n\njulia> R2s = 1e5;\n\njulia> m0 = [0, 0, 1-m0s, 0, m0s, 1];\n\njulia> (xf, yf, zf, xs, zs, _) = exp(hamiltonian_linear(ω1, B1, ω0, T, m0s, R1f, R2f, Rx, R1s, R2s)) * m0\n6-element StaticArrays.SVector{6, Float64} with indices SOneTo(6):\n  0.0010647535813058293\n  0.0\n -0.8957848274535014\n  0.005126529591877105\n  0.08122007142111888\n  1.0\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.interpolate_greens_function-Tuple{Any, Any, Any}","page":"API","title":"MRIgeneralizedBloch.interpolate_greens_function","text":"interpolate_greens_function(f, κmin, κmax)\n\nInterpolate the Green's function f in the range between κmin and κmax.\n\nThe interpolation uses the ApproxFun.jl package that incorporates Chebyshev polynomials and ensures an approximation to machine precision. \n\nExamples\n\njulia> t = 100e-6;\n\njulia> τ = 0;\n\njulia> T2s = 10e-6;\n\njulia> greens_superlorentzian((t-τ)/T2s)\n0.1471246868094442\n\njulia> Gint = interpolate_greens_function(greens_superlorentzian, 0, 20);\n\n\njulia> Gint((t-τ)/T2s)\n0.14712468680944407\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.precompute_R2sl-Tuple{}","page":"API","title":"MRIgeneralizedBloch.precompute_R2sl","text":"precompute_R2sl([;TRF_min=100e-6, TRF_max=500e-6, T2s_min=5e-6, T2s_max=21e-6, ω1_max=π/TRF_max, B1_max=1.5, greens=greens_superlorentzian])\n\nPre-compute and interpolate the linearized R2sl(TRF, α, B1, T2s) and its derivatives dR2sldB1(TRF, α, B1, T2s), R2sldT2s(TRF, α, B1, T2s) etc. in the range specified by the arguments.\n\nThe function solves the generalized Bloch equations of an isolated semi-solid pool for values in the specified range, calulates the linearized R2sl that minimizes the error of zs at the end of the RF-pulse, and interpolates between the different samples.\n\nOptional Arguments:\n\nTRF_min::Number: lower bound of the RF-pulse duration range in seconds\nTRF_max::Number: upper bound of the RF-pulse duration range in seconds\nT2s_min::Number: lower bound of the T2s range in seconds\nT2s_max::Number: upper bound of the T2s range in seconds\nω1_max::Number: upper bound of the Rabi frequency ω1, the default is the frequency of a 500μs long π-pulse\nB1_max::Number: upper bound of the B1 range, normalized so that B1 = 1 corresponds to a perfectly calibrated RF field\ngreens=greens_superlorentzian: Greens function in the form G(κ) = G((t-τ)/T2s). This package supplies the three Greens functions greens=greens_superlorentzian (default), greens=greens_lorentzian, and greens=greens_gaussian\n\nExamples\n\njulia> R2slT = precompute_R2sl();\n\n\njulia> R2sl, dR2sldB1, R2sldT2s, _ = precompute_R2sl(TRF_min=100e-6, TRF_max=500e-6, T2s_min=5e-6, T2s_max=15e-6, ω1_max=π/500e-6, B1_max=1.3, greens=greens_gaussian);\n\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.second_order_α!-NTuple{4, Any}","page":"API","title":"MRIgeneralizedBloch.second_order_α!","text":"F = second_order_α!(grad_ω1, grad_TRF, ω1, TRF; λ = 1)\n\nCalculate second order penalty of variations of the flip angle α and over-write the gradients in place.\n\nArguments\n\ngrad_ω1::Vector{<:Number}: Gradient of control, which will be over-written in place\ngrad_TRF::Vector{<:Number}: Gradient of control, which will be over-written in place\nω1::Vector{<:Number}: Control vector\nTRF::Vector{<:Number}: Control vector\n\nOptional Keyword Arguments:\n\nλ::Number: regularization parameter\n\nExamples\n\njulia> using MRIgeneralizedBloch\n\njulia> ω1 = 4000π * rand(100);\n\njulia> TRF = 500e-6 * rand(100);\n\njulia> grad_ω1 = similar(ω1);\n\njulia> grad_TRF = similar(ω1);\n\njulia> F = MRIgeneralizedBloch.second_order_α!(grad_ω1, grad_TRF, ω1, TRF; λ = 1e-3)\n0.3394498406831758\n\n\n\n\n\n","category":"method"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"EditURL = \"https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/master/docs/src/OCT.jl\"","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"(Image: )","category":"page"},{"location":"build_literate/OCT/#Optimal-Control","page":"Optimal Control","title":"Optimal Control","text":"","category":"section"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"This section provides a brief introduction to the package's interface for sequence optimization. We use the Cramer-Rao bound (CRB) to assess a sequence's performance and optimize the amplitudes (ω1) and durations (TRF) of a train of RF-pulses to reduce the CRB, assuming a Balanced Hybrid-State Free Precession Pulse Sequence. For computational efficiency, the derivatives of the CRB wrt. ω1 and TRF are calcuated with the adjoint state method as known from the optimal control literature.","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"For this tutorial, we use the following packages:","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"using MRIgeneralizedBloch\nusing LinearAlgebra\nBLAS.set_num_threads(1) # single threaded is faster in this case\nusing Optim             # provides the optimization algorithm\nusing Plots\nplotlyjs(bg = RGBA(31/255,36/255,36/255,1.0), ticks=:native); #hide\nnothing #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"Here, we optimize the pulse sequence for a predefined set of parameters:","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"m0s = 0.15\nR1f = 0.5   # 1/s\nR2f = 15    # 1/s\nRx = 30     # 1/s\nR1s = 3     # 1/s\nT2s = 10e-6 # s\nω0 = 0      # rad/s\nB1 = 1;     # in units of B1_nominal\nnothing #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"and we optimize","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"Npulse = 200;\nnothing #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"pulses, spaced","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"TR = 3.5e-3; # s\nnothing #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"apart. A cyle duration of","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"Npulse * TR","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"seconds is much shorter than the optimal durations, which are roughly in the range of 4-10s, but we reduce Npulse speed up the computations in this demonstration. We precompute the linear the Linear Approximation of the generalized Bloch model:","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"R2slT = precompute_R2sl();\nnothing #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"In the calculation of the CRB, we account for following gradients:","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"grad_list = [grad_m0s(), grad_R1f(), grad_R2f(), grad_Rx(), grad_R1s(), grad_T2s(), grad_ω0(), grad_B1()];\nnothing #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"and we sum the CRB of all parameters, weighted by the following vector:","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"weights = transpose([0, 1, 0, 0, 0, 0, 0, 0, 0]);\nnothing #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"Note that the vector weights has one more entry compared to the grad_list vector, as the first value always indicates the derivative wrt. M_0, which is calculated in any case. Here, we only optimize for the CRB of m_0^s, while accounting for a fit of all 9 model parameters. Hence, we can use an arbitrary weighting for the CRB of m_0^s.","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"We take some initial guess for the pulse train:","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"α = abs.(sin.((1:Npulse) * 2π/Npulse));\nnothing #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"initialize with a constant TRF = 300μs:","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"TRF = 300e-6 .* one.(α);\nnothing #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"and define that first RF pulse as a 500μs inversion pulse by modifying vectors accordingly and by creating a bit vector that indicates the position of the inversion pulse:","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"α[1] = π # first pulse is an inversion pulse\nTRF[1] = 500e-6 # first pulse is an inversion pulse\nisInversionPulse = [true, falses(length(α)-1)...];\nnothing #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"We calculate the initial ω1","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"ω1 = α ./ TRF;\nnothing #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"and plot the inital control:","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"p1 = plot(TR*(1:Npulse), α ./ π, ylabel=\"α/π\")\np2 = plot(TR*(1:Npulse), 1e6TRF, ylim=(0, 1e3), xlabel=\"t (s)\", ylabel=\"TRF (μs)\")\np = plot(p1, p2, layout=(2, 1), legend=:none)\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"With above defined weights, the function CRBgradientOCT returns the CRB","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"(CRBm0s, grad_ω1, grad_TRF) = MRIgeneralizedBloch.CRB_gradient_OCT(ω1, TRF, TR, ω0, B1, m0s, R1f, R2f, Rx, R1s, T2s, R2slT, grad_list, weights, isInversionPulse=isInversionPulse)\nCRBm0s","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"along with the gradients:","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"p1 = plot(TR*(1:Npulse), grad_ω1  .* ((-1) .^ (1:Npulse)), ylabel=\"∂CRB(m0s) / ∂ω1 (s/rad)\")\np2 = plot(TR*(1:Npulse), grad_TRF .* ((-1) .^ (1:Npulse)), ylabel=\"∂CRB(m0s) / ∂TRF (1/s)\", xlabel=\"t (s)\")\np = plot(p1, p2, layout=(2, 1), legend=:none)\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"Note that we remove the oszillating nature of the gradient here for the display.","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"In this example, we limit the control to the following bounds","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"ω1_min  = 0      # rad/s\nω1_max  = 2e3π   # rad/s\nTRF_min = 100e-6 # s\nTRF_max = 500e-6; # s\nnothing #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"and the function bound_ω1_TRF! modifies ω1 and TRF to comply with these bounds and returns a single vector in the range [-Inf, Inf] that relates to the bounded control by a tanh transformation:","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"x0 = MRIgeneralizedBloch.bound_ω1_TRF!(ω1, TRF; ω1_min = ω1_min, ω1_max = ω1_max, TRF_min = TRF_min, TRF_max = TRF_max)","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"Further, we initialze a gradient of the same length:","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"G = similar(x0);\nnothing #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"and define a cost function:","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"function fg!(F, G, x)\n    ω1, TRF = MRIgeneralizedBloch.get_bounded_ω1_TRF(x; ω1_min = ω1_min, ω1_max = ω1_max, TRF_min = TRF_min, TRF_max = TRF_max)\n\n    (F, grad_ω1, grad_TRF) = MRIgeneralizedBloch.CRB_gradient_OCT(ω1, TRF, TR, ω0, B1, m0s, R1f, R2f, Rx, R1s, T2s, R2slT, grad_list, weights, isInversionPulse=isInversionPulse)\n    F = abs(F)\n\n    F += MRIgeneralizedBloch.second_order_α!(grad_ω1, grad_TRF, ω1, TRF; λ=1e4)\n    F += MRIgeneralizedBloch.RF_power!(grad_ω1, grad_TRF, ω1, TRF, λ=1e-3, Pmax=3e6, TR=TR)\n    F += MRIgeneralizedBloch.TRF_TV!(grad_TRF, ω1, TRF; λ=1e3)\n\n    MRIgeneralizedBloch.apply_bounds_to_grad!(G, x, grad_ω1, grad_TRF; ω1_min = ω1_min, ω1_max = ω1_max, TRF_min = TRF_min, TRF_max = TRF_max)\n    return F\nend;\nnothing #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"We use the packge Optim.jl, which requires the cost function fg!(F, G, x) to take the cost, the gradient, and the control as input variables and it will over-writes the gradient in place. The cost function calculates the gradient of the CRB with above described optimal control code and we, further, add some regularization terms: second_order_α! penalizes the curvature of α, which results in smoother flip angle trains and helps ensuring the hybrid state conditions. The penalty RF_power! penalizes the power deposition of the RF-pulse train if sum(ω_1^2  T_textRF)  T_textcycle  Pmax and helps with compliance with safety limits. Assuming a reasonble λ, the resulting enery will be Pmax in units of (rad/s)² and averaged over the cycle. The value Pmax=3e6 (rad/s)² heuristically proofed to run reliably on a 3T system. The penalty TRF_TV! penalizes fast fluctuations of T_textRF, as know that fluctuations of ω_1 and T_textRF have negligible effect if they are fast than the biophysical time constants. We note, however, that this penalty is not required and rather ensure beauty of the result.","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"With all this in place, we can start the actual optimization","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"result = optimize(Optim.only_fg!(fg!), # cost function\n    x0,                                # initialization\n    BFGS(),                            # algorithm\n    Optim.Options(show_trace=true,     # show cost function\n        iterations=10_000,             # larger number as we use a time limit\n        time_limit=(15*60)             # in seconds\n        )\n    )","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"and see that the CRB(m0s) has reduced substantially:","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"(CRBm0s, grad_ω1, grad_TRF) = MRIgeneralizedBloch.CRB_gradient_OCT(ω1, TRF, TR, ω0, B1, m0s, R1f, R2f, Rx, R1s, T2s, R2slT, grad_list, weights, isInversionPulse=isInversionPulse)\nCRBm0s","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"After transfering the result back into the space of bounded ω_1 and T_textRF values","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"ω1, TRF = MRIgeneralizedBloch.get_bounded_ω1_TRF(result.minimizer; ω1_min = ω1_min, ω1_max = ω1_max, TRF_min = TRF_min, TRF_max = TRF_max);\nnothing #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"and calculating the flip angle, we can plot the optimized control:","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"α = ω1 .* TRF\np1 = plot(TR*(1:Npulse), α ./ π, ylabel=\"α/π\")\np2 = plot(TR*(1:Npulse), 1e6TRF, ylim=(0, 1e3), xlabel=\"t (s)\", ylabel=\"TRF (μs)\")\np = plot(p1, p2, layout=(2, 1), legend=:none)\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"To analyze the results, we can calculate and plot all magnetization components:","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"m = calculatesignal_linearapprox(α, TRF, TR, ω0, B1, m0s, R1f, R2f, Rx, R1s, T2s, R2slT; output=:realmagnetization)\nm = vec(m)\n\nxf = [m[i][1] for i=1:length(m)]\nyf = [m[i][2] for i=1:length(m)]\nzf = [m[i][3] for i=1:length(m)]\nxs = [m[i][4] for i=1:length(m)]\nzs = [m[i][5] for i=1:length(m)]\n\np = plot(xlabel=\"t (s)\", ylabel=\"m (normalized)\")\nplot!(p, TR*(1:Npulse), xf ./(1-m0s), label=\"xᶠ\")\nplot!(p, TR*(1:Npulse), yf ./(1-m0s), label=\"yᶠ\")\nplot!(p, TR*(1:Npulse), zf ./(1-m0s), label=\"zᶠ\")\nplot!(p, TR*(1:Npulse), xs ./   m0s , label=\"xˢ\")\nplot!(p, TR*(1:Npulse), zs ./   m0s , label=\"zˢ\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"And we can also plot the dynamics of the free spin pool on the Bloch sphere:","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"p = plot(xf, zf, xlabel=\"xf\", ylabel=\"zf\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"As yᶠ is close to zero in this particular case, we neglect it in this 2D plot.","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"This page was generated using Literate.jl.","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"EditURL = \"https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/master/docs/src/Analyze_NMR_PreSat_Data.jl\"","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"(Image: )","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/#Continuous-Wave-Saturation-Experiments","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"The following code analyzes data from a steady-state experiment similar to the original work of Henkelman et al. In this experiment, the magnetization of the coupled spin system is saturated with off-resonant continuous waves of the exponentially spaced frequencies:","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"Δ = exp.(range(log(0.01e3), log(100e3), length=20)) * 2π # rad/s","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"and the amplitudes:","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"ω1_dB = -60:5:-5 # dB\nω1 = @. 10^(ω1_dB / 20) * π / 2 / 11.4e-6 # rad/s","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"The waves were applied for 7 seconds to ensure a steady state. Thereafter, the magnetization was excited with a π/2-pulse and an FID was acquired. The repetition times was 30s to ensure full recovery to thermal equilibrium.","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"We fit the data with Henkelman's closed form solution to this steady-state problem while assuming a Lorentzian lineshape for the free spin pool, and different lineshapes for the semi-solid spin pool:","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"g_Lorentzian(Δ, T2) = T2 / π / (1 + (T2 * Δ)^2)\ng_Gaussian(Δ, T2) = T2 / sqrt(2π) * exp(-(T2 * Δ)^2 / 2)\ng_superLorentzian(Δ, T2) = T2 * sqrt(2 / π) * quadgk(ct -> exp(- 2 *  (T2 * Δ / (3 * ct^2 - 1))^2) / abs(3 * ct^2 - 1), 0, sqrt(1 / 3), 1)[1];\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"For this data analysis we need the following packages:","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"using MRIgeneralizedBloch\nusing QuadGK\nusing LsqFit\nusing LinearAlgebra\nusing Statistics\nusing Printf\nusing Plots\nplotlyjs(bg=RGBA(31 / 255, 36 / 255, 36 / 255, 1.0), ticks=:native); # hide\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"The raw data is stored in a separate github repository and the following functions return the URL to the individual files:","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"MnCl2_data(ω1_dB) = string(\"https://github.com/JakobAsslaender/MRIgeneralizedBloch_NMRData/blob/main/20210419_1mM_MnCl2/ja_PreSat_v2%20(\", ω1_dB, \")/1/data.2d?raw=true\")\nBSA_data(ω1_dB)   = string(\"https://github.com/JakobAsslaender/MRIgeneralizedBloch_NMRData/blob/main/20210416_15%25BSA_2ndBatch/ja_PreSat_v2%20(\", ω1_dB, \")/1/data.2d?raw=true\");\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"which can be loaded with functions implemented in this file:","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"include(string(pathof(MRIgeneralizedBloch), \"/../../docs/src/load_NMR_data.jl\"));\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"We store the off-resonance frequencies and wave amplitudes in a single matrix for convenience:","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"x = zeros(Float64, length(ω1) * length(Δ), 2)\nx[:,1] = repeat(Δ, length(ω1))\nx[:,2] = vec(repeat(ω1, 1, length(Δ))');\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/#MnCl_2-Sample","page":"Continuous Wave Saturation Experiments","title":"MnCl_2 Sample","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"We load the first data point of each FID:","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"M = zeros(Float64, length(Δ), length(ω1))\nfor i = 1:length(ω1_dB)\n    M[:,i] = load_first_datapoint(MnCl2_data(ω1_dB[i]); set_phase=:abs)\nend\nM ./= maximum(M);\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"In contrast to the inversion-recovery experiment, the phase of the signal was not stable. Therefore, we took the absolute value of the signal by setting the flag set_phase=:abs.","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"The MnCl_2-data can be described with a single compartment model:","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"function single_compartment_model(x, p)\n    (m0, R1, T2) = p\n\n    Δ  = @view x[:,1]\n    ω1 = @view x[:,2]\n\n    Rrf = @. π * ω1^2 * g_Lorentzian(Δ, T2)\n    m = @. m0 * R1 / (R1 + Rrf)\n    return m\nend;\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"(cf. Eqs. (14) and (15) in the paper).","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"As this model is merely a function of the relaxation times T₁ and T₂, we forgo a fitting routine and use the estimates from the Inversion Recovery Experiments instead:","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"R1 = 1.479 # 1/s\nT2 = 0.075 # s\nnothing # hide","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"Visually, this model describes the data well:","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"p = plot(xlabel=\"Δ [rad/s]\", ylabel=\"M / max(M)\", xaxis=:log, legend=:none)\n[scatter!(p, Δ, M[:,i], color=i) for i=1:length(ω1)]\n[plot!(p, Δ, reshape(single_compartment_model(x, [1,R1,T2]), length(Δ), length(ω1))[:,i], color=i) for i=1:length(ω1)]\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/#Bovine-Serum-Albumin-Sample","page":"Continuous Wave Saturation Experiments","title":"Bovine Serum Albumin Sample","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"We acquired the same data for the BSA sample, which we load:","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"for i = 1:length(ω1_dB)\n    M[:,i] = load_first_datapoint(BSA_data(ω1_dB[i]); set_phase=:abs)\nend\nM ./= maximum(M);\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"We model the steady-state magnetization as described by Henkelman et al.:","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"function Henkelman_model(x, p; lineshape=:superLorentzian)\n    (m0, m0s, R1f, R1s, T2f, T2s, Rx) = p\n\n    m0s /= 1 - m0s # switch from m0s + m0f = 1 to m0f = 1 normalization\n\n    Δ  = @view x[:,1]\n    ω1 = @view x[:,2]\n\n    Rrf_f = @. π * ω1^2 * g_Lorentzian(Δ, T2f)\n\n    if lineshape == :Lorentzian\n        Rrf_s = @. π * ω1^2 * g_Lorentzian(Δ, T2s)\n    elseif lineshape == :Gaussian\n        Rrf_s = @. π * ω1^2 * g_Gaussian(Δ, T2s)\n    elseif lineshape == :superLorentzian\n        Rrf_s = @. π * ω1^2 * g_superLorentzian(Δ, T2s)\n    end\n\n    m = @. m0 * (R1s * Rx * m0s + Rrf_s * R1f + R1f * R1s + R1f * Rx) / ((R1f + Rrf_f + Rx * m0s) * (R1s + Rrf_s + Rx) - Rx^2 * m0s)\n    return m\nend;\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"Here, we use a fitting routine to demonstrate the best possible fit with each of the three lineshapes. We define an initialization for the fitting routine p0 = [m0, m0s, R1f, R1s, T2f, T2s, Rx] and set some reasonable bounds:","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"p0   = [  1,0.01,   1,   5,0.052,  1e-5, 40]\npmin = [  0,   0,   0,   0,0.052,  1e-6,  1]\npmax = [Inf,   1, Inf, Inf,0.052, 10e-3,100];\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"Note that we fixed T₂ᶠ = 52ms to the value estimated with the Inversion Recovery Experiments as T₂ᶠ is poorly defined by this saturation experiment.","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/#Super-Lorentzian-Lineshape","page":"Continuous Wave Saturation Experiments","title":"Super-Lorentzian Lineshape","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"Fitting the model with a super-Lorentzian lineshape to the data achieves good concordance:","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"fit = curve_fit((x, p) -> Henkelman_model(x, p; lineshape=:superLorentzian), x, vec(M), p0, lower=pmin, upper=pmax)\nfit_std = stderror(fit)\n\np = plot(xlabel=\"Δ [rad/s]\", ylabel=\"M / max(M)\", xaxis=:log, legend=:none)\n[scatter!(p, Δ, M[:,i], color=i) for i=1:length(ω1)]\n[plot!(p, Δ, reshape(Henkelman_model(x, fit.param), length(Δ), length(ω1))[:,i], color=i) for i=1:length(ω1)]\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/#Lorentzian-Lineshape","page":"Continuous Wave Saturation Experiments","title":"Lorentzian Lineshape","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"The Lorentzian lineshape, on the other hand, does not fit the data well:","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"fit = curve_fit((x, p) -> Henkelman_model(x, p; lineshape=:Lorentzian), x, vec(M), p0, lower=pmin, upper=pmax)\nfit_std = stderror(fit)\n\np = plot(xlabel=\"Δ [rad/s]\", ylabel=\"M / max(M)\", xaxis=:log, legend=:none)\n[scatter!(p, Δ, M[:,i], color=i) for i=1:length(ω1)]\n[plot!(p, Δ, reshape(Henkelman_model(x, fit.param), length(Δ), length(ω1))[:,i], color=i) for i=1:length(ω1)]\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/#Gaussian-Lineshape","page":"Continuous Wave Saturation Experiments","title":"Gaussian Lineshape","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"And the Gaussian lineshape does not not fit the data well either:","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"fit = curve_fit((x, p) -> Henkelman_model(x, p; lineshape=:Lorentzian), x, vec(M), p0, lower=pmin, upper=pmax)\nfit_std = stderror(fit)\n\np = plot(xlabel=\"Δ [rad/s]\", ylabel=\"M / max(M)\", xaxis=:log, legend=:none)\n[scatter!(p, Δ, M[:,i], color=i) for i=1:length(ω1)]\n[plot!(p, Δ, reshape(Henkelman_model(x, fit.param), length(Δ), length(ω1))[:,i], color=i) for i=1:length(ω1)]\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"This page was generated using Literate.jl.","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"EditURL = \"https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/master/docs/src/Analyze_NMR_IR_Data.jl\"","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"(Image: )","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/#Inversion-Recovery-Experiments","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"The following code replicates the NMR data analysis in Figs. 4-6 and complements the paper with additional analyses that are not shown in the paper in the interest of brevity.","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"For this analysis we need the following packages:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"using MRIgeneralizedBloch\nusing DifferentialEquations\nusing LinearAlgebra\nusing LsqFit\nusing Statistics\nimport Pingouin\nusing Printf\nusing Formatting\nusing Plots\nplotlyjs(bg = RGBA(31/255,36/255,36/255,1.0), ticks=:native); #hide\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"The raw data is stored in a separate github repository and the following functions return the URL to the individual files:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"MnCl2_data(TRF_scale) = string(\"https://github.com/JakobAsslaender/MRIgeneralizedBloch_NMRData/blob/main/20210419_1mM_MnCl2/ja_IR_v2%20(\", TRF_scale, \")/1/data.2d?raw=true\")\nBSA_data(TRF_scale)   = string(\"https://github.com/JakobAsslaender/MRIgeneralizedBloch_NMRData/blob/main/20210416_15%25BSA_2ndBatch/ja_IR_v2%20(\", TRF_scale, \")/1/data.2d?raw=true\");\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"which can be loaded with functions implemented in this file:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"include(string(pathof(MRIgeneralizedBloch), \"/../../docs/src/load_NMR_data.jl\"));\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/#MnCl_2-Sample","page":"Inversion Recovery Experiments","title":"MnCl_2 Sample","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_IR_Data/#T_2{*,f}-Estimation","page":"Inversion Recovery Experiments","title":"T_2^*f Estimation","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"We estimate T_2^*f by fitting a mono-exponential decay curve to the FID of the acquisition with T_textRF = 228μs and T_texti = 5s.","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"M = load_Data(MnCl2_data(1))\nM = M[:,1]; # select Tᵢ = 5s\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"The data was measured at the following time points in units of seconds:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"T_dwell = 100e-6 # s\nTE = T_dwell * ((1:length(M)) .+ 7) # s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Note that the signal is an FID, so the phrase echo time is a bit misleading.","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"The function curve_fit from the LsqFit.jl package is only implemented for real-valued models. To accommodate this, we need to split the data into its real and imaginary part:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"TEreal = [TE;TE]\nMreal = [real(M);imag(M)];\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Here, we are using a simple mono-exponential model with a complex-valued scaling factor p[1] + 1im p[2], the decay time T_2^*f = p[3], and the Larmor frequency p[4]:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"FID_model(t, p) = @. [p[1] * exp(- t[1:end ÷ 2] / p[3]) * cos(p[4] * t[1:end ÷ 2]); p[2] * exp(- t[end ÷ 2 + 1:end] / p[3]) * sin(p[4] * t[end ÷ 2 + 1:end])];\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Fitting this model to the NMR data estimates T_2^*f:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"fit = curve_fit(FID_model, TEreal, Mreal, [1, 1, 0.1, 0])\nT₂star_MnCl2 = fit.param[3] # s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"seconds and its uncertainty (also in units of seconds)","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"stderror(fit)[3] # s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Visually, the plot and the data show good agreement:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Mfitted = FID_model(TEreal, fit.param)\nMfitted = Mfitted[1:end÷2] + 1im * Mfitted[end÷2+1:end]\np = plot(xlabel=\"TE [s]\", ylabel=\"|FID(TE)| [a.u.]\")\nplot!(p, TE, abs.(M), label=\"data\")\nplot!(p, TE, abs.(Mfitted), label=@sprintf(\"fit with T₂* = %2.3f ms\", 1e3 * T₂star_MnCl2))\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"The relative residual norm of the fit, i.e. textresidual_2M_2 is","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"norm(fit.resid) / norm(M)","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Despite its small ell_2-norm, the Shapiro-Wilk test indicates that the residual is not Gaussian or normal distributed at a significance level of α=0.05","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Pingouin.normality(fit.resid, α=0.05)","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"We note that mono-exponential T_2^* decays assume a Lorentzian distributed magnetic field, which is in general an assumption rather than a well-founded theory.","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/#Mono-Exponential-IR-Model","page":"Inversion Recovery Experiments","title":"Mono-Exponential IR Model","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"We performed several experiments in which we inverted the thermal equilibrium magnetization with rectangular π-pulses with the following pulse durations (in seconds):","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Tʳᶠmin = 22.8e-6 # s - shortest Tʳᶠ possible on the NMR\nTRF_scale = [1;2;5:5:40] # scaling factor\nTʳᶠ = TRF_scale * Tʳᶠmin # s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"and acquired inversion recovery data at exponentially spaced inversion times (in seconds):","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Tᵢ = exp.(range(log(3e-3), log(5), length=20)) # s\nTᵢ .+= 12 * Tʳᶠmin + (13 * 15.065 - 5) * 1e-6 # s - correction factors","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"We calculate the Rabi frequencies of the RF pulses and a finer grid of T_texti to plot the IR model:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"ω₁ = π ./ Tʳᶠ # rad/s\nTᵢplot = exp.(range(log(Tᵢ[1]), log(Tᵢ[end]), length=500)); # s\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"After loading and normalizing the data","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"M = zeros(Float64, length(Tᵢ), length(TRF_scale))\nfor i = 1:length(TRF_scale)\n    M[:,i] = load_first_datapoint(MnCl2_data(TRF_scale[i]))\nend\nM ./= maximum(M);\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"we analyze each inversion recovery curve that corresponds to a different T_textRF separately. This allows us to fit a simple mono-exponential model","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"standard_IR_model(t, p) = @. p[1] - p[3] * exp(- t * p[2]);\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"where p[1] is the thermal equilibrium magnetization, p[2] = T_1, and p[1] - p[3] is the magnetization right after the inversion pulse or, equivalently, Minv = p[1] / p[3] - 1 is the inversion efficiency, which is 1 for an ideal π-pulse and smaller otherwise. The parameters are initialized with","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"p0 = [1.0, 1.0, 2.0];\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"and we can loop over T_textRF to perform the fits:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"R₁ = similar(M[1,:])\nMinv = similar(R₁)\nresidual = similar(R₁)\np = plot(xlabel=\"Tᵢ [s]\", ylabel=\"zᶠ(Tʳᶠ, Tᵢ) [a.u.]\")\nfor i = 1:length(TRF_scale)\n    Mi = @view M[:,i]\n\n    fit = curve_fit(standard_IR_model, Tᵢ, Mi, p0)\n\n    R₁[i] = fit.param[2]\n    Minv[i] = fit.param[3] / fit.param[1] - 1\n\n    residual[i] = norm(fit.resid) / norm(Mi)\n\n    scatter!(p, Tᵢ, Mi, label=@sprintf(\"Tʳᶠ = %1.2es - data\", Tʳᶠ[i]), color=i)\n    plot!(p, Tᵢplot, standard_IR_model(Tᵢplot, fit.param), label=@sprintf(\"fit with R₁ = %.3f/s; MInv = %.3f\", R₁[i], Minv[i]), color=i)\nend\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Here, the data measured with different T_textRF are indicated by markers in different colors, and the corresponding fits are the line plots in the same color. The fitted parameters are denoted in the legend. In the paper, we highlight the estimated inversion efficiency and the relaxation rate of the dataset acquired with T_textRF=228μs:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Minv[1]","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"R₁[1] # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"and of the dataset acquired with T_textRF=912μs:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Minv[end]","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"R₁[end] # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"The mean value of all R₁ estimates is","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"mean(R₁) # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"1/s and its standard deviation in units of 1/s is","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"std(R₁) # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"The relative residual norm of the fits is on average","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"mean(residual)","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/#Global-IR-Fit","page":"Inversion Recovery Experiments","title":"Global IR Fit","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"As an alternative to individual fits to the inversion recovery curves with different T_textRF, we can also perform a global fit that accounts for the T_2^*f decay during the inversion pulse. The model first simulates the T_2^*f decay during the inversion pulse, followed by T_1 recovery:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"function Bloch_IR_model(p, Tʳᶠ, Tᵢ, T2)\n    (m0, m0_inv, R₁) = p\n    R2 = 1 / T2\n\n    M = zeros(Float64, length(Tᵢ), length(Tʳᶠ))\n    for i = 1:length(Tʳᶠ)\n        # simulate inversion pulse\n        ω₁ = π / Tʳᶠ[i]\n        H = [-R2 -ω₁ 0 ;\n              ω₁ -R₁ R₁;\n               0   0 0 ]\n\n        m_inv = m0_inv * (exp(H * Tʳᶠ[i]) * [0,1,1])[2]\n\n        # simulate T1 recovery\n        H = [-R₁ R₁*m0;\n               0     0]\n\n        for j = 1:length(Tᵢ)\n            M[j,i] = m0 * (exp(H .* (Tᵢ[j] - Tʳᶠ[i] / 2)) * [m_inv,1])[1]\n        end\n    end\n    return vec(M)\nend;\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"We use the previously estimated T_2^*f value for the fit:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"fit = curve_fit((x, p) -> Bloch_IR_model(p, Tʳᶠ, Tᵢ, T₂star_MnCl2), 1:length(M), vec(M), [ 1, .8, 1])\n\np = plot(xlabel=\"Tᵢ [s]\", ylabel=\"zᶠ(Tʳᶠ, Tᵢ) [a.u.]\")\nfor i=1:length(Tʳᶠ)\n    scatter!(p, Tᵢ, M[:,i], label=@sprintf(\"Tʳᶠ = %1.2es\", Tʳᶠ[i]), color=i)\n    plot!(p, Tᵢplot, Bloch_IR_model(fit.param, Tʳᶠ[i], Tᵢplot, T₂star_MnCl2), label=@sprintf(\"Tʳᶠ = %1.2es\", Tʳᶠ[i]), color=i)\nend\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"With this global fit, we get a very similar relaxation rate in units of 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"R₁_MnCl2 = fit.param[3] # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"with an uncertainty (also in units of 1/s) of","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"stderror(fit)[3] # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Note that the relative residual norm is somewhat increased compared to individual fits to each inversion recovery curve:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"norm(fit.resid) / norm(M)","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/#Bovine-Serum-Albumin-Sample","page":"Inversion Recovery Experiments","title":"Bovine Serum Albumin Sample","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_IR_Data/#T_2{*,f}-Estimation-2","page":"Inversion Recovery Experiments","title":"T_2^*f Estimation","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"We repeat the T_2^*f estimation for the bovine serum albumin (BSA) sample by fitting a mono-exponential decay curve to the FID of the acquisition with T_textRF = 228μs and T_texti = 5s.","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"M = load_Data(BSA_data(1));\nM = M[:,1] # select Tᵢ = 5s\nMreal = [real(M);imag(M)]\n\nfit = curve_fit(FID_model, TEreal, Mreal, [1.0, 1.0, .1, 0.0]);\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"The estimated T_2^*f of the BSA sample is","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"T₂star_BSA = fit.param[3] # s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"seconds with an uncertainty of","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"stderror(fit)[3] # s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"seconds.","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Visually, the plot and the data align well for the BSA sample, too:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Mfitted = FID_model(TEreal, fit.param)\nMfitted = Mfitted[1:end÷2] + 1im * Mfitted[end÷2+1:end]\np = plot(xlabel=\"TE [s]\", ylabel=\"|FID(TE)| [a.u.]\")\nplot!(p, TE, abs.(M), label=\"data\")\nplot!(p, TE, abs.(Mfitted), label=@sprintf(\"fit with T₂* = %2.3f ms\", 1e3 * T₂star_BSA))\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"The relative residual norm (textresidual_2M_2) is","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"norm(fit.resid) / norm(M)","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Despite the small residual, the Shapiro-Wilk test indicates that the residual is not normal distributed for this sample either:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Pingouin.normality(fit.resid, α=0.05)","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/#Mono-Exponential-IR-Model-2","page":"Inversion Recovery Experiments","title":"Mono-Exponential IR Model","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"We also fit a mono-exponential model to each inversion recovery curve of the BSA data:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"M = zeros(Float64, length(Tᵢ), length(TRF_scale))\nfor i = 1:length(TRF_scale)\n    M[:,i] = load_first_datapoint(BSA_data(TRF_scale[i]))\nend\nM ./= maximum(M)\n\n\np = plot(xlabel=\"Tᵢ [s]\", ylabel=\"zᶠ(Tʳᶠ, Tᵢ) [a.u.]\")\nfor i = 1:length(TRF_scale)\n    Mi = @view M[:,i]\n\n    fit = curve_fit(standard_IR_model, Tᵢ, Mi, p0)\n\n    R₁[i] = fit.param[2]\n    Minv[i] = fit.param[3] / fit.param[1] - 1\n    residual[i] = norm(fit.resid) / norm(Mi)\n\n    scatter!(p, Tᵢ, Mi, label=@sprintf(\"Tʳᶠ = %1.2es - data\", Tʳᶠ[i]), color=i)\n    plot!(p, Tᵢplot, standard_IR_model(Tᵢplot, fit.param), label=@sprintf(\"fit with R₁ = %.3f/s; MInv = %.3f\", R₁[i], Minv[i]), color=i)\nend\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Zooming into the early phase of the recovery curve reveals the poor fit quality, in particular for long T_textRF. This is also reflected by a substantially larger relative residual norm compared to the MnCl_2 sample:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"mean(residual)","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"In the paper, we highlight the estimated inversion efficiency and the relaxation rate of the dataset acquired with T_textRF=228μs","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Minv[1]","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"R₁[1] # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"and of the dataset acquired with T_textRF=912μs","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Minv[end]","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"R₁[end] # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"The mean value of all R₁ estimates is","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"mean(R₁) # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"and its standard deviation is substantially larger compared to the same fit of the MnCl_2 sample:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"std(R₁) # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/#Global-IR-Fit-Generalized-Bloch-Model","page":"Inversion Recovery Experiments","title":"Global IR Fit - Generalized Bloch Model","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"In order to repeat the global fit that includes all T_textRF values, we have to account for the spin dynamics in the semi-solid pool during the RF-pulse. First, we do this with the proposed generalized Bloch model:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"function gBloch_IR_model(p, G, Tʳᶠ, TI, R2f)\n    (m0, m0f_inv, m0s, R₁, T₂ˢ, Rx) = p\n    m0f = 1 - m0s\n    ω₁ = π ./ Tʳᶠ\n\n    m0vec = [0, 0, m0f, m0s, 1]\n    m_fun(p, t; idxs=nothing) = typeof(idxs) <: Number ? 0.0 : zeros(5)\n\n\n    H = [-R₁-m0s*Rx     m0f*Rx R₁*m0f;\n             m0s*Rx -R₁-m0f*Rx R₁*m0s;\n              0          0         0 ]\n\n    M = zeros(Float64, length(TI), length(Tʳᶠ))\n    for i = 1:length(Tʳᶠ)\n        param = (ω₁[i], 1, 0, m0s, R₁, R2f, Rx, R₁, T₂ˢ, G)\n        prob = DDEProblem(apply_hamiltonian_gbloch!, m0vec, m_fun, (0.0, Tʳᶠ[i]), param)\n        m = solve(prob)[end]\n\n        for j = 1:length(TI)\n            M[j,i] = m0 * (exp(H .* (TI[j] - Tʳᶠ[i] / 2)) * [m0f_inv * m[3],m[4],1])[1]\n        end\n    end\n    return vec(M)\nend;\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Here, we use assume a super-Lorentzian lineshape, whose Green's function is interpolated to speed up the fitting routine:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"T₂ˢ_min = 5e-6 # s\nG_superLorentzian = interpolate_greens_function(greens_superlorentzian, 0, maximum(Tʳᶠ)/T₂ˢ_min);\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"The fit is initialized with p0 = [m0, m0f_inv, m0_s, R₁, T2_s, Rx] and we set some reasonable bounds to the fitted parameters:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"p0   = [  1, 0.932,  0.1,   1, 10e-6, 50]\npmin = [  0, 0.100,   .0, 0.3,  1e-9, 10]\npmax = [Inf,   Inf,  1.0, Inf, 20e-6,1e3]\n\nfit_gBloch = curve_fit((x, p) -> gBloch_IR_model(p, G_superLorentzian, Tʳᶠ, Tᵢ, 1/T₂star_BSA), [], vec(M), p0, lower=pmin, upper=pmax);\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Visually, the plot and the data align well:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"p = plot(xlabel=\"Tᵢ [s]\", ylabel=\"zᶠ(Tʳᶠ, Tᵢ) [a.u.]\")\nfor i=1:length(Tʳᶠ)\n    scatter!(p, Tᵢ, M[:,i], label=@sprintf(\"Tʳᶠ = %1.2es\", Tʳᶠ[i]), color=i)\n    plot!(p, Tᵢplot, gBloch_IR_model(fit_gBloch.param, G_superLorentzian, Tʳᶠ[i], Tᵢplot, 1/T₂star_BSA), label=@sprintf(\"Tʳᶠ = %1.2es\", Tʳᶠ[i]), color=i)\nend\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"which becomes particularly apparent when zooming into the beginning of the inversion recovery curves. Further, the relative residual norm is much smaller compared to the mono-exponential fit:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"norm(fit_gBloch.resid) / norm(M)","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"The estimated parameters are","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"m0 = fit_gBloch.param[1]","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Minv = fit_gBloch.param[2]","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"m0s = fit_gBloch.param[3]","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"R₁ = fit_gBloch.param[4] # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"T₂ˢ = 1e6fit_gBloch.param[5] # μs","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Rx = fit_gBloch.param[6] # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"with the uncertainties (in the same order)","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"stderror(fit_gBloch)","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/#Global-IR-Fit-Graham's-Spectral-Model","page":"Inversion Recovery Experiments","title":"Global IR Fit - Graham's Spectral Model","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"For comparison, we repeat the same fit with Graham's spectral model:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"function Graham_IR_model(p, Tʳᶠ, TI, R2f)\n    (m0, m0f_inv, m0s, R₁, T₂ˢ, Rx) = p\n    m0f = 1 - m0s\n    ω₁ = π ./ Tʳᶠ\n\n    m0vec = [0, 0, m0f, m0s, 1]\n\n    H = [-R₁-m0s*Rx     m0f*Rx R₁*m0f;\n             m0s*Rx -R₁-m0f*Rx R₁*m0s;\n              0          0         0 ]\n\n    M = zeros(Float64, length(TI), length(Tʳᶠ))\n    for i = 1:length(Tʳᶠ)\n        param = (ω₁[i], 1, 0, Tʳᶠ[i], m0s, R₁, R2f, Rx, R₁, T₂ˢ)\n        prob = ODEProblem(apply_hamiltonian_graham_superlorentzian!, m0vec, (0.0, Tʳᶠ[i]), param)\n        m = solve(prob)[end]\n\n        for j = 1:length(TI)\n            M[j,i] = m0 * (exp(H .* (TI[j] - Tʳᶠ[i] / 2)) * [m0f_inv * m[3],m[4],1])[1]\n        end\n    end\n    return vec(M)\nend\n\nfit_Graham = curve_fit((x, p) -> Graham_IR_model(p, Tʳᶠ, Tᵢ, 1/T₂star_BSA), [], vec(M), p0, lower=pmin, upper=pmax);\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Visually, the plot and the data align substantially worse:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"p = plot(xlabel=\"Tᵢ [s]\", ylabel=\"zᶠ(Tʳᶠ, Tᵢ) [a.u.]\")\nfor i=1:length(Tʳᶠ)\n    scatter!(p, Tᵢ, M[:,i], label=@sprintf(\"Tʳᶠ = %1.2es\", Tʳᶠ[i]), color=i)\n    plot!(p, Tᵢplot, Graham_IR_model(fit_Graham.param, Tʳᶠ[i], Tᵢplot, 1/T₂star_BSA), label=@sprintf(\"Tʳᶠ = %1.2es\", Tʳᶠ[i]), color=i)\nend\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"which becomes particularly apparent when zooming into the beginning of the inversion recovery curves. Further, the relative residual norm is much larger compared to the generalized Bloch fit:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"norm(fit_Graham.resid) / norm(M)","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"The estimated parameters are","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"m0 = fit_Graham.param[1]","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Minv = fit_Graham.param[2]","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"m0s = fit_Graham.param[3]","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"R₁ = fit_Graham.param[4] # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"T₂ˢ = 1e6fit_Graham.param[5] # μs","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Rx = fit_Graham.param[6] # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"with the uncertainties (in the same order)","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"stderror(fit_Graham)","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/#Global-IR-Fit-Sled's-Model","page":"Inversion Recovery Experiments","title":"Global IR Fit - Sled's Model","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"We also performed the fit with Sled's model:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"function Sled_IR_model(p, G, Tʳᶠ, TI, R2f)\n    (m0, m0f_inv, m0s, R₁, T₂ˢ, Rx) = p\n    m0f = 1 - m0s\n    ω₁ = π ./ Tʳᶠ\n\n    m0vec = [0, 0, m0f, m0s, 1]\n\n    H = [-R₁-m0s*Rx     m0f*Rx R₁*m0f;\n             m0s*Rx -R₁-m0f*Rx R₁*m0s;\n              0          0         0 ]\n\n    M = zeros(Float64, length(TI), length(Tʳᶠ))\n    for i = 1:length(Tʳᶠ)\n        param = (ω₁[i], 1, 0, m0s, R₁, R2f, Rx, R₁, T₂ˢ, G)\n        prob = ODEProblem(apply_hamiltonian_sled!, m0vec, (0.0, Tʳᶠ[i]), param)\n        m = solve(prob)[end]\n\n        for j = 1:length(TI)\n            M[j,i] = m0 * (exp(H .* (TI[j] - Tʳᶠ[i] / 2)) * [m0f_inv * m[3],m[4],1])[1]\n        end\n    end\n    return vec(M)\nend\n\nfit_Sled = curve_fit((x, p) -> Sled_IR_model(p, G_superLorentzian, Tʳᶠ, Tᵢ, 1/T₂star_BSA), [], vec(M), p0, lower=pmin, upper=pmax);\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Visually, the plot and the data do not align well either:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"p = plot(xlabel=\"Tᵢ [s]\", ylabel=\"zᶠ(Tʳᶠ, Tᵢ) [a.u.]\")\nfor i=1:length(Tʳᶠ)\n    scatter!(p, Tᵢ, M[:,i], label=@sprintf(\"Tʳᶠ = %1.2es\", Tʳᶠ[i]), color=i)\n    plot!(p, Tᵢplot, Sled_IR_model(fit_Sled.param, G_superLorentzian, Tʳᶠ[i], Tᵢplot, 1/T₂star_BSA), label=@sprintf(\"Tʳᶠ = %1.2es\", Tʳᶠ[i]), color=i)\nend\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"which becomes particularly apparent when zooming into the beginning of the inversion recovery curves. Further, the relative residual norm is also large compared to the generalized Bloch fit:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"norm(fit_Sled.resid) / norm(M)","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"The estimated parameters are","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"m0 = fit_Sled.param[1]","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Minv = fit_Sled.param[2]","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"m0s = fit_Sled.param[3]","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"R₁ = fit_Sled.param[4] # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"T₂ˢ = 1e6fit_Sled.param[5] # μs","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Rx = fit_Sled.param[6] # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"with the uncertainties (in the same order)","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"stderror(fit_Sled)","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/#Analysis-of-the-Residuals","page":"Inversion Recovery Experiments","title":"Analysis of the Residuals","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"In order to visualize how well the three models align with the data at different T_textRF, we calculate the ell_2-norm of the residuals after subtracting the modeled from the measured signal and normalize it by the ell_2-norm of the signal:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"resid_gBlo = similar(Tʳᶠ)\nresid_Sled = similar(Tʳᶠ)\nresid_Grah = similar(Tʳᶠ)\nfor i=1:length(Tʳᶠ)\n    resid_gBlo[i] = norm(gBloch_IR_model(fit_gBloch.param, G_superLorentzian, Tʳᶠ[i], Tᵢ, 1/T₂star_BSA) .- M[:,i]) / norm(M[:,i])\n    resid_Grah[i] = norm(Graham_IR_model(fit_Graham.param, Tʳᶠ[i], Tᵢ, 1/T₂star_BSA)                    .- M[:,i]) / norm(M[:,i])\n    resid_Sled[i] = norm(Sled_IR_model(  fit_Sled.param,   G_superLorentzian, Tʳᶠ[i], Tᵢ, 1/T₂star_BSA) .- M[:,i]) / norm(M[:,i])\nend\n\np = plot(xlabel=\"Tʳᶠ [s]\", ylabel=\"relative residual\")\nscatter!(p, Tʳᶠ, resid_gBlo, label=\"generalized Bloch model\")\nscatter!(p, Tʳᶠ, resid_Grah, label=\"Graham's spectral model\")\nscatter!(p, Tʳᶠ, resid_Sled, label=\"Sled's model\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"This analysis examines the residuals from the actual fits, i.e. it uses the biophysical parameters of respective fit to model the signal. The disadvantage of this approach is that residuals at long T_textRF are negatively affected by the poor fits of Graham's and Sled's models at short T_textRF. This problem is overcome by subtracting the measured signal from signal that is simulated with the biophysical parameters that were estimated by fitting the generalized Bloch model:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"for i=1:length(Tʳᶠ)\n    resid_gBlo[i] = norm(gBloch_IR_model(fit_gBloch.param, G_superLorentzian, Tʳᶠ[i], Tᵢ, 1/T₂star_BSA) .- M[:,i]) / norm(M[:,i])\n    resid_Grah[i] = norm(Graham_IR_model(fit_gBloch.param, Tʳᶠ[i], Tᵢ, 1/T₂star_BSA)                    .- M[:,i]) / norm(M[:,i])\n    resid_Sled[i] = norm(Sled_IR_model(  fit_gBloch.param, G_superLorentzian, Tʳᶠ[i], Tᵢ, 1/T₂star_BSA) .- M[:,i]) / norm(M[:,i])\nend\n\np = plot(xlabel=\"Tʳᶠ [s]\", ylabel=\"relative residual\")\nscatter!(p, Tʳᶠ, resid_gBlo, label=\"generalized Bloch model\")\nscatter!(p, Tʳᶠ, resid_Grah, label=\"Graham's spectral model\")\nscatter!(p, Tʳᶠ, resid_Sled, label=\"Sled's model\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"One can observe reduced residuals for Graham's and Sled's models for long T_textRF as a trade off for larger residuals at short T_textRF. Yet, the residuals at long T_textRF are still substantially larger compared to ones of the generalized Bloch model.","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MRIgeneralizedBloch","category":"page"},{"location":"#MRIgeneralizedBloch.jl","page":"Home","title":"MRIgeneralizedBloch.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for the MRIgeneralizedBloch.jl package, which implements the generalized Bloch model for simulating magnetization transfer (MT), as described in our paper. The key innovation of the model is to generalize the original Bloch model to arbitrary lineshapes, such as the super-Lorentzian lineshape which has been shown to describe brain white matter well. This enables a more accurate description of the spin dynamics during short RF-pulses compared to previous MT models.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package allows to simulate the dynamics of an isolated semi-solid spin pool during RF-pulses, as well as the dynamics of a coupled spin system with a free spin pool, for which we use the Bloch model, and a semi-solid pool, which we describe with the generalized Bloch model.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A bare bone demonstration of the interface can found in the Quick Start Tutorial, where the Section Simulation of a Single RF Pulse demonstrates the basic and flexible simulation of the spin dynamics during a single RF pulse and Section Balanced Hybrid-State Free Precession Pulse Sequence demonstrates an efficient simulation of a train of RF pulses.","category":"page"},{"location":"","page":"Home","title":"Home","text":"More details on the implementation are provided in the Section Generalized Bloch Paper, which reproduces all simulations, data analyses, and figures of the generalized Bloch paper:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages=[\n        \"build_literate/Greens_functions.md\",\n        \"build_literate/Simulation_ContinuousWave.md\",\n        \"build_literate/Simulation_Pulse.md\",\n        \"build_literate/Analyze_NMR_IR_Data.md\",\n        \"build_literate/Analyze_NMR_PreSat_Data.md\",\n        \"build_literate/Linear_Approximation.md\",\n]\nDepth = 2","category":"page"},{"location":"","page":"Home","title":"Home","text":"Section Non-Linear Least Square Fitting demonstrates a simple method for parameter estimation at the example of a Balanced Hybrid-State Free Precession Pulse Sequence; and Section Optimal Control outlines the interface for optimizing RF pulse trains for parameter estimation. More details about these topics can be found in the paper Rapid quantitative magnetization transfer imaging: utilizing the hybrid state and the generalized Bloch model.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The documentation of all exported functions can be found in the API Section.","category":"page"}]
}
