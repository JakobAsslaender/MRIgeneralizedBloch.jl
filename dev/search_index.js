var documenterSearchIndex = {"docs":
[{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"(Image: )","category":"section"},{"location":"build_literate/Linear_Approximation/#Linear-Approximation","page":"Linear Approximation","title":"Linear Approximation","text":"The following code demonstrates the linear approximation of the generalized Bloch model and replicates Figs. 7 and 8 in the paper.\n\nFor this analysis we need the following packages:\n\nusing DifferentialEquations\nusing BenchmarkTools\nusing LinearAlgebra\nusing MRIgeneralizedBloch\nusing Plots\nplotlyjs(bg = RGBA(31/255,36/255,36/255,1.0), ticks=:native); #hide\nnothing #hide\n\nand we simulate a coupled spin system with the following parameters:\n\nm₀ˢ = 0.1\nm₀ᶠ = 1-m₀ˢ\nR₁ = 1 # 1/s\nR₂ᶠ = 1 / 50e-3 # 1/s\nRₓ = 70; # 1/s\nnothing #hide","category":"section"},{"location":"build_literate/Linear_Approximation/#Linearized-T_2{s,l}","page":"Linear Approximation","title":"Linearized T_2^sl","text":"We demonstrate the linear approximation at the example of the Green's function corresponding to the super-Lorentzian lineshape, which we interpolate to improve the performance:\n\nG = interpolate_greens_function(greens_superlorentzian, 0, 1e-3 / 5e-6);\nnothing #hide\n\nThe function precompute_R2sl returns another function, R₂ˢˡ(Tʳᶠ, α, B1, T₂ˢ), that interpolates the linearized relaxation rate, as well as functions that describe its derivatives wrt. T_2^s and B_1, respectively:\n\nR₂ˢˡ, ∂R₂ˢˡ∂T₂ˢ, ∂R₂ˢˡ∂B₁ = precompute_R2sl(TRF_min=5, TRF_max=100, T2s_min=1, T2s_max=1, ω1_max=π/5, B1_max=1, greens=G);\nnothing #hide\n\nThe derivatives are not used here and are just assigned for demonstration purposes.\n\nIn order to replicate Fig. 7, we plot R₂ˢˡ(Tʳᶠ, α, B₁, T₂ˢ) for a varying α and T_textRFT_2^s:\n\nα = (0.01:.01:1) * π\nTʳᶠoT₂ˢ = 5:100\n\nTʳᶠoT₂ˢ_m = repeat(reshape(TʳᶠoT₂ˢ, 1, :), length(α), 1)\nα_m = repeat(α, 1, size(TʳᶠoT₂ˢ_m, 2))\n\np = plot(xlabel=\"Tʳᶠ/T₂ˢ\", ylabel=\"α/π\", colorbar_title=\"T₂ˢˡ/T₂ˢ\")\ncontour!(p, TʳᶠoT₂ˢ, α ./ π, 1 ./ R₂ˢˡ.(TʳᶠoT₂ˢ_m, α_m, 1, 1), fill = true)\nMain.HTMLPlot(p) #hide","category":"section"},{"location":"build_literate/Linear_Approximation/#Spin-Dynamics-during-a-single-RF-Pulse","page":"Linear Approximation","title":"Spin Dynamics during a single RF Pulse","text":"To replicate Fig. 8a, we simulate and plot the dynamics of a coupled spin system during a single π-pulse, starting from thermal equilibrium.\n\nTʳᶠ = 100e-6 # s\nT₂ˢ = 10e-6 # μs\nm0_5D = [0,0,m₀ᶠ,m₀ˢ,1]\nmfun(p, t; idxs=nothing) = typeof(idxs) <: Number ? 0 : m0_5D; # initialize history function, here with the ability to just call a single index\nnothing #hide\n\nThe full generalized Bloch model is solved by\n\nparam = (π/Tʳᶠ, 1, 0, m₀ˢ, R₁, R₂ᶠ, Rₓ, R₁, T₂ˢ, G)\nprob = DDEProblem(apply_hamiltonian_gbloch!, m0_5D, mfun, (0.0, Tʳᶠ), param)\nsol_pi_full = solve(prob, MethodOfSteps(Tsit5()));\nnothing #hide\n\nand we evaluate the interpolated solution at the following time points:\n\nt = (0:.01:1) * Tʳᶠ # s\nMpi_full = zeros(length(t),4)\nfor i in eachindex(t)\n    Mpi_full[i,:] = sol_pi_full(t[i])[1:4]\nend\n\nFurther, we calculate the linear approximation, which is simulated in a 6D-space as it explicitly models x^s:\n\nm0_6D = [0,0,m₀ᶠ,0,m₀ˢ,1]\n\nMpi_appx = similar(Mpi_full)\nfor i in eachindex(t)\n    H = exp(hamiltonian_linear(π/Tʳᶠ, 1, 0, t[i], m₀ˢ, R₁, R₂ᶠ, Rₓ, R₁, R₂ˢˡ(Tʳᶠ, π, 1, T₂ˢ)))\n    Mpi_appx[i,:] = (H * m0_6D)[[1:3;5]]\nend\n\nand plot the original generalized Bloch model and its linear approximation for comparison:\n\np = plot(xlabel=\"t [s]\", ylabel=\"m/m₀\")\nplot!(p, t, Mpi_full[:,1] / m₀ᶠ, label=\"xᶠ/m₀ᶠ original model\")\nplot!(p, t, Mpi_appx[:,1] / m₀ᶠ, label=\"xᶠ/m₀ᶠ linear approximation\")\nplot!(p, t, Mpi_full[:,3] / m₀ᶠ, label=\"zᶠ/m₀ᶠ original model\")\nplot!(p, t, Mpi_appx[:,3] / m₀ᶠ, label=\"zᶠ/m₀ᶠ linear approximation\")\nplot!(p, t, Mpi_full[:,4] / m₀ˢ, label=\"zˢ/m₀ˢ original model\")\nplot!(p, t, Mpi_appx[:,4] / m₀ˢ, label=\"zˢ/m₀ˢ linear approximation\")\nMain.HTMLPlot(p) #hide\n\nWe observe slight deviations of zˢ during the pulse, but a virtually perfect match at the end of the RF pulse.","category":"section"},{"location":"build_literate/Linear_Approximation/#RF-Pulses-with-Different-Flip-Angles","page":"Linear Approximation","title":"RF Pulses with Different Flip Angles","text":"To replicate Fig. 8b, we simulate the spin dynamics during multiple RF pulses with different flip angles α, each simulation starting from thermal equilibrium, and analyze the magnetization at the end of each pulse:\n\nα = (.01:.01:1) * π\n\nM_full = zeros(length(α), 4)\nM_appx = similar(M_full)\nfor i in eachindex(α)\n    param = (α[i]/Tʳᶠ, 1, 0, m₀ˢ, R₁, R₂ᶠ, Rₓ, R₁, T₂ˢ, G)\n    prob = DDEProblem(apply_hamiltonian_gbloch!, m0_5D, mfun, (0.0, Tʳᶠ), param)\n    M_full[i,:] = solve(prob, MethodOfSteps(Tsit5())).u[end][1:4]\n\n    u = exp(hamiltonian_linear(α[i]/Tʳᶠ, 1, 0, Tʳᶠ, m₀ˢ, R₁, R₂ᶠ, Rₓ, R₁, R₂ˢˡ(Tʳᶠ, α[i], 1, T₂ˢ))) * m0_6D\n    M_appx[i,:] = u[[1:3;5]]\nend\n\np = plot(xlabel=\"α/π\", ylabel=\"m/m₀\")\nplot!(p, α/π, M_appx[:,1] / m₀ᶠ, label=\"xᶠ/m₀ˢ original model\")\nplot!(p, α/π, M_full[:,1] / m₀ᶠ, label=\"xᶠ/m₀ˢ linear approximation\")\nplot!(p, α/π, M_appx[:,3] / m₀ᶠ, label=\"zᶠ/m₀ˢ original model\")\nplot!(p, α/π, M_full[:,3] / m₀ᶠ, label=\"zᶠ/m₀ˢ linear approximation\")\nplot!(p, α/π, M_appx[:,4] / m₀ˢ, label=\"zˢ/m₀ˢ original model\")\nplot!(p, α/π, M_full[:,4] / m₀ˢ, label=\"zˢ/m₀ˢ linear approximation\")\nMain.HTMLPlot(p) #hide\n\nVisually, the linear approximation matches the full simulation well. The normalized root-mean-squared error of the linear approximation for x^f is\n\nnorm(M_appx[:,1] .- M_full[:,1]) / norm(M_full[:,1])\n\nfor z^f it is\n\nnorm(M_appx[:,3] .- M_full[:,3]) / norm(M_full[:,3])\n\nand for z^s it is\n\nnorm(M_appx[:,4] .- M_full[:,4]) / norm(M_full[:,4])\n\nwhich confirms the good concordance.","category":"section"},{"location":"build_literate/Linear_Approximation/#Benchmark","page":"Linear Approximation","title":"Benchmark","text":"We analyze the execution time for solving the full integro-differential equation:\n\nparam = (α[end]/Tʳᶠ, 1, 0, m₀ˢ, R₁, R₂ᶠ, Rₓ, R₁, T₂ˢ, G)\nprob = DDEProblem(apply_hamiltonian_gbloch!, m0_5D, mfun, (0.0, Tʳᶠ), param)\n@benchmark solve($prob, $(MethodOfSteps(Tsit5())))\n\nThe $ symbol interpolates the variable, which improves the accuracy of the timing measurement. We can compare this time to the time it takes to calculate the linear approximation, including the time it takes to evaluate the interpolated R₂ˢˡ:\n\n@benchmark exp(hamiltonian_linear($(α[end]/Tʳᶠ), 1, 0, $Tʳᶠ, $m₀ˢ, $R₁, $R₂ᶠ, $Rₓ, $R₁, R₂ˢˡ($Tʳᶠ, $α[end], 1, $T₂ˢ))) * $m0_6D\n\nWe can see that linear approximation is about 4 orders of magnitude faster compared to the full model.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"(Image: )","category":"section"},{"location":"build_literate/tutorial_pulsetrain/#Balanced-Hybrid-State-Free-Precession-Pulse-Sequence","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"This section explains the interface for calculating the spin evolution during a train of RF pulses, assuming balanced gradient moments (cf. Hybrid-state free precession in nuclear magnetic resonance). For this, we need the following packages:\n\nusing MRIgeneralizedBloch\nusing MAT\nusing Plots\nplotlyjs(bg = RGBA(31/255,36/255,36/255,1.0), ticks=:native); #hide\nnothing #hide\n\nand we use the pulse train described in the paper Rapid quantitative magnetization transfer imaging: utilizing the hybrid state and the generalized Bloch model:\n\ncontrol = matread(normpath(joinpath(pathof(MRIgeneralizedBloch), \"../../docs/control_MT_v3p2_TR3p5ms_discretized.mat\")))\nα   = control[\"alpha\"]\nTRF = control[\"TRF\"]\ngrad_moment = [i == 1 ? :crusher : :balanced for i ∈ eachindex(α)];\nnothing #hide\n\nThe vector grad_moment defines the gradient moments for each TR. Further, we define\n\nTR = 3.5e-3; # s\nnothing #hide\n\nThe control has the following shape:\n\nt = TR .* (1:length(TRF))\np1 = plot(t, α/π, ylabel=\"α/π\", label=:none)\np2 = plot(t, TRF, xlabel=\"t (s)\", ylabel=\"TRF (s)\", label=:none)\np = plot(p1, p2, layout=(2,1))\nMain.HTMLPlot(p) #hide\n\nWe simulate the signal for the following biophysical parameters:\n\nm0s = 0.15\nR1f = 0.5   # 1/s\nR2f = 15    # 1/s\nRex = 30    # 1/s\nR1s = 3     # 1/s\nT2s = 10e-6 # s\nω0 = 0      # rad/s\nB1 = 1;     # in units of B1_nominal\nnothing #hide\n\nFor speed purposes, it is advisable to use the linear approximation of the generalized Bloch model, which requires a precomputed R_2^sl\n\nR2slT = precompute_R2sl();\nnothing #hide\n\nNow we have everything set up to calculate the signal:\n\ns_linapp = calculatesignal_linearapprox(α, TRF, TR, ω0, B1, m0s, R1f, R2f, Rex, R1s, T2s, R2slT; grad_moment)\n\nBy default, the output is a complex valued array where each element describes the transversal magnetization x^f + i y^f of the free spin pool in each T_textR. With ω_0 = 0, however, the imaginary part of the signal vanishes:\n\np = plot(xlabel=\"t (s)\", ylabel=\"signal (normalized)\"; legend=:topleft)\nplot!(p, t, real.(vec(s_linapp)), label=\"Re(s); lin. approx.\")\nplot!(p, t, imag.(vec(s_linapp)), label=\"Im(s); lin. approx.\")\nMain.HTMLPlot(p) #hide\n\nFor comparison, we can also solve the full integro-differential equation (IDE) for each RF pulse, which is more accurate, but much slower:\n\ns_ide = calculatesignal_gbloch_ide(α, TRF, TR, ω0, B1, m0s, R1f, R2f, Rex, R1s, T2s)\n\nplot!(p, t, real.(vec(s_ide)), label=\"Re(s); IDE\")\nplot!(p, t, imag.(vec(s_ide)), label=\"Im(s); IDE\")\nMain.HTMLPlot(p) #hide\n\nClicking on the legend entries allows to select and de-select individual graphs.","category":"section"},{"location":"build_literate/tutorial_pulsetrain/#Real-valued-magnetization-vector","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Real-valued magnetization vector","text":"As an alternative to the complex-valued signal, we can also calculate the full magnetization vector (x^f y^f z^f x^s z^s 1) by supplying the keyword argument output=:realmagnetization. Here, x, y, z denote the dimensions in space, the superscripts f and s denote the free and the semi-solid spin pool, respectively. We neglect the y^s component, assuming (without loss of generality) ωₓ = 0 and given that R_2^sl gg ω_0.\n\nm_linapp = calculatesignal_linearapprox(α, TRF, TR, ω0, B1, m0s, R1f, R2f, Rex, R1s, T2s, R2slT;\n    output=:realmagnetization, grad_moment)\n\np = plot(xlabel=\"t (s)\", ylabel=\"magnetization (normalized)\"; legend=:topleft)\nplot!(p, t, [m_linapp[i][1] for i ∈ axes(m_linapp,1)] ./ (1 - m0s), label=\"xᶠ / m₀ᶠ\")\nplot!(p, t, [m_linapp[i][2] for i ∈ axes(m_linapp,1)] ./ (1 - m0s), label=\"yᶠ / m₀ᶠ\")\nplot!(p, t, [m_linapp[i][3] for i ∈ axes(m_linapp,1)] ./ (1 - m0s), label=\"zᶠ / m₀ᶠ\")\nplot!(p, t, [m_linapp[i][4] for i ∈ axes(m_linapp,1)] ./      m0s , label=\"xˢ / m₀ˢ\")\nplot!(p, t, [m_linapp[i][5] for i ∈ axes(m_linapp,1)] ./      m0s , label=\"zˢ / m₀ˢ\")\nMain.HTMLPlot(p) #hide","category":"section"},{"location":"build_literate/tutorial_pulsetrain/#Gradients","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Gradients","text":"The same interface can also be used to calculate the derivatives of the signal wrt. the biophysical parameters. One can specify any subset of derivatives in any order with a vector of identifier objects:\n\ngrad_list = (grad_m0s(), grad_R1f(), grad_R2f(), grad_Rex(), grad_R1s(), grad_T2s(), grad_ω0(), grad_B1());\nnothing #hide\n\nCalling the function calculatesignal_linearapprox with the keyword argument grad_list and this vector\n\ns_linapp = calculatesignal_linearapprox(α, TRF, TR, ω0, B1, m0s, R1f, R2f, Rex, R1s, T2s, R2slT; grad_list, grad_moment);\nnothing #hide\n\nreturns the derivatives in the specified order:\n\np = plot(xlabel=\"t (s)\", ylabel=\"signal (normalized)\"; legend=:topleft)\nplot!(p, t, real.(s_linapp[:,1,1]       ), label=\"Re(∂s/∂M₀ )*M₀\")\nplot!(p, t, real.(s_linapp[:,1,2] .* m0s), label=\"Re(∂s/∂m₀ˢ)*m₀ˢ\")\nplot!(p, t, real.(s_linapp[:,1,3] .* R1f), label=\"Re(∂s/∂R₁ᶠ)*R₁ᶠ\")\nplot!(p, t, real.(s_linapp[:,1,4] .* R2f), label=\"Re(∂s/∂R₂ᶠ)*R₂ᶠ\")\nplot!(p, t, real.(s_linapp[:,1,5] .* Rex), label=\"Re(∂s/∂Rₓ )*Rₓ \")\nplot!(p, t, real.(s_linapp[:,1,6] .* R1s), label=\"Re(∂s/∂R₁ˢ)*R₁ˢ\")\nplot!(p, t, real.(s_linapp[:,1,7] .* T2s), label=\"Re(∂s/∂T₂ˢ)*T₂ˢ\")\nplot!(p, t, real.(s_linapp[:,1,8] .* ω0 ), label=\"Re(∂s/∂ω₀ )*ω₀ \")\nplot!(p, t, real.(s_linapp[:,1,9] .* B1 ), label=\"Re(∂s/∂B₁ )*B₁ \")\nMain.HTMLPlot(p) #hide\n\nNote that the first row is always the signal itself, which is equivalent to ∂s/∂M₀, as this toolbox always assumes M₀ = 1.","category":"section"},{"location":"build_literate/tutorial_pulsetrain/#Apparent-R","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Apparent R₁","text":"Above code calculates separate derivatives for R_1^f and R_1^s. Yet, many publications, including our own paper \"Rapid quantitative magnetization transfer imaging: utilizing the hybrid state and the generalized Bloch model\" assumes an apparent longitudinal relaxation rate R_1^a = R_1^f = R_1^f. The derivatives wrt. this apparent relaxation rate can be calculated with\n\nR1a = 1 # 1/s\ngrad_list = (grad_R1a(),)\ns_linapp = calculatesignal_linearapprox(α, TRF, TR, ω0, B1, m0s, R1a, R2f, Rex, R1a, T2s, R2slT; grad_list, grad_moment)\n\np = plot(xlabel=\"t (s)\", ylabel=\"signal (normalized)\"; legend=:topleft)\nplot!(p, t, real.(s_linapp[:,1,1]       ), label=\"Re(∂s/∂M₀)/M₀\")\nplot!(p, t, real.(s_linapp[:,1,2] .* R1a), label=\"Re(∂s/∂R₁ᵃ)*R₁ᵃ\")\nMain.HTMLPlot(p) #hide\n\nNote that R1a appears here twice in the arguments of the calculatesignal_linearapprox in place of R1f and R1s.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"(Image: )","category":"section"},{"location":"build_literate/Greens_functions/#Green's-Functions","page":"Green's Functions","title":"Green's Functions","text":"The Green's functions are given by the Fourier transform of the corresponding lineshapes. For a Lorentzian lineshape, the Green's function is\n\n\tG(ttau) = exp (-R_2^s (t-tau))  forall  t geq tau\n\nfor a Gaussian lineshape it is\n\n\tG(ttau) = exp(- R_2^s^2 (t-tau)^2  2))\n\nand for super-Lorentzian lineshape it is\n\n\tG(ttau) = int_0^1 exp left(- R_2^s^2 (t - tau)^2 cdot  frac(3 zeta^2 - 1)^28 right) dzeta\n\nAs evident from these equations, the Green's functions are merely a function of kappa = R_2^s cdot (t - tau) = (t - tau)  T_2^s, and in this package we implemented the functions as such: greens_lorentzian(κ), greens_gaussian(κ), and greens_superlorentzian(κ). These functions can be used to reproduce Fig. 1 in the generalized Bloch paper:\n\nusing MRIgeneralizedBloch\nusing Plots\nplotlyjs(bg = RGBA(31/255,36/255,36/255,1.0), ticks=:native); #hide\nnothing #hide\n\nT₂ˢ = 10e-6 # s\nt = 0 : 1e-6 : 1e-3\np = plot(yaxis=:log, ylim=(1e-6,1), xlabel=\"(t-τ) [ms]\", ylabel=\"G((t-τ)/T₂ˢ)\")\nplot!(p, 1e3t, greens_lorentzian.(t ./ T₂ˢ), label=\"Lorentzian lineshape\")\nplot!(p, 1e3t, greens_gaussian.(t ./ T₂ˢ), label=\"Gaussian lineshape\")\nplot!(p, 1e3t, greens_superlorentzian.(t ./ T₂ˢ), label=\"super-Lorentzian l.\")\nMain.HTMLPlot(p) #hide\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"(Image: )","category":"section"},{"location":"build_literate/tutorial_singlepulse/#Simulation-of-a-Single-RF-Pulse","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"The core of generalized Bloch model is implemented in the function apply_hamiltonian_gbloch!(∂m∂t, m, mfun, p, t), which calculates the derivative ∂m/∂t for a given magnetization vector m and stores it in-place in the variable ∂m∂t. The function interface is written in a format that can be fed directly into a differential equation solver of the DifferentialEquations.jl package.\n\nWe need the following packages for this tutorial:\n\nusing MRIgeneralizedBloch\nusing DifferentialEquations\nusing SpecialFunctions\nusing QuadGK\nusing Plots\nplotlyjs(bg = RGBA(31/255,36/255,36/255,1.0), ticks=:native); #hide\nnothing #hide\n\nand we define the properties of a coupled spin system:\n\nm0s = 0.15\nR1f = 0.5 # 1/s\nR2f = 13 # 1/s\nR1s = 3 # 1/s\nT2s = 12e-6 # s\nRex = 17; # 1/s\nnothing #hide\n\nFor most parts of this tutorial, we assume a perfectly calibrated, on-resonant RF-pulse:\n\nB1 = 1\nω0 = 0; # rad/s\nnothing #hide\n\nas well as a super-Lorentzian lineshape. We interpolate the corresponding Green's function in the range TRF ∈ [0, 1000 ⋅ T2s] to improve performance:\n\nG = interpolate_greens_function(greens_superlorentzian, 0, 1000);\nnothing #hide","category":"section"},{"location":"build_literate/tutorial_singlepulse/#Rectangular-RF-Pulses","page":"Simulation of a Single RF Pulse","title":"Rectangular RF-Pulses","text":"First, we simulate a rectangular RF-pulse with a constant ω1:\n\nα = π # rad\nTRF = 500e-6 # s\nω1 = α/TRF # rad/s","category":"section"},{"location":"build_literate/tutorial_singlepulse/#Isolated-Semi-Solid-Spin-Pool","page":"Simulation of a Single RF Pulse","title":"Isolated Semi-Solid Spin Pool","text":"The first example demonstrates how to simulate an isolated semi-solid spin pool for which the magnetization vector is defined by m = [zs; 1]. The appended 1 facilitates a more compact implementation of longitudinal relaxation to a non-zero thermal equilibrium. Here, we initialize the magnetization with the thermal equilibrium:\n\nm0 = [1; 1];\nnothing #hide\n\nThe generalized Bloch model is a so-called integro-differential equation where the derivative mt at the time t_1 does not just depend on m(t_1), but on m(t) with t in 0 t_1. This is solved with a delay differential equation (DDE) solver that stores an interpolated history function mfun(p, t), which we use in the apply_hamiltonian_gbloch! function to evaluate the integral. This history function has to be initialized with\n\nmfun(p, t) = m0;\nnothing #hide\n\nFor slight performance improvements, we could also initialize the history function with mfun(p, t; idxs=nothing) = typeof(idxs) <: Number ? m0[idxs] : m0. This syntax allows for direct indexing of the history function in apply_hamiltonian_gbloch!, which improves performance. Following the syntax of the DifferentialEquations.jl package, we can define and solve the differential equation:\n\nparam = (ω1, B1, ω0, R1s, T2s, G) # defined by apply_hamiltonian_gbloch!\nprob = DDEProblem(apply_hamiltonian_gbloch!, m0, mfun, (0, TRF), param)\nz_gBloch = solve(prob, MethodOfSteps(Tsit5()))\n\nThe function apply_hamiltonian_gbloch! is implemented such that it infers from param = (ω1, B1, ω0, R1s, T2s, G) that you are only supplying the relaxation properties of the semi-solid spin pool and hence it simulates the spin dynamics of an isolated semi-solid spin pool. The DifferentialEquations.jl package also implements a plot function for the solution object, which can be used to display the result:\n\np = plot(z_gBloch, xlabel=\"t [s]\", ylabel=\"zˢ(t)\", idxs=1, label=\"g. Bloch\")\nMain.HTMLPlot(p) #hide\n\nFor comparison, we can simulate the signal with Graham's spectral model, which describes an exponential saturation with the rate\n\nf_ω1(t) = ω1\nRʳᶠ = graham_saturation_rate_spectral(ω0 -> lineshape_superlorentzian(ω0, T2s), f_ω1, TRF, ω0) # 1/s\n\nThe function graham_saturation_rate_spectral calculates the spectral power density S(ω₀,Δω,ω₁(t)) of the RF-pulse with an off-resonance frequency Δω and a pulse shape ω₁(t). The spectral power density is the squared absolute value of the pulse's Fourier transform, divided by the pulse duration. Thereafter, the function calculates the integral\n\nRʳᶠ = int_-^+ dω₀ S(ω₀Δωω₁(t)) g(ω₀ T₂ˢ) \n\nwhere g(ω₀, T₂ˢ) is the spectral lineshape of the spin pool. Given this saturation rate, we can simply solve the ordinary differential equation ∂z/∂t = R₁ (1 - z) - Rʳᶠ z, which has the following analytical solution:\n\nz_Graham(t) = (Rʳᶠ * exp(-t * (R1s + Rʳᶠ)) + R1s) / (R1s + Rʳᶠ)\nplot!(p, z_Graham, 0, TRF, label=\"Graham\")\nMain.HTMLPlot(p) #hide\n\nThis plot reveals a substantial difference between Graham's spectral model and the generalized Bloch model at the example of a 500μs inversion pulse, as, e.g., used in our in vivo experiments. This also entails a substantial difference in the z-magnetization of the semi-solid spin pool at the end of the RF-pulse:\n\nz_gBloch(TRF)[1]\n\nz_Graham(TRF)","category":"section"},{"location":"build_literate/tutorial_singlepulse/#Coupled-Spin-System","page":"Simulation of a Single RF Pulse","title":"Coupled Spin System","text":"For a coupled spin system, the magnetization vector is defined as m = [xf; yf; zf; zs; 1] and the thermal equilibrium magnetization is given by:\n\nm0 = [0; 0; 1-m0s; m0s; 1];\nnothing #hide\n\nTo indicate to the apply_hamiltonian_gbloch! function that we would like to simulate a coupled spin system, we simple provide it with the properties of both pools in the following format:\n\nparam = (ω1, B1, ω0, m0s, R1f, R2f, Rex, R1s, T2s, G);\nnothing #hide\n\nThereafter, we can use the same function calls as above to simulate the spin dynamics:\n\nprob = DDEProblem(apply_hamiltonian_gbloch!, m0, mfun, (0, TRF), param)\nm_gBloch = solve(prob, MethodOfSteps(Tsit5()))\np = plot(m_gBloch, xlabel=\"t [s]\", ylabel=\"m(t)\", idxs=1:4, labels=[\"xᶠ\" \"yᶠ\" \"zᶠ\" \"zˢ\"])\nMain.HTMLPlot(p) #hide","category":"section"},{"location":"build_literate/tutorial_singlepulse/#Shaped-RF-Pulses","page":"Simulation of a Single RF Pulse","title":"Shaped RF-Pulses","text":"The function apply_hamiltonian_gbloch! also allows for the simulation of RF-pulses with arbitrary shapes. To this end, ω₁(t) has to be defined as a function that takes time in seconds as an input and returns ω₁ at this particular point in time. For example, we can define a 1ms sinc-pulse:\n\nTRF = 1e-3 # s\nNSideLobes = 1\nf_ω1(t) = sinc(2(NSideLobes+1) * t/TRF - (NSideLobes+1)) * α / (sinint((NSideLobes+1)π) * TRF/π / (NSideLobes+1))\np = plot(f_ω1, 0, TRF, xlabel=\"t [s]\", ylabel=\"ω₁(t)\", labels=:none)\nMain.HTMLPlot(p) #hide\n\nNSideLobes defines here the number of side lobes on each side as can be seen in the plot. With numerical integration we can check if the RF-pulse has the correct flip angle:\n\nquadgk(f_ω1, 0, TRF)[1] / α","category":"section"},{"location":"build_literate/tutorial_singlepulse/#Isolated-Semi-Solid-Spin-Pool-2","page":"Simulation of a Single RF Pulse","title":"Isolated Semi-Solid Spin Pool","text":"In order to calculate the spin dynamics of an isolated semi-solid spin pool during this shaped RF-pulse, we define the same tuple param as we did in Section Rectangular RF-Pulses with the only difference that the first element is a subtype of the abstract type Function:\n\nparam = (f_ω1, B1, ω0, R1s, T2s, G)\ntypeof(f_ω1) <: Function\n\nWith this definition of param, we can use the same function call as we did before:\n\nm0 = [1; 1]\nprob = DDEProblem(apply_hamiltonian_gbloch!, m0, mfun, (0, TRF), param)\nz_gBloch = solve(prob, MethodOfSteps(Tsit5()))\np = plot(z_gBloch, xlabel=\"t [s]\", ylabel=\"zˢ(t)\", idxs=1, label=\"g. Bloch\")\nMain.HTMLPlot(p) #hide\n\nFor comparison, we can simulate the signal with Graham's spectral model, which describes an exponential saturation with the rate\n\nRʳᶠ = graham_saturation_rate_spectral(ω0 -> lineshape_superlorentzian(ω0, T2s), f_ω1, TRF, ω0)\n\nz_Graham(t) = (Rʳᶠ * exp(-t * (R1s + Rʳᶠ)) + R1s) / (R1s + Rʳᶠ)\nplot!(p, z_Graham, 0, TRF, label=\"Graham\")\nMain.HTMLPlot(p) #hide\n\nz_gBloch(TRF)[1]\n\nz_Graham(TRF)\n\nThe difference between Graham's model and the generalized Bloch model is more pronounced for this 1ms sinc-inversion pulse compared to the 500μs rectangular inversion pulse. We note, however, that the peak pulse amplitude of the sinc-pulse is higher and potentially too high clinical MRI systems.","category":"section"},{"location":"build_literate/tutorial_singlepulse/#Coupled-Spin-System-2","page":"Simulation of a Single RF Pulse","title":"Coupled Spin System","text":"We can perform the same change to param to simulate a coupled spin system:\n\nparam = (f_ω1, B1, ω0, m0s, R1f, R2f, Rex, R1s, T2s, G)\nm0 = [0; 0; 1-m0s; m0s; 1]\nprob = DDEProblem(apply_hamiltonian_gbloch!, m0, mfun, (0, TRF), param)\nm_gBloch = solve(prob, MethodOfSteps(Tsit5()))\np = plot(m_gBloch, xlabel=\"t [s]\", ylabel=\"m(t)\", idxs=1:4, labels=[\"xᶠ\" \"yᶠ\" \"zᶠ\" \"zˢ\"])\nMain.HTMLPlot(p) #hide\n\nDouble click on zˢ in the legend to isolate the semi-solid spin pool in the plot and compare the simulation to the last section.","category":"section"},{"location":"build_literate/tutorial_singlepulse/#ω-Sweep-or-Adiabatic-RF-Pulses","page":"Simulation of a Single RF Pulse","title":"ω₀-Sweep or Adiabatic RF-Pulses","text":"The apply_hamiltonian_gbloch!(∂m∂t, m, mfun, p, t) function is also implemented for RF-pulses with a varying RF frequency ω₀(t) as, e.g., used in adiabatic pulses. In order to simulate such pulses, the first element of param has to be ω₁(t)::Function like for Shaped RF-Pulses and, additionally, the third element has to be φ::Function instead of ω₀::Number. Notice two differences here: first, the (abstract) type Function instead of Number will tell the compiler to use the adiabatic-pulse implementation. Second, this implementation requires the phase of the RF-pulse as function of time φ(t) instead of the frequency because φ(t) ≠ ω₀(t) ⋅ t, if ω₀ is a function of time.\n\nTo demonstrate the interface at a practical example, we can defined a hyperbolic secant adiabatic inversion pulse:\n\nTRF = 10.24e-3 # s\nγ = 267.522e6 # gyromagnetic ratio in rad/s/T\nω₁ᵐᵃˣ = 13e-6 * γ # rad/s\nμ = 5 # shape parameter in rad\nβ = 674.1 # shape parameter in 1/s\n\nf_ω1(t) = ω₁ᵐᵃˣ * sech(β * (t - TRF/2)) # rad/s\nf_ω0(t) = -μ * β * tanh(β * (t - TRF/2)) # rad/s\nf_φ(t)  = -μ * log(cosh(β * t) - sinh(β*t) * tanh(β*TRF/2)); # rad\nnothing #hide\n\nFor this example, we analytically solved the integral φ(t) = int_0^t ω₀(τ) dτ.\n\nThis pulse a hyperbolic secant amplitude:\n\np = plot(f_ω1, 0, TRF, xlabel=\"t [s]\", ylabel=\"ω₁(t) [rad/s]\", labels=:none)\nMain.HTMLPlot(p) #hide\n\nand hyperbolic tangent frequency sweep\n\np = plot(f_ω0, 0, TRF, xlabel=\"t [s]\", ylabel=\"ω₀(t) [rad/s]\", labels=:none)\nMain.HTMLPlot(p) #hide\n\nAs explained above, we actually don't use the frequency in the implementation. Instead, we use the RF-phase:\n\np = plot(f_φ, 0, TRF, xlabel=\"t [s]\", ylabel=\"φ(t) [rad]\", labels=:none)\nMain.HTMLPlot(p) #hide\n\nThis interface, of course, also allows for the simulation of an isolated semi-solid spin pool with above described modifications to param. For brevity, however, we here directly simulate a coupled spin pool starting from thermal equilibrium:\n\nm0 = [0, 0, 1-m0s, m0s, 1]\np = (f_ω1, B1, f_φ, m0s, R1f, R2f, Rex, R1s, T2s, G)\nm_gBloch = solve(DDEProblem(apply_hamiltonian_gbloch!, m0, mfun, (0, TRF), p), MethodOfSteps(Tsit5()))\np = plot(m_gBloch, xlabel=\"t [s]\", ylabel=\"m(t)\", idxs=1:4, labels=[\"xᶠ\" \"yᶠ\" \"zᶠ\" \"zˢ\"])\nMain.HTMLPlot(p) #hide\n\nThis simulation shows the intended inversion of the free spin pool and a near complete saturation of the semi-solid spin pool (double click on the corresponding legend entry). The transversal magnetization of the free pool exhibits some oscillations and at this point I should highlight a distinct difference between the implementation for adiabatic RF-pulses the above described implementation for constant ω₀: the latter case uses a frame of references that rotates with the RF-frequency about the z-axis, i.e. the RF-pulses rotate the magnetization  with ω₁ about the y-axis and, additionally, the magnetizations rotates with ω₀ about the z-axis. The implementation of the adiabatic pulses uses a rotating frame of reference that is on resonance with the Larmor frequency of the spin isochromat and the phase of the RF-pulse rotates with ω₀(t). To simulate off-resonance, we can simply add a static value to above function or, more precisely, add a phase slope to φ:\n\nΔω0 = 1000 # rad/s\nf_φ_or(t) = f_φ(t) + Δω0 * t; # rad\nnothing #hide\n\nWe can, additionally, change B1 to demonstrate the robustness of adiabatic pulses:\n\nB1 = 1.2 # 20% miss-calibration\np = (f_ω1, B1, f_φ_or, m0s, R1f, R2f, Rex, R1s, T2s, G)\nm_gBloch = solve(DDEProblem(apply_hamiltonian_gbloch!, m0, mfun, (0, TRF), p), MethodOfSteps(Tsit5()))\np = plot(m_gBloch, xlabel=\"t [s]\", ylabel=\"m(t)\", idxs=1:4, labels=[\"xᶠ\" \"yᶠ\" \"zᶠ\" \"zˢ\"])\nMain.HTMLPlot(p) #hide\n\nWhile the spin dynamics during the pulse is changed, the final magnetization of the free pool is approximately the same compared to the on-resonant isochromat with B1 = 1. The final magnetization of the semi-solid spin pool is, like before, close to zero, but a close look reveals a small negative zˢ-magnetization (double click on zˢ in the plot's legend). The difference to the previous simulation highlights that the dynamics of semi-solid spin pool is not adiabatic and does depend on B₁.","category":"section"},{"location":"build_literate/tutorial_singlepulse/#Transversal-Magnetization-of-the-Semi-Solid-Spin-Pool","page":"Simulation of a Single RF Pulse","title":"Transversal Magnetization of the Semi-Solid Spin Pool","text":"Throughout this tutorial, we only ever calculated and plotted the longitudinal magnetization of the semi-solid spin pool. This is foremost a result of way we formulate and solve the generalized Bloch equations (cf. Eq. (9) in the paper). But this implementation is also reflective of the standard use-case in magnetization transfer imaging, where we are foremost interested in the longitudinal magnetization of the semi-solid spin pool and its effect on the free spin pool. If required, however, it is easily possible to calculate the transversal magnetization with Eqs. (4-5) from the paper:\n\nωx(t) = -B1 * f_ω1(t) * sin(f_φ_or(t))\nωy(t) =  B1 * f_ω1(t) * cos(f_φ_or(t))\nzs_gBloch(t) = m_gBloch(t)[4]\nxs_gBloch(t) = quadgk(τ -> G((t - τ) / T2s) * ωx(τ) * zs_gBloch(τ), 0, t)[1]\nys_gBloch(t) = quadgk(τ -> G((t - τ) / T2s) * ωy(τ) * zs_gBloch(τ), 0, t)[1];\nnothing #hide\n\nThe last two lines calculate the numerical integral of the Green's function multiplied by the oscillating RF-fields. Similar code is also used in the implementation of apply_hamiltonian_gbloch!. Plotting these functions reveals the spin dynamics of the semi-solid spin pool:\n\np = plot(xs_gBloch, 0, TRF, xlabel=\"t [s]\", ylabel=\"m(t)\", label=\"xˢ\")\nplot!(p, ys_gBloch, 0, TRF, label=\"yˢ\")\nplot!(p, zs_gBloch, 0, TRF, label=\"zˢ\")\nMain.HTMLPlot(p) #hide\n\nMore details about the interface, including the linear approximation of the generalized Bloch model can found in the following scripts that replicate all simulations, data analyses, and figures of the generalized Bloch paper.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"(Image: )","category":"section"},{"location":"build_literate/Simulation_Pulse/#RF-Pulse-Simulation","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"The following code replicates the RF-pulse simulation of Fig. 3 and plots the z^s-magnetization at the end of respective pulse.\n\nFor these simulations we need the following packages:\n\nusing MRIgeneralizedBloch\nusing QuadGK\nusing DifferentialEquations\nusing SpecialFunctions\nusing Plots\nplotlyjs(bg = RGBA(31/255,36/255,36/255,1.0), ticks=:native); #hide\nnothing #hide\n\nand we simulate an isolated semi-solid spin pool with the following parameters:\n\nR₁ = 1 # 1/s\nT₂ˢ = 10e-6; # s\nnothing #hide\n\nHere, we simulate π-pulses with the following parameters:\n\nα = π\nTʳᶠ = exp.(range(log(2e-7), log(1e-1), length=100)) # s\nω₁ = α ./ Tʳᶠ # rad/s\nω₀ = 0; # rad/s\nnothing #hide\n\nReplace first line with α = π/4 or α = π/2 to simulate the other two rows of Fig. 3.","category":"section"},{"location":"build_literate/Simulation_Pulse/#Lorentzian-Lineshape","page":"RF-Pulse Simulation","title":"Lorentzian Lineshape","text":"In this script, we simulate the three lineshapes separately, starting with the Lorentzian lineshape for which the Bloch model provides a ground truth.","category":"section"},{"location":"build_literate/Simulation_Pulse/#Bloch-Model","page":"RF-Pulse Simulation","title":"Bloch Model","text":"We can formulate the Bloch model as\n\npartial_t beginpmatrix x  y  z  1 endpmatrix = beginpmatrix\n-R_2  -ω_0  ω_1  0 \nω_0  -R_2  0  0 \n-ω_1  0  -R_1  R_1 \n0  0  0  0\nendpmatrix beginpmatrix x  y  z  1 endpmatrix \n\nwhere the matrix is the Hamiltonian of the Bloch model. For a constant ω_0 and ω_1, we can evaluate the Bloch model by taking the  matrix exponential of its Hamiltonian:\n\nH(ω₁, ω₀, R₂, R₁) = [-R₂ -ω₀  ω₁  0;\n                      ω₀ -R₂   0  0;\n                     -ω₁   0 -R₁ R₁;\n                       0   0   0  0]\n\nz_Bloch = similar(Tʳᶠ)\nfor i ∈ eachindex(Tʳᶠ)\n    (_, _, z_Bloch[i], _)  = exp(H(ω₁[i], ω₀, 1 / T₂ˢ, R₁) * Tʳᶠ[i]) * [0; 0; 1; 1]\nend","category":"section"},{"location":"build_literate/Simulation_Pulse/#Graham's-Spectral-Model","page":"RF-Pulse Simulation","title":"Graham's Spectral Model","text":"Graham's spectral model is derived by integrating over the lineshape multiplied by the spectral response function of the RF-pulse. This results in the RF-induced saturation rate Rʳᶠ that is used in an exponential model:\n\nRʳᶠ = @. ω₁^2 * T₂ˢ * ((exp(-Tʳᶠ / T₂ˢ) -1) * T₂ˢ + Tʳᶠ) / Tʳᶠ\nz_Graham_spec_Lorentzian = @. (Rʳᶠ * exp(-Tʳᶠ * (R₁ + Rʳᶠ)) + R₁) / (R₁ + Rʳᶠ);\nnothing #hide","category":"section"},{"location":"build_literate/Simulation_Pulse/#Graham's-Single-Frequency-Approximation","page":"RF-Pulse Simulation","title":"Graham's Single Frequency Approximation","text":"In the single frequency approximation, Graham assumes that the RF-pulse has only a single frequency, which reduces Rʳᶠ to\n\ng_Lorentzian(ω₀) = T₂ˢ / π ./ (1 .+ (T₂ˢ .* ω₀).^2)\nRʳᶠ = @. π * ω₁^2 * g_Lorentzian(ω₀)\nz_Graham_SF_approx_Lorentzian = @. (Rʳᶠ * exp(-Tʳᶠ * (R₁ + Rʳᶠ)) + R₁) / (R₁ + Rʳᶠ);\nnothing #hide\n\nwhere g_Lorentzian(ω₀) denotes the Lorentzian lineshape.","category":"section"},{"location":"build_literate/Simulation_Pulse/#Sled's-Model","page":"RF-Pulse Simulation","title":"Sled's Model","text":"Sled's model is given by the ordinary differential equation (ODE)\n\npartial_t z(t) = left(-pi int_0^t G(t-τ) omega_1(τ)^2 dτ right) z(t)  + R_1 (1-z)\n\nwhere G(t-τ) is the Green's function. The Hamiltonian of this ODE is implemented in apply_hamiltonian_sled! and the ODE can be solved with the DifferentialEquations.jl package:\n\nz₀ = [1.0, 1.0] # initial z-magnetization\nz_Sled_Lorentzian = similar(Tʳᶠ)\nfor i ∈ eachindex(Tʳᶠ)\n    param = (ω₁[i], 1, ω₀, R₁, T₂ˢ, greens_lorentzian)\n    prob = ODEProblem(apply_hamiltonian_sled!, z₀, (0, Tʳᶠ[i]), param)\n    z_Sled_Lorentzian[i] = solve(prob).u[end][1]\nend","category":"section"},{"location":"build_literate/Simulation_Pulse/#Generalized-Bloch-Model","page":"RF-Pulse Simulation","title":"Generalized Bloch Model","text":"The generalized Bloch model is given by the integro-differential equation (IDE)\n\npartial_t z(t) = - ω_1(t) int_0^t G(tτ) ω_1(τ) z(τ) dτ + R_1 (1 - z(t)) \n\nor by\n\npartial_t z(t) = - ω_y(t) int_0^t G(tτ) ω_y(τ) z(τ) dτ - ω_x(t) int_0^t G(tτ) ω_x(τ) z(τ) dτ + R_1 (1 - z(t)) \n\nfor off-resonant RF-pulses with ω_1 = ω_x + i ω_y. The Hamiltonian of the IDE is implemented in apply_hamiltonian_gbloch! and we can solve this IDE with the delay-differential equation (DDE) solver of the DifferentialEquations.jl package:\n\nz_fun(p, t) = [1.0, 1.0]; # initialize history function (will be populated with an interpolation by the DDE solver)\n\nz_gBloch_Lorentzian = similar(Tʳᶠ)\nfor i ∈ eachindex(Tʳᶠ)\n    param = (ω₁[i], 1, ω₀, R₁, T₂ˢ, greens_lorentzian)\n    prob = DDEProblem(apply_hamiltonian_gbloch!, z₀, z_fun, (0, Tʳᶠ[i]), param)\n    z_gBloch_Lorentzian[i] = solve(prob, MethodOfSteps(Tsit5())).u[end][1]\nend\n\nNow we have solved all five models and can plot the solutions for comparison:\n\np = plot(xaxis=:log, legend=:bottomright, xlabel=\"Tʳᶠ [s]\", ylabel=\"zˢ(Tʳᶠ)\")\nplot!(p, Tʳᶠ, z_gBloch_Lorentzian, label=\"generalized Bloch model\")\nplot!(p, Tʳᶠ, Tʳᶠ .* 0 .+ cos(α), label=\"cos(α)\")\nplot!(p, Tʳᶠ, z_Sled_Lorentzian, label=\"Sled's model\")\nplot!(p, Tʳᶠ, z_Graham_spec_Lorentzian, label=\"Graham's spectral model\")\nplot!(p, Tʳᶠ, z_Graham_SF_approx_Lorentzian, label=\"Graham's single frequency approximation\")\nplot!(p, Tʳᶠ, z_Bloch, label=\"Bloch model\")\nMain.HTMLPlot(p) #hide","category":"section"},{"location":"build_literate/Simulation_Pulse/#Gaussian-Lineshape","page":"RF-Pulse Simulation","title":"Gaussian Lineshape","text":"We can repeat these simulations (with the exception of the Bloch model) for the Gaussian lineshape:\n\nRʳᶠ = @. ω₁^2 * T₂ˢ * (2 * T₂ˢ * (exp(-(Tʳᶠ/T₂ˢ)^2/2)-1) + sqrt(2π) * Tʳᶠ * erf(Tʳᶠ/T₂ˢ/sqrt(2))) / (2 * Tʳᶠ)\nz_Graham_spec_Gaussian = @. (Rʳᶠ * exp(-Tʳᶠ * (R₁ + Rʳᶠ)) + R₁) / (R₁ + Rʳᶠ)\n\ng_Gaussian(ω₀) = T₂ˢ / sqrt(2π) * exp(-(T₂ˢ * ω₀)^2 / 2) # lineshape\nRʳᶠ = @. π * ω₁^2 * g_Gaussian(ω₀)\nz_Graham_SF_approx_Gaussian = @. (Rʳᶠ * exp(-Tʳᶠ * (R₁ + Rʳᶠ)) + R₁) / (R₁ + Rʳᶠ)\n\nz_Sled_Gaussian = similar(Tʳᶠ)\nfor i ∈ eachindex(Tʳᶠ)\n    param = (ω₁[i], 1, ω₀, R₁, T₂ˢ, greens_gaussian)\n    prob = ODEProblem(apply_hamiltonian_sled!, z₀, (0, Tʳᶠ[i]), param)\n    z_Sled_Gaussian[i] = solve(prob).u[end][1]\nend\n\nz_gBloch_Gaussian = similar(Tʳᶠ)\nfor i ∈ eachindex(Tʳᶠ)\n    param = (ω₁[i], 1, ω₀, R₁, T₂ˢ, greens_gaussian)\n    prob = DDEProblem(apply_hamiltonian_gbloch!, z₀, z_fun, (0, Tʳᶠ[i]), param)\n    z_gBloch_Gaussian[i] = solve(prob, MethodOfSteps(Tsit5())).u[end][1]\nend\n\np = plot(xaxis=:log, legend=:bottomright, xlabel=\"Tʳᶠ [s]\", ylabel=\"zˢ(Tʳᶠ)\")\nplot!(p, Tʳᶠ, z_gBloch_Gaussian, label=\"generalized Bloch model\")\nplot!(p, Tʳᶠ, Tʳᶠ .* 0 .+ cos(α), label=\"cos(α)\")\nplot!(p, Tʳᶠ, z_Sled_Gaussian, label=\"Sled's model\")\nplot!(p, Tʳᶠ, z_Graham_spec_Gaussian, label=\"Graham's spectral model\")\nplot!(p, Tʳᶠ, z_Graham_SF_approx_Gaussian, label=\"Graham's single frequency approximation\")\nMain.HTMLPlot(p) #hide","category":"section"},{"location":"build_literate/Simulation_Pulse/#Super-Lorentzian-Lineshape","page":"RF-Pulse Simulation","title":"Super-Lorentzian Lineshape","text":"Further, we can repeat these simulations for the super-Lorentzian lineshape with the exception of Graham's single frequency approximation, as the super-Lorentzian lineshape diverges at ω_0  0.\n\nG_superLorentzian = interpolate_greens_function(greens_superlorentzian, 0, maximum(Tʳᶠ)/T₂ˢ)\n\nf_PSD(τ) = quadgk(ct -> (4 / τ / abs(1 - 3 * ct^2) * (exp(- τ^2 / 8 * (1 - 3 * ct^2)^2) - 1) + sqrt(2π) * erf(τ / 2 / sqrt(2) * abs(1 - 3 * ct^2))) / abs(1 - 3 * ct^2), 0.0, 1.0)[1]\nRʳᶠ = @. f_PSD(Tʳᶠ / T₂ˢ) * ω₁^2 * T₂ˢ\nz_Graham_spec_superLorentzian = @. (Rʳᶠ * exp(-Tʳᶠ * (R₁ + Rʳᶠ)) + R₁) / (R₁ + Rʳᶠ)\n\nz_Sled_superLorentzian = similar(Tʳᶠ)\nfor i ∈ eachindex(Tʳᶠ)\n    param = (ω₁[i], 1, ω₀, R₁, T₂ˢ, G_superLorentzian)\n    prob = ODEProblem(apply_hamiltonian_sled!, z₀, (0, Tʳᶠ[i]), param)\n    z_Sled_superLorentzian[i] = solve(prob).u[end][1]\nend\n\nz_gBloch_superLorentzian = similar(Tʳᶠ)\nfor i ∈ eachindex(Tʳᶠ)\n    param = (ω₁[i], 1, ω₀, R₁, T₂ˢ, G_superLorentzian)\n    prob = DDEProblem(apply_hamiltonian_gbloch!, z₀, z_fun, (0, Tʳᶠ[i]), param)\n    z_gBloch_superLorentzian[i] = solve(prob, MethodOfSteps(Tsit5())).u[end][1]\nend\n\np = plot(xaxis=:log, legend=:bottomright, xlabel=\"Tʳᶠ [s]\", ylabel=\"zˢ(Tʳᶠ)\")\nplot!(p, Tʳᶠ, z_gBloch_superLorentzian, label=\"generalized Bloch model\")\nplot!(p, Tʳᶠ, Tʳᶠ .* 0 .+ cos(α), label=\"cos(α)\")\nplot!(p, Tʳᶠ, z_Sled_superLorentzian, label=\"Sled's model\")\nplot!(p, Tʳᶠ, z_Graham_spec_superLorentzian, label=\"Graham's spectral model\")\nMain.HTMLPlot(p) #hide\n\nThis simulation reveals the most pronounced deviations of the generalized Bloch model from established models due to the slower decay of the super-Lorentzian Green's function.","category":"section"},{"location":"build_literate/Simulation_Pulse/#Error-Analysis","page":"RF-Pulse Simulation","title":"Error Analysis","text":"Assuming a super-Lorentzian lineshape, we quantify the deviations of Sled's model from the generalized Bloch model:\n\nTʳᶠᵢ = 1e-3 # s\nω₁ᵢ = α / Tʳᶠᵢ # rad/s\nparam = (ω₁ᵢ, 1, ω₀, R₁, T₂ˢ, G_superLorentzian)\n\nprob = ODEProblem(apply_hamiltonian_sled!, z₀, (0, Tʳᶠᵢ), param)\nz_Sled_superLorentzian_i = solve(prob).u[end][1]\n\nprob = DDEProblem(apply_hamiltonian_gbloch!, z₀, z_fun, (0, Tʳᶠᵢ), param)\nz_gBloch_superLorentzian_i = solve(prob, MethodOfSteps(Tsit5())).u[end][1]\n\nz_Sled_superLorentzian_i - z_gBloch_superLorentzian_i\n\nFor T_textRF = 1ms, the deviations are small compared to the thermal equilibrium magnetization z^s_0 = 1, but with T_textRF = 01ms, this deviation becomes sizable:\n\nTʳᶠᵢ = 1e-4 # s\nω₁ᵢ = α / Tʳᶠᵢ # rad/s\nparam = (ω₁ᵢ, 1, ω₀, R₁, T₂ˢ, G_superLorentzian)\n\nprob = ODEProblem(apply_hamiltonian_sled!, z₀, (0, Tʳᶠᵢ), param)\nz_Sled_superLorentzian_i = solve(prob).u[end][1]\n\nprob = DDEProblem(apply_hamiltonian_gbloch!, z₀, z_fun, (0, Tʳᶠᵢ), param)\nz_gBloch_superLorentzian_i = solve(prob, MethodOfSteps(Tsit5())).u[end][1]\n\nz_Sled_superLorentzian_i - z_gBloch_superLorentzian_i\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"(Image: )","category":"section"},{"location":"build_literate/Simulation_ContinuousWave/#Continuous-Wave-Simulation","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"The following code replicates the continuous wave simulation of Fig. 2 and is slightly more comprehensive in the sense that all discussed models are simulated.\n\nFor these simulations we need the following packages:\n\nusing MRIgeneralizedBloch\nusing DifferentialEquations\nusing QuadGK\nusing Plots\nplotlyjs(bg = RGBA(31/255,36/255,36/255,1.0), ticks=:native); #hide\nnothing #hide\n\nand we simulate an isolated semi-solid spin pool with the following parameters:\n\nR₁ = 1.0 # 1/s\nT₂ˢ = 10e-6 # s\n\nTʳᶠ = 2e-3 # s\nω₁ = 2000π # rad/s\nω₀ = 200π # rad/s\n\nt = range(0, Tʳᶠ, length=1001) # time points for plotting\ntspan = (0.0, Tʳᶠ); # simulation range\nnothing #hide\n\nThese parameters correspond to Fig. 2b, the parameters for replicating Fig. 2a are ω₁ = 200π and Tʳᶠ = 1s.","category":"section"},{"location":"build_literate/Simulation_ContinuousWave/#Lorentzian-Lineshape","page":"Continuous Wave Simulation","title":"Lorentzian Lineshape","text":"In this script, we simulate the three lineshapes separately, starting with the Lorentzian lineshape for which the Bloch model provides a ground truth.","category":"section"},{"location":"build_literate/Simulation_ContinuousWave/#Bloch-Model","page":"Continuous Wave Simulation","title":"Bloch Model","text":"We can formulate the Bloch model as\n\npartial_t beginpmatrix x  y  z  1 endpmatrix = beginpmatrix\n-R_2  -ω_0  ω_1  0 \nω_0  -R_2  0  0 \n-ω_1  0  -R_1  R_1 \n0  0  0  0\nendpmatrix beginpmatrix x  y  z  1 endpmatrix \n\nwhere the matrix is the Hamiltonian of the Bloch model. For a constant ω_0 and ω_1, we can evaluate the Bloch model by taking the  matrix exponential of its Hamiltonian:\n\nH(ω₁, ω₀, R₂, R₁) = [-R₂  -ω₀  ω₁  0;\n                       ω₀ -R₂   0  0;\n                      -ω₁   0 -R₁ R₁;\n                        0   0   0  0]\n\nz_Bloch = similar(t)\nfor i = 1:length(t)\n    (_, _, z_Bloch[i], _) = exp(H(ω₁, ω₀, 1 / T₂ˢ, R₁) * t[i]) * [0; 0; 1; 1]\nend","category":"section"},{"location":"build_literate/Simulation_ContinuousWave/#Henkelman's-Steady-State-Solution","page":"Continuous Wave Simulation","title":"Henkelman's Steady-State Solution","text":"When assuming an isolated semi-solid pool, Eq. (9) in Henkelman, R. Mark, et al. \"Quantitative interpretation of magnetization transfer.\" Magnetic resonance in medicine 29.6 (1993): 759-766 reduces to\n\ng_Lorentzian(ω₀) = T₂ˢ / π / (1 + (T₂ˢ * ω₀)^2)\nz_steady_state_Lorentzian = R₁ / (R₁ + π * ω₁^2 * g_Lorentzian(ω₀))\n\nwhere g_Lorentzian(ω₀) is the Lorentzian lineshape.","category":"section"},{"location":"build_literate/Simulation_ContinuousWave/#Graham's-Single-Frequency-Approximation","page":"Continuous Wave Simulation","title":"Graham's Single Frequency Approximation","text":"The lineshape is also used to calculate Graham's single frequency approximation, which describes an exponential decay with the RF-induced saturation rate Rʳᶠ:\n\nRʳᶠ = π * ω₁^2 * g_Lorentzian(ω₀)\nz_Graham_Lorentzian = @. (Rʳᶠ * exp(-t * (R₁ + Rʳᶠ)) + R₁) / (R₁ + Rʳᶠ);\nnothing #hide","category":"section"},{"location":"build_literate/Simulation_ContinuousWave/#Sled's-Model","page":"Continuous Wave Simulation","title":"Sled's Model","text":"Sled's model is given by the ordinary differential equation (ODE)\n\npartial_t z(t) = left(-pi int_0^t G(t-τ) omega_1(τ)^2 dτ right) z(t)  + R_1 (1-z)\n\nwhere G(t-τ) is the Green's function. The Hamiltonian of this ODE is implemented in apply_hamiltonian_sled! and we solve this ODE with the DifferentialEquations.jl package:\n\nz₀ = [1.0, 1.0] # initial z-magnetization\nparam = (ω₁, 1, ω₀, R₁, T₂ˢ, greens_lorentzian) # defined by apply_hamiltonian_sled!\nprob = ODEProblem(apply_hamiltonian_sled!, z₀, tspan, param)\nz_Sled_Lorentzian = solve(prob);\nnothing #hide","category":"section"},{"location":"build_literate/Simulation_ContinuousWave/#Generalized-Bloch-Model","page":"Continuous Wave Simulation","title":"Generalized Bloch Model","text":"The generalized Bloch model is an integro-differential equation (IDE) as it depends on z(τ) instead of z(t):\n\npartial_t z(t) = - ω_1(t) int_0^t G(tτ) ω_1(τ) z(τ) dτ + R_1 (1 - z(t)) \n\nFor off-resonant RF-pulses with ω_1 = ω_x + i ω_y, it is given by\n\npartial_t z(t) = - ω_y(t) int_0^t G(tτ) ω_y(τ) z(τ) dτ - ω_x(t) int_0^t G(tτ) ω_x(τ) z(τ) dτ + R_1 (1 - z(t)) \n\nThe Hamiltonian of the IDE is implemented in apply_hamiltonian_gbloch! and we can solve this IDE with the delay-differential equation (DDE) solver of the DifferentialEquations.jl package:\n\nzfun(p, t) = [1.0, 1.0] # initialize history function (will be populated with an interpolation by the DDE solver)\n\nparam = (ω₁, 1, ω₀, R₁, T₂ˢ, greens_lorentzian) # defined by apply_hamiltonian_gbloch!\nprob = DDEProblem(apply_hamiltonian_gbloch!, z₀, zfun, tspan, param)\nz_gBloch_Lorentzian = solve(prob, MethodOfSteps(Tsit5()));\nnothing #hide\n\nNow that we have solved all five models, we can plot the solutions for comparison:\n\np = plot(xlabel=\"t [ms]\", ylabel=\"zˢ(t)\")\nplot!(p, 1e3t, zero(similar(t)) .+ z_steady_state_Lorentzian, label=\"Henkelman's steady-state\")\nplot!(p, 1e3t, z_Graham_Lorentzian, label=\"Graham's model\")\nplot!(p, 1e3t, hcat(z_Sled_Lorentzian(t).u...)[1,:], label=\"Sled's model\")\nplot!(p, 1e3t, hcat(z_gBloch_Lorentzian(t).u...)[1,:], label=\"generalized Bloch model\")\nplot!(p, 1e3t, z_Bloch, label=\"Bloch model\")\nMain.HTMLPlot(p) #hide\n\nZooming into the plot, reveals virtually perfect (besides numerical differences) agreement between Bloch and generalized Bloch model and subtle, but existing differences when compared to the other models. Choosing a longer T₂ˢ amplifies these differences.","category":"section"},{"location":"build_literate/Simulation_ContinuousWave/#Gaussian-Lineshape","page":"Continuous Wave Simulation","title":"Gaussian Lineshape","text":"We can repeat these simulations (with the exception of the Bloch model) for the Gaussian lineshape:\n\ng_Gaussian(ω₀) = T₂ˢ / sqrt(2π) * exp(-(T₂ˢ * ω₀)^2 / 2)\nz_steady_state_Gaussian = R₁ / (R₁ + π * ω₁^2 * g_Gaussian(ω₀))\n\nRʳᶠ = π * ω₁^2 * g_Gaussian(ω₀)\nz_Graham_Gaussian = @. (Rʳᶠ * exp(-t * (R₁ + Rʳᶠ)) + R₁) / (R₁ + Rʳᶠ)\n\nparam = (ω₁, 1, ω₀, R₁, T₂ˢ, greens_gaussian) # defined by apply_hamiltonian_sled!\nprob = ODEProblem(apply_hamiltonian_sled!, z₀, tspan, param)\nz_Sled_Gaussian = solve(prob)\n\nprob = DDEProblem(apply_hamiltonian_gbloch!, z₀, zfun, tspan, param)\nz_gBloch_Gaussian = solve(prob, MethodOfSteps(Tsit5()))\n\np = plot(xlabel=\"t [ms]\", ylabel=\"zˢ(t)\")\nplot!(p, 1e3t, zero(similar(t)) .+ z_steady_state_Gaussian, label=\"Henkelman's steady-state\")\nplot!(p, 1e3t, z_Graham_Gaussian, label=\"Graham' model\")\nplot!(p, 1e3t, hcat(z_Sled_Gaussian(t).u...)[1,:], label=\"Sled's model\")\nplot!(p, 1e3t, hcat(z_gBloch_Gaussian(t).u...)[1,:], label=\"generalized Bloch model\")\nMain.HTMLPlot(p) #hide","category":"section"},{"location":"build_literate/Simulation_ContinuousWave/#Super-Lorentzian-Lineshape","page":"Continuous Wave Simulation","title":"Super-Lorentzian Lineshape","text":"And we can repeat these simulations (with the exception of the Bloch model) for the super-Lorentzian lineshape, which reveals the most pronounced deviations between the models due to the substantially slower decay of the Green's function:\n\ng_superLorentzian(ω₀) = sqrt(2 / π) * T₂ˢ * quadgk(ct -> exp(-2 * (T₂ˢ * ω₀ / abs(3 * ct^2 - 1))^2) / abs(3 * ct^2 - 1), 0.0, sqrt(1 / 3), 1)[1]\nz_steady_state_superLorentzian = R₁ / (R₁ + π * ω₁^2 * g_superLorentzian(ω₀))\n\nRʳᶠ = π * ω₁^2 * g_superLorentzian(ω₀)\nz_Graham_superLorentzian = @. (Rʳᶠ * exp(-t * (R₁ + Rʳᶠ)) + R₁) / (R₁ + Rʳᶠ)\n\nG_superLorentzian = interpolate_greens_function(greens_superlorentzian, 0, Tʳᶠ/T₂ˢ)\n\nparam = (ω₁, 1, ω₀, R₁, T₂ˢ, G_superLorentzian)\nprob = ODEProblem(apply_hamiltonian_sled!, z₀, tspan, param)\nz_Sled_superLorentzian = solve(prob)\n\nprob = DDEProblem(apply_hamiltonian_gbloch!, z₀, zfun, tspan, param)\nz_gBloch_superLorentzian = solve(prob, MethodOfSteps(Tsit5()))\n\n\np = plot(xlabel=\"t [ms]\", ylabel=\"zˢ(t)\")\nplot!(p, 1e3t, zero(similar(t)) .+ z_steady_state_superLorentzian, label=\"Henkelman's steady-state\")\nplot!(p, 1e3t, z_Graham_superLorentzian, label=\"Graham's model\")\nplot!(p, 1e3t, hcat(z_Sled_superLorentzian(t).u...)[1,:], label=\"Sled's model\")\nplot!(p, 1e3t, hcat(z_gBloch_superLorentzian(t).u...)[1,:], label=\"generalized Bloch model\")\nMain.HTMLPlot(p) #hide\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"(Image: )","category":"section"},{"location":"build_literate/NLLS/#Non-Linear-Least-Square-Fitting","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"This section gives a brief overview of the interface to fit the generalized Bloch model to hybrid-state free precession data. We use the LsqFit.jl package and supply the algorithm with analytic gradients that are calculated with the calculatesignal_linearapprox function that implements the linear approximation of the generalized Bloch model for a train of rectangular RF pulses.","category":"section"},{"location":"build_literate/NLLS/#Basic-Interface","page":"Non-Linear Least Square Fitting","title":"Basic Interface","text":"This tutorial uses the following packages:\n\nusing MRIgeneralizedBloch\nusing MAT\nusing LinearAlgebra\nusing Plots\nplotlyjs(bg = RGBA(31/255,36/255,36/255,1.0), ticks=:native); #hide\nnothing #hide\n\nand we demonstrate the concept at the example of the RF pulse train that we published in the paper Rapid quantitative magnetization transfer imaging: utilizing the hybrid state and the generalized Bloch model:\n\ncontrol = matread(normpath(joinpath(pathof(MRIgeneralizedBloch), \"../../docs/control_MT_v3p2_TR3p5ms_discretized.mat\")))\nα   = control[\"alpha\"]\nTRF = control[\"TRF\"]\ngrad_moment = [:crusher; fill(:balanced, length(α)-1)]\n\nTR = 3.5e-3\nt = TR .* (1:length(TRF));\nnothing #hide\n\nAs an example we can assume the following ground truth parameters\n\nm0s = 0.15\nR1f = 0.5 # 1/s\nR2f = 17 # 1/s\nRex = 30 # 1/s\nR1s = 3 # 1/s\nT2s = 12e-6 # s\nω0 = 100 # rad/s\nB1 = 0.9; # in units of B1_nominal\nnothing #hide\n\nprecompute the linear approximation\n\nR2slT = precompute_R2sl();\nnothing #hide\n\nand simulate the signal:\n\ns = calculatesignal_linearapprox(α, TRF, TR, ω0, B1, m0s, R1f, R2f, Rex, R1s, T2s, R2slT; grad_moment)\ns = vec(s)\n\nTo make this example a bit more realistic, we add complex valued Gaussian noise:\n\ns .+= 0.01 * randn(ComplexF64, size(s));\nnothing #hide\n\nNow we can fit the model to the noisy data:\n\nqM = fit_gBloch(s, α, TRF, TR; R2slT, grad_moment)\n\nThe last keyword argument is optional. It allows to recycle the precomputed R2sl, which improves speed. If not specified, it is re-calculated internally.\n\nThe results are stored in a struct and we can access the fitted parameters with\n\nqM.m0s\n\nqM.R1f # 1/s\n\nqM.R2f # 1/s\n\nqM.Rex # 1/s\n\nqM.R1s # 1/s\n\n1e6qM.T2s # μs\n\nqM.ω0 # rad/s\n\nqM.B1 # 1/B1_nominal\n\nWe can also simulate the signal with the fitted parameters\n\ns_fitted = calculatesignal_linearapprox(α, TRF, TR, qM.ω0, qM.B1, qM.m0s, qM.R1f, qM.R2f, qM.Rex, qM.R1s, qM.T2s, R2slT; grad_moment)\ns_fitted = vec(s_fitted);\nnothing #hide\n\nand compare it to the noisy data:\n\np = plot(xlabel=\"t (s)\", ylabel=\"signal (normalized)\", legend=:topleft)\nplot!(p, t, real.(s), label=\"Re(s)\")\nplot!(p, t, imag.(s), label=\"Im(s)\")\nplot!(p, t, real.(s_fitted), label=\"Re(s_fitted)\")\nplot!(p, t, imag.(s_fitted), label=\"Im(s_fitted)\")\nMain.HTMLPlot(p) #hide","category":"section"},{"location":"build_literate/NLLS/#Bounds-and-Fixed-Parameters","page":"Non-Linear Least Square Fitting","title":"Bounds and Fixed Parameters","text":"Above example uses the default bounds\n\nreM0 = (-Inf,   1,  Inf)\n\nimM0 = (-Inf,   0,  Inf)\n\nm0s  = (   0, 0.2,    1)\n\nR1f  = (   0, 0.3,  Inf)\n\nR2f  = (   0,  15,  Inf)\n\nRex  = (   0,  20,  Inf)\n\nR1s  = (   0,   3,  Inf)\n\nT2s  = (8e-6,1e-5,12e-6)\n\nω0   = (-Inf,   0,  Inf)\n\nB1   = (   0,   1,  1.5)\n\nwhere the three entries refer to (minimum, start_value, maximum) (cf. fit_gBloch).\n\nWith keyword arguments, one can modify each of these bounds. For example:\n\nqM = fit_gBloch(s, α, TRF, TR; R2slT, m0s  = (0.1, 0.3, 0.5), grad_moment)\n\nstarts the fit at m0s = 0.3 and uses a lower bound of 0.1 and an upper bound of 0.5. Alternatively, one also fix parameters to specified values:\n\nqM = fit_gBloch(s, α, TRF, TR; R2slT, ω0 = 0, B1 = 1, grad_moment)\n\nIn this case, the derivatives wrt. ω0 and B1 are not calculated and the result is accordingly\n\nqM.ω0\n\nqM.B1","category":"section"},{"location":"build_literate/NLLS/#Linear-Compression","page":"Non-Linear Least Square Fitting","title":"Linear Compression","text":"As originally suggested by McGivney et al. for MR Fingerprinting, the manifold of signal evolution or fingerprints is low rank and it is often beneficial to reconstruct images directly in this domain. We can calculate a low rank basis with\n\nsv = Array{ComplexF64}(undef, length(s), 50)\nfor i=1:size(sv,2)\n    sv[:,i] = calculatesignal_linearapprox(α, TRF, TR, 500randn(), 0.8 + 0.4rand(), rand(), rand(), 20rand(), 30rand(), 3rand(), 8e-6+5e-6rand(), R2slT; grad_moment)\nend\nu, _, _ = svd(sv)\nu = u[:,1:9];\nnothing #hide\n\nwhere the rank 9 was chosen heuristically. The noisy signal can be compressed with\n\nsc = u' * s\n\nand fitted by calling fit_gBloch with the keyword argument u=u:\n\nqM = fit_gBloch(sc, α, TRF, TR; R2slT, u, grad_moment)","category":"section"},{"location":"build_literate/NLLS/#Apparent-R_1","page":"Non-Linear Least Square Fitting","title":"Apparent R_1","text":"Above fits tread R1f and R1s of the free and the semi-solid as independent parameters. As we discussed in our paper, many publications in the literature assume an apparent R1a = R1f = R1s. The corresponding model can be fitted by specifying fit_apparentR1=true:\n\nR1a = 1 # 1/s\ns = calculatesignal_linearapprox(α, TRF, TR, ω0, B1, m0s, R1a, R2f, Rex, R1a, T2s, R2slT; grad_moment)\nqM = fit_gBloch(vec(s), α, TRF, TR; fit_apparentR1=true, R1a = (0, 0.7, Inf), R2slT, grad_moment)\n\nHere, we specified the limits of R1a explicitly, which is optional.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"api/#API","page":"API","title":"API","text":"In the following, you find the documentation of all exported functions of the MRIgeneralizedBloch.jl package:\n\n","category":"section"},{"location":"api/#MRIgeneralizedBloch.CRB_gradient_OCT-NTuple{14, Any}","page":"API","title":"MRIgeneralizedBloch.CRB_gradient_OCT","text":"CRB, grad_ω1, grad_TRF = CRB_gradient_OCT(ω1, TRF, TR, ω0, B1, m0s, R1f, R2f, Rex, R1s, T2s, R2slT, grad_list, weights; grad_moment=[i[1] == 1 ? :spoiler_dual : :balanced for i ∈ CartesianIndices(ω1)])\n\nCalculate the Cramer-Rao bound of a pulse sequence along with the derivatives wrt. ω1 and TRF.\n\nArguments\n\nω1::Vector{Real}: Control vector of length = Npulses (matrix if more than 1 sequence are optimized)\nTRF::Vector{Real}: Control vector of length = Npulses (matrix if more than 1 sequence are optimized)\nTR::Real: Repetition time in seconds\nω0::Real: Off-resonance frequency in rad/s\nB1::Real: Normalized transmit B1 field, i.e. B1 = 1 corresponds to a well-calibrated B1 field\nm0s::Real: Fractional size of the semi-solid pool; should be in range of 0 to 1\nR1f::Real: Longitudinal relaxation rate of the free pool in 1/seconds\nR2f::Real: Transversal relaxation rate of the free pool in 1/seconds\nRex::Real: Exchange rate between the two spin pools in 1/seconds\nR1f::Real: Longitudinal relaxation rate of the semi-solid pool in 1/seconds\nT2s::Real: Transversal relaxation time of the semi-solid pool in seconds\nR2slT::NTuple{3, Function}: Tuple of three functions: R2sl(TRF, ω1, B1, T2s), dR2sldB1(TRF, ω1, B1, T2s), and R2sldT2s(TRF, ω1, B1, T2s). Can be generated with precompute_R2sl\ngrad_list::Tuple{<:grad_param}: Tuple that specifies the gradients that are calculated; the vector elements can either be any subset/order of grad_list=(grad_m0s(), grad_R1f(), grad_R2f(), grad_Rex(), grad_R1s(), grad_T2s(), grad_ω0(), grad_B1()); the derivative wrt. to apparent R1a = R1f = R1s can be calculated with grad_R1a()\nweights::transpose(Vector{Real}): Row vector of weights applied to the Cramer-Rao bounds (CRB) of the individual parameters. The first entry always refers to the CRB of M0, followed by the values defined in grad_list in the order defined therein. Hence, the vector weights has to have one more entry than grad_list\n\nOptional Keyword Arguments:\n\ngrad_moment=[i[1] == 1 ? :spoiler_dual : :balanced for i ∈ CartesianIndices(ω1)]: Different types of gradient moments of each TR are possible (:balanced, :crusher, :spoiler_dual, :spoiler_prepulse). :balanced simulates a TR with all gradient moments nulled. :crusher assumes equivalent (non-zero) gradient moments before and simulates the refocussing path of the extended phase graph. :spoiler_prepulse nulls all transverse magnetization before the RF pulse, emulating an idealized FLASH. :spoiler_dual nulls all transverse magnetization before and after the RF pulse.\n\nExamples\n\njulia> CRB, grad_ω1, grad_TRF = MRIgeneralizedBloch.CRB_gradient_OCT(range(pi/2, π, 100), range(100e-6, 400e-6, 100), 3.5e-3, 0, 1, 0.15, 0.5, 15, 30, 4, 10e-6, precompute_R2sl(), [grad_m0s(), grad_R2f()], transpose([0, 1, 1]))\n(7.036532949438835e17, [-3.390796354537386e15, -1.9839673463682364e16, 1.9478009146395284e16, -1.8267985259974836e16, 1.6854024503161112e16, -1.564870176592121e16, 1.3903706541983584e16, -1.2606082554973334e16, 1.1194927161388668e16, -9.539757823647384e15  …  2.5718054915661044e16, -8.337218806299867e16, 4.778792906164447e16, -8.836386285134571e16, 7.1006544616540664e16, -9.901490876727578e16, 9.339003931389179e16, -1.1880577663606485e17, 1.1196316998153437e17, -1.526589221445061e17], [-6.260353922953729e19, -3.1566204597354915e20, 2.8346374467477307e20, -2.8268175999840482e20, 2.331816059339016e20, -2.376712332529386e20, 1.816604170405834e20, -1.9023039511824227e20, 1.3663891126875767e20, -1.4586637093661966e20  …  3.0242994279981213e20, -5.942607397341693e20, 4.384537591620554e20, -6.72590448103838e20, 5.776809344770309e20, -7.977977759334612e20, 7.085448466252249e20, -9.913215504590694e20, 8.145557315154696e20, -1.2823732424849773e21])\n\n\nc.f. Optimal Control\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.RF_power!-NTuple{4, Any}","page":"API","title":"MRIgeneralizedBloch.RF_power!","text":"F = RF_power!(grad_ω1, grad_TRF, ω1, TRF; λ=1, Pmax=3e6, TR=3.5e-3)\n\nCalculate RF power penalty and add the gradients in place.\n\nArguments\n\ngrad_ω1::Vector{Real}: Gradient of control, which will be added in place (matrix if more than 1 sequence are optimized)\ngrad_TRF::Vector{Real}: Gradient of control, which will be added in place (matrix if more than 1 sequence are optimized)\nω1::Vector{Real}: Control vector (matrix if more than 1 sequence are optimized)\nTRF::Vector{Real}: Control vector (matrix if more than 1 sequence are optimized)\n\nOptional Keyword Arguments:\n\nλ::Real: regularization parameter\nPmax::Real: Maximum average power deposition in (rad/s)²; everything above this value will be penalized and with an appropriate λ, the resulting power will be equal to or less than this value.\nTR::Real: Repetition time of the pulse sequence\n\nExamples\n\njulia> ω1 = range(0, 4000π, 100);\n\njulia> TRF = range(100e-6, 500e-6, 100);\n\njulia> grad_ω1 = similar(ω1);\n\njulia> grad_TRF = similar(ω1);\n\njulia> F = MRIgeneralizedBloch.RF_power!(grad_ω1, grad_TRF, ω1, TRF; λ=1e3, Pmax=3e6, TR=3.5e-3)\n9.418321886730644e15\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.TRF_TV!-Tuple{Any, Any}","page":"API","title":"MRIgeneralizedBloch.TRF_TV!","text":"F = TRF_TV!(grad_TRF, TRF; λ=1, grad_moment=[i[1] == 1 ? :spoiler_dual : :balanced for i ∈ CartesianIndices(TRF)])\n\nCalculate the total variation penalty of TRF and add to grad_TRF in place.\n\nArguments\n\ngrad_TRF::Vector{Real}: Gradient of control, which will added in place (matrix if more than 1 sequence are optimized)\nTRF::Vector{Real}: Control vector (matrix if more than 1 sequence are optimized)\n\nOptional Keyword Arguments:\n\nλ::Real: regularization parameter\ngrad_moment = [i[1] == 1 ? :spoiler_dual : :balanced for i ∈ CartesianIndices(TRF)]: Different types of gradient moments of each TR are possible (:balanced, :spoilerdual, :crusher). Skip :crusher and :spoilerdual TRs for the TRF TV penalty\n\nExamples\n\njulia> TRF = range(100e-6, 500e-6, 100);\n\njulia> grad_TRF = similar(TRF);\n\njulia> F = MRIgeneralizedBloch.TRF_TV!(grad_TRF, TRF; λ = 1e-3)\n3.9595959595959597e-7\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.apply_hamiltonian_gbloch!-Tuple{Any, Any, Any, NTuple{11, Any}, Any}","page":"API","title":"MRIgeneralizedBloch.apply_hamiltonian_gbloch!","text":"apply_hamiltonian_gbloch!(∂m∂t, m, mfun, p, t)\n\nApply the generalized Bloch Hamiltonian to m and write the resulting derivative wrt. time into ∂m∂t.\n\nArguments\n\n∂m∂t::Vector{Real}: Vector describing to derivative of m wrt. time; this vector has to be of the same size as m, but can contain any value, which is replaced by H * m\nm::Vector{Real}: Vector the spin ensemble state of the form [xf, yf, zf, zs, 1] if now gradient is calculated or of the form [xf, yf, zf, zs, 1, ∂xf/∂θ1, ∂yf/∂θ1, ∂zf/∂θ1, ∂zs/∂θ1, 0, ..., ∂xf/∂θn, ∂yf/∂θn, ∂zf/∂θn, ∂zs/∂θn, 0] if n derivatives wrt. θn are calculated\nmfun: History function; can be initialized with mfun(p, t; idxs=nothing) = typeof(idxs) <: Real ? 0.0 : zeros(5n + 5) for n gradients, and is then updated by the delay differential equation solvers\np::NTuple{6,Any}: (ω1, B1, ω0, R1s, T2s, g) or\np::NTuple{6,Any}: (ω1, B1,  φ, R1s, T2s, g) or\np::NTuple{10,Any}: (ω1, B1, ω0, m0s, R1f, R2f, Rex, R1s, T2s, g) or\np::NTuple{10,Any}: (ω1, B1,  φ, m0s, R1f, R2f, Rex, R1s, T2s, g) or\np::NTuple{12,Any}: (ω1, B1, ω0, m0s, R1f, R2f, Rex, R1s, T2s, g, dG_o_dT2s_x_T2s, grad_list) or\np::NTuple{12,Any}: (ω1, B1, ω0, m0s, R1f, R2f, Rex, R1s, T2s, g, dG_o_dT2s_x_T2s, grad_list) with the following entries\nω1::Real: Rabi frequency in rad/s (rotation about the y-axis) or\nω1(t)::Function: Rabi frequency in rad/s as a function of time for shaped RF-pulses\nB1::Real: B1 scaling normalized so that B1=1 corresponds to a perfectly calibrated RF field\nω0::Real: Larmor or off-resonance frequency in rad/s or\nφ::Function: RF-phase in rad as a function of time for frequency/phase-sweep pulses (works only in combination with ω1(t)::Function)\nm0s::Real: Fractional semi-solid spin pool size in the range of 0 to 1\nR1f::Real: Longitudinal spin relaxation rate of the free pool in 1/seconds\nR2f::Real: Transversal spin relaxation rate of the free pool in 1/seconds\nRex::Real: Exchange rate between the two pools in 1/seconds\nR1s::Real: Longitudinal spin relaxation rate of the semi-solid pool in 1/seconds\nT2s::Real: Transversal spin relaxation time of the semi-solid pool in seconds\ng::Function: Green's function of the form G(κ) = G((t-τ)/T2s)\ndG_o_dT2s_x_T2s::Function: Derivative of the Green's function wrt. T2s, multiplied by T2s; of the form dG_o_dT2s_x_T2s(κ) = dG_o_dT2s_x_T2s((t-τ)/T2s)\ngrad_list::Vector{grad_param}: List of gradients to be calculated, i.e., any subset of [grad_m0s(), grad_R1f(), grad_R2f(), grad_Rex(), grad_R1s(), grad_T2s(), grad_ω0(), grad_B1()]; length of the vector must be n (cf. arguments m and ∂m∂t); the derivative wrt. to apparent R1a = R1f = R1s can be calculated with grad_R1a()\nt::Real: Time in seconds\n\nOptional:\n\npulsetype=:normal: Use default for a regular RF-pulse; the option pulsetype=:inversion should be handled with care as it is only intended to calculate the saturation of the semi-solid pool and its derivative.\n\nExamples\n\njulia> using DifferentialEquations\n\njulia> α = π/2;\n\njulia> TRF = 100e-6;\n\njulia> ω1 = α/TRF;\n\njulia> B1 = 1;\n\njulia> ω0 = 0;\n\njulia> m0s = 0.2;\n\njulia> R1f = 1/3;\n\njulia> R2f = 15;\n\njulia> R1s = 2;\n\njulia> T2s = 10e-6;\n\njulia> Rex = 30;\n\njulia> G = interpolate_greens_function(greens_superlorentzian, 0, TRF / T2s);\n\njulia> m0 = [0; 0; 1-m0s; m0s; 1];\n\njulia> mfun(p, t; idxs=nothing) = typeof(idxs) <: Real ? 0.0 : zeros(5);\n\njulia> sol = solve(DDEProblem(apply_hamiltonian_gbloch!, m0, mfun, (0, TRF), (ω1, B1, ω0, m0s, R1f, R2f, Rex, R1s, T2s, G)), MethodOfSteps(Tsit5()))\nretcode: Success\nInterpolation: specialized 4th order \"free\" interpolation\nt: 9-element Vector{Float64}:\n 0.0\n 1.375006182301112e-7\n 1.512506800531223e-6\n 8.042561462897698e-6\n 2.107848848643912e-5\n 3.911418153169565e-5\n 6.268793403244071e-5\n 9.147711277097536e-5\n 0.0001\nu: 9-element Vector{Vector{Float64}}:\n [0.0, 0.0, 0.8, 0.2, 1.0]\n [0.0017278806030763402, 0.0, 0.7999981340131751, 0.19999953350448, 1.0]\n [0.019004717382235078, 0.0, 0.7997742277135814, 0.19994357804868362, 1.0]\n [0.10079111057210487, 0.0, 0.7936248126644649, 0.19842287249439766, 1.0]\n [0.26002578123515735, 0.0, 0.7565529685035107, 0.18981913084469726, 1.0]\n [0.46104237185160846, 0.0, 0.6537239507723229, 0.16937683480955013, 1.0]\n [0.6661740252095096, 0.0, 0.4426121112504473, 0.1358931147134579, 1.0]\n [0.7923117749819578, 0.0, 0.10713075535178414, 0.0939026077525371, 1.0]\n [0.7994211188442862, 0.0, 0.00044033743049392323, 0.08214809659226695, 1.0]\n\njulia> dG_o_dT2s_x_T2s = interpolate_greens_function(dG_o_dT2s_x_T2s_superlorentzian, 0, TRF / T2s);\n\njulia> grad_list = (grad_R2f(), grad_m0s());\n\njulia> m0 = [0; 0; 1-m0s; m0s; 1; zeros(5*length(grad_list))];\n\njulia> mfun(p, t; idxs=nothing) = typeof(idxs) <: Real ? 0.0 : zeros(5 + 5*length(grad_list));\n\njulia> sol = solve(DDEProblem(apply_hamiltonian_gbloch!, m0, mfun, (0, TRF), (ω1, B1, ω0, m0s, R1f, R2f, Rex, R1s, T2s, G, dG_o_dT2s_x_T2s, grad_list)), MethodOfSteps(Tsit5()))\nretcode: Success\nInterpolation: specialized 4th order \"free\" interpolation\nt: 9-element Vector{Float64}:\n 0.0\n 1.3749977183723476e-7\n 1.5124974902095823e-6\n 8.55413928087924e-6\n 2.2735031185663937e-5\n 4.19108470558807e-5\n 6.604834675708889e-5\n 9.498577875254548e-5\n 0.0001\nu: 9-element Vector{Vector{Float64}}:\n [0.0, 0.0, 0.8, 0.2, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n [0.0017278699670365163, 0.0, 0.7999981340361474, 0.19999953351022304, 1.0, -1.1879082228166889e-10, 0.0, 8.552314797346093e-14, 1.7639111626379964e-20, 0.0, -4.504148593116325e-9, 0.0, -4.170810886524201e-6, 4.399976485334709e-6, 0.0]\n [0.019004600420955017, 0.0, 0.7997742304929397, 0.1999435787430011, 1.0, -1.4372150874574205e-8, 0.0, 1.1382351624387973e-10, 2.582351851673891e-16, 0.0, -5.449397614775737e-7, 0.0, -4.586940831786521e-5, 4.8389939712349446e-5, 0.0]\n [0.10716443623865489, 0.0, 0.7927892601714349, 0.19821857478945182, 1.0, -4.583399621367497e-7, 0.0, 2.0553664518760576e-8, 2.6371802289291116e-13, 0.0, -1.7378210958556595e-5, 0.0, -0.00025789082577413444, 0.000272108762962073, 0.0]\n [0.2796150309669262, 0.0, 0.7495316534746568, 0.18828190387976126, 1.0, -3.1783478165730177e-6, 0.0, 3.8161527675201545e-7, 1.3013762608576572e-11, 0.0, -0.00012051934290282377, 0.0, -0.0006606411859023958, 0.0006984066858780591, 0.0]\n [0.4892864720822774, 0.0, 0.632847234166742, 0.16565573509863743, 1.0, -1.0252123180462778e-5, 0.0, 2.3176672964164325e-6, 1.4579058977830925e-10, 0.0, -0.00038904986340924794, 0.0, -0.0010958655218685713, 0.001171980309319979, 0.0]\n [0.6885646541968483, 0.0, 0.4068512686677757, 0.1309174303256667, 1.0, -2.2735398366534667e-5, 0.0, 8.492086356144201e-6, 8.444612435331494e-10, 0.0, -0.0008655167803567697, 0.0, -0.0013568007560206506, 0.001522818443889853, 0.0]\n [0.796968522108364, 0.0, 0.06333054117000982, 0.08900920150401267, 1.0, -3.784041815054497e-5, 0.0, 2.2377155206782674e-5, 3.2320972096434295e-9, 0.0, -0.001454710061558483, 0.0, -0.0011369133117761624, 0.0015299729958457285, 0.0]\n [0.7994211129892578, 0.0, 0.0004402646711967819, 0.08214809793086313, 1.0, -3.995979477323799e-5, 0.0, 2.5441798584056785e-5, 3.87911904112647e-9, 0.0, -0.00154036350300196, 0.0, -0.0010380366536841005, 0.001486424275625734, 0.0]\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.apply_hamiltonian_sled!-Tuple{Any, Any, Tuple{Real, Real, Real, Real, Real, Function}, Any}","page":"API","title":"MRIgeneralizedBloch.apply_hamiltonian_sled!","text":"apply_hamiltonian_sled!(∂m∂t, m, p, t)\n\nApply Sled's Hamiltonian to m and write the resulting derivative wrt. time into ∂m∂t.\n\nArguments\n\n- `∂m∂t::Vector{<:Real}`: Vector of length 1 describing to derivative of `m` wrt. time; this vector can contain any value, which is replaced by `H * m`\n- `m::Vector{<:Real}`: Vector of length 1 describing the `zs` magnetization\n- `p::NTuple{6 or 10, Any}`: `(ω1, B1, ω0, R1s, T2s, g)` for a simulating an isolated semi-solid pool or `(ω1, B1, ω0, m0s, R1f, R2f, Rex, R1s, T2s, g)` for simulating a coupled spin system; with\n- `ω1::Real`: Rabi frequency in rad/s (rotation about the y-axis) or\n- `ω1(t)::Function`: Rabi frequency in rad/s as a function of time for shaped RF-pulses\n- `B1::Real`: B1 scaling normalized so that `B1=1` corresponds to a perfectly calibrated RF field\n- `ω0::Real`: Larmor or off-resonance frequency in rad/s (is only used for the free spin pool)\n- `R1f::Real`: Longitudinal spin relaxation rate of the free pool in 1/seconds\n- `R2f::Real`: Transversal spin relaxation rate of the free pool in 1/seconds\n- `R1s::Real`: Longitudinal spin relaxation rate of the semi-solid in 1/seconds\n- `Rex::Real`: Exchange rate between the two pools in 1/seconds\n- `T2s::Real`: Transversal spin relaxation time in seconds\n- `g::Function`: Green's function of the form `G(κ) = G((t-τ)/T2s)`\n\nt::Real: Time in seconds\n\nExamples\n\njulia> using DifferentialEquations\n\njulia> α = π/2;\n\njulia> TRF = 100e-6;\n\njulia> ω1 = α/TRF;\n\njulia> B1 = 1;\n\njulia> ω0 = 0;\n\njulia> R1s = 2;\n\njulia> T2s = 10e-6;\n\njulia> G = interpolate_greens_function(greens_superlorentzian, 0, TRF / T2s);\n\njulia> m0 = [1];\n\njulia> sol = solve(ODEProblem(apply_hamiltonian_sled!, m0, (0, TRF), (ω1, 1, ω0, R1s, T2s, G)), Tsit5())\nretcode: Success\nInterpolation: specialized 4th order \"free\" interpolation\nt: 3-element Vector{Float64}:\n 0.0\n 7.475414666720001e-5\n 0.0001\nu: 3-element Vector{Vector{Float64}}:\n [1.0]\n [0.6313928231811967]\n [0.4895365449661913]\n\njulia> using Plots\n\njulia> plot(sol, labels=[\"zs\"], xlabel=\"t (s)\", ylabel=\"m(t)\");\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.bound_ω1_TRF!-Tuple{Any, Any}","page":"API","title":"MRIgeneralizedBloch.bound_ω1_TRF!","text":"x = bound_ω1_TRF!(ω1, TRF; ω1_min=zeros(size(ω1)), ω1_max=fill(2e3π, size(ω1)), TRF_min=fill(100e-6, size(TRF)), TRF_max=fill(500e-6, size(TRF)))\n\nBound the controls ω1 and TRF (over-written in place) and return a vector of length 2Npulses * NSeq with values in the range [-Inf, Inf] that relate to the bounded ω1 and TRF via the tanh function.\n\nArguments\n\nω1: Control vector of length Npulses or matrix with the number of sequences in the second dimension\nTRF: Control vector of length Npulses or matrix with the number of sequences in the second dimension\n\nOptional Keyword Arguments:\n\nω1_min: elementwise lower bound for ω1 in rad/s\nω1_max: elementwise upper bound for ω1 in rad/s\nTRF_min: elementwise lower bound for TRF in s\nTRF_max: elementwise bound for TRF in s\n\nExamples\n\njulia> ω1 = collect(range(0, 2000π, 100));\n\njulia> TRF = collect(range(100e-6, 500e-6, 100));\n\njulia> x = MRIgeneralizedBloch.bound_ω1_TRF!(ω1, TRF)\n200-element Vector{Float64}:\n -Inf\n  -2.2924837393352853\n  -1.9407818989717183\n  -1.7328679513998637\n  -1.5837912652403254\n  -1.4669284349179519\n  -1.3704200119626004\n  -1.2879392139968635\n  -1.2157089824185072\n  -1.151292546497023\n   ⋮\n   1.2157089824185072\n   1.2879392139968635\n   1.3704200119626009\n   1.4669284349179519\n   1.5837912652403245\n   1.7328679513998637\n   1.9407818989717212\n   2.2924837393352826\n  Inf\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.calculatesignal_gbloch_ide-NTuple{11, Any}","page":"API","title":"MRIgeneralizedBloch.calculatesignal_gbloch_ide","text":"calculatesignal_gbloch_ide(α, TRF, TR, ω0, B1, m0s, R1f, R2f, Rex, R1s, T2s[; grad_list, Ncyc=2, output=:complexsignal])\n\nCalculate the signal or magnetization evolution with the full generalized Bloch model assuming a super-Lorentzian lineshape (slow).\n\nThe simulation assumes a sequence of rectangular RF-pulses with varying flip angles α and RF-pulse durations TRF, but a fixed repetition time TR. Further, it assumes balanced gradient moments.\n\nArguments\n\nα::Vector{Real}: Array of flip angles in radians\nTRF::Vector{Real}: Array of the RF-pulse durations in seconds\nTR::Real: Repetition time in seconds\nω0::Real: Off-resonance frequency in rad/s\nB1::Real: Normalized transmit B1 field, i.e. B1 = 1 corresponds to a well-calibrated B1 field\nm0s::Real: Fractional size of the semi-solid pool; should be in range of 0 to 1\nR1f::Real: Longitudinal relaxation rate of the free pool in 1/seconds\nR2f::Real: Transversal relaxation rate of the free pool in 1/seconds\nRex::Real: Exchange rate between the two spin pools in 1/seconds\nR1s::Real: Longitudinal relaxation rate of the semi-solid pool in 1/seconds\nT2s::Real: Transversal relaxation time of the semi-solid pool in seconds\n\nOptional Arguments:\n\ngrad_list=(): Tuple that specifies the gradients that are calculated; the Tuple can either be empty () for no gradient, or contain any subset/order of grad_list=(grad_m0s(), grad_R1s(), grad_R2f(), grad_Rex(), grad_R1s(), grad_T2s(), grad_ω0(), grad_B1()); the derivative wrt. to apparent R1a = R1f = R1s can be calculated with grad_R1a()\nNcyc=2: The magnetization is initialized with thermal equilibrium and then performed Ncyc times and only the last cycle is stored. The default value is usually a good approximation for antiperiodic boundary conditions. Increase the number for higher precision at the cost of computation time.\noutput=:complexsignal: The default keywords triggers the function to output a complex-valued signal (xf + 1im yf); the keyword output=:realmagnetization triggers an output of the entire (real valued) vector [xf, yf, zf, xs, zs]\ngreens=(greens_superlorentzian, dG_o_dT2s_x_T2s_superlorentzian): Tuple of a Greens function G(κ) = G((t-τ)/T2s) and its partial derivative wrt. T2s, multiplied by T2s ∂G((t-τ)/T2s)/∂T2s * T2s. This package supplies the three Greens functions greens=(greens_superlorentzian, dG_o_dT2s_x_T2s_superlorentzian) (default), greens=(greens_lorentzian, dG_o_dT2s_x_T2s_lorentzian), and greens=(greens_gaussian, dG_o_dT2s_x_T2s_gaussian)\n\nExamples\n\njulia> calculatesignal_gbloch_ide(fill(π/2, 100), fill(5e-4, 100), 4e-3, 0, 1, 0.2, 0.3, 15, 20, 2, 10e-6)\n100×1 Matrix{ComplexF64}:\n   -0.00796631644531007 + 0.0im\n  0.0012590590420428205 - 0.0im\n  -0.006088855588249691 + 0.0im\n  0.0024187389409131197 - 0.0im\n  -0.004361339394954331 + 0.0im\n  0.0034891358222515524 - 0.0im\n  -0.002763371060585636 + 0.0im\n   0.004483217942995653 - 0.0im\n -0.0012812573504847615 + 0.0im\n   0.005408854036525993 - 0.0im\n                        ⋮\n   0.017760808273166815 - 0.0im\n   0.017576118975513207 + 0.0im\n    0.01781395094611691 - 0.0im\n    0.01764385633643116 + 0.0im\n   0.017863575856212212 - 0.0im\n   0.017706926034820686 + 0.0im\n   0.017909914934264932 - 0.0im\n   0.017765650374172208 + 0.0im\n    0.01795318489372217 - 0.0im\n\njulia> calculatesignal_gbloch_ide(fill(π/2, 100), fill(5e-4, 100), 4e-3, 0, 1, 0.2, 0.3, 15, 20, 2, 10e-6; grad_list=(grad_R1f(), grad_T2s()), output=:realmagnetization)\n100×15 transpose(::Matrix{Float64}) with eltype Float64:\n -0.00796627   0.0   0.000637773  …   0.0   -10.8757  -335.26   0.0\n  0.00125903  -0.0  -0.00700671      -0.0   125.882   -326.977  0.0\n -0.00608882   0.0   0.00185086       0.0   -30.4187  -317.56   0.0\n  0.00241873  -0.0  -0.00520622      -0.0    96.1776  -309.906  0.0\n -0.00436133   0.0   0.00296471       0.0   -47.5803  -302.948  0.0\n  0.003489    -0.0  -0.00354518   …  -0.0    69.5148  -298.697  0.0\n -0.00276366   0.0   0.00399588       0.0   -62.8453  -294.886  0.0\n  0.00448273  -0.0  -0.00200673      -0.0    45.3179  -292.783  0.0\n -0.00128187   0.0   0.00495478       0.0   -76.6573  -290.321  0.0\n  0.00540814  -0.0  -0.000578836     -0.0    23.1756  -289.245  0.0\n  ⋮                               ⋱\n  0.0177563   -0.0   0.0175372       -0.0  -290.779   -349.855  0.0\n  0.0175716    0.0   0.0177845        0.0  -295.347   -350.002  0.0\n  0.0178094   -0.0   0.0176073       -0.0  -292.44    -350.163  0.0\n  0.0176393    0.0   0.0178359        0.0  -296.668   -350.3    0.0\n  0.017859    -0.0   0.0176727    …  -0.0  -294.001   -350.451  0.0\n  0.0177024    0.0   0.0178838        0.0  -297.914   -350.579  0.0\n  0.0179053   -0.0   0.0177335       -0.0  -295.467   -350.72   0.0\n  0.0177611    0.0   0.0179286        0.0  -299.09    -350.84   0.0\n  0.0179486   -0.0   0.0177902       -0.0  -296.845   -350.972  0.0\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.calculatesignal_graham_ode-NTuple{11, Any}","page":"API","title":"MRIgeneralizedBloch.calculatesignal_graham_ode","text":"calculatesignal_graham_ode(α, TRF, TR, ω0, B1, m0s, R1f, R2f, Rex, R1s, T2s[; grad_list, Ncyc=2, output=:complexsignal])\n\nCalculate the signal or magnetization evolution with Graham's spectral model assuming a super-Lorentzian lineshape.\n\nThe simulation assumes a sequence of rectangular RF-pulses with varying flip angles α and RF-pulse durations TRF, but a fixed repetition time TR. Further, it assumes balanced gradient moments.\n\nArguments\n\nα::Vector{Real}: Array of flip angles in radians\nTRF::Vector{Real}: Array of the RF-pulse durations in seconds\nTR::Real: Repetition time in seconds\nω0::Real: Off-resonance frequency in rad/s\nB1::Real: Normalized transmit B1 field, i.e. B1 = 1 corresponds to a well-calibrated B1 field\nm0s::Real: Fractional size of the semi-solid pool; should be in range of 0 to 1\nR1f::Real: Longitudinal relaxation rate of the free pool in 1/seconds\nR2f::Real: Transversal relaxation rate of the free pool in 1/seconds\nRex::Real: Exchange rate between the two spin pools in 1/seconds\nR1s::Real: Longitudinal relaxation rate of the semi-solid pool in 1/seconds\nT2s::Real: Transversal relaxation time of the semi-solid pool in seconds\n\nOptional:\n\ngrad_list=(): Tuple that specifies the gradients that are calculated; the Tuple can either be empty () for no gradient, or contain any subset/order of grad_list=(grad_m0s(), grad_R1s(), grad_R2f(), grad_Rex(), grad_R1s(), grad_T2s(), grad_ω0(), grad_B1()); the derivative wrt. to apparent R1a = R1f = R1s can be calculated with grad_R1a()\nNcyc=2: The magnetization is initialized with thermal equilibrium and then performed Ncyc times and only the last cycle is stored. The default value is usually a good approximation for antiperiodic boundary conditions. Increase the number for higher precision at the cost of computation time.\noutput=:complexsignal: The default keywords triggers the function to output a complex-valued signal (xf + 1im yf); the keyword output=:realmagnetization triggers an output of the entire (real valued) vector [xf, yf, zf, xs, zs]\n\nExamples\n\njulia> calculatesignal_graham_ode(fill(π/2, 100), fill(5e-4, 100), 4e-3, 0, 1, 0.2, 0.3, 15, 20, 2, 10e-6)\n100×1 Matrix{ComplexF64}:\n   -0.00807345119183248 + 0.0im\n  0.0012686432905036744 - 0.0im\n  -0.006178694437249284 + 0.0im\n   0.002435865817889169 - 0.0im\n  -0.004437476277210456 + 0.0im\n  0.0035164646498608665 - 0.0im\n   -0.00283155425205221 + 0.0im\n   0.004523902250398101 - 0.0im\n -0.0013422299483480582 + 0.0im\n   0.005454562034859056 - 0.0im\n                        ⋮\n    0.01814822204095453 - 0.0im\n   0.017957696614147724 + 0.0im\n   0.018204860876662482 - 0.0im\n   0.018029363102617015 + 0.0im\n    0.01825782014256331 - 0.0im\n   0.018096168912466293 + 0.0im\n   0.018307337729978102 - 0.0im\n   0.018158444501175805 + 0.0im\n    0.01835363622965507 - 0.0im\n\njulia> calculatesignal_graham_ode(fill(π/2, 100), fill(5e-4, 100), 4e-3, 0, 1, 0.2, 0.3, 15, 20, 2, 10e-6; grad_list=(grad_R1f(), grad_T2s()), output=:realmagnetization)\n100×15 transpose(::Matrix{Float64}) with eltype Float64:\n -0.0080756    0.0   0.000643162  …   0.0   -10.4986  -323.634  0.0\n  0.00126867  -0.0  -0.00710692      -0.0   123.078   -316.358  0.0\n -0.00618067   0.0   0.00186482       0.0   -29.4458  -307.862  0.0\n  0.00243634  -0.0  -0.0052899       -0.0    94.1692  -300.821  0.0\n -0.00443746   0.0   0.00298646       0.0   -46.1422  -294.116  0.0\n  0.00351386  -0.0  -0.00361718   …  -0.0    68.262   -289.421  0.0\n -0.00282882   0.0   0.00402793       0.0   -61.0236  -285.242  0.0\n  0.00451808  -0.0  -0.00206741      -0.0    44.7888  -282.867  0.0\n -0.00133608   0.0   0.00499316       0.0   -74.4075  -280.79   0.0\n  0.00544896  -0.0  -0.00062663      -0.0    23.2536  -280.148  0.0\n  ⋮                               ⋱\n  0.0181755   -0.0   0.0179431       -0.0  -285.071   -337.48   0.0\n  0.0179911    0.0   0.0181963        0.0  -289.591   -337.634  0.0\n  0.0182343   -0.0   0.018019        -0.0  -286.777   -337.804  0.0\n  0.0180645    0.0   0.0182531        0.0  -290.964   -337.948  0.0\n  0.0182893   -0.0   0.0180898    …  -0.0  -288.383   -338.106  0.0\n  0.0181329    0.0   0.0183062        0.0  -292.261   -338.241  0.0\n  0.0183407   -0.0   0.0181559       -0.0  -289.895   -338.39   0.0\n  0.0181968    0.0   0.0183559        0.0  -293.488   -338.516  0.0\n  0.0183888   -0.0   0.0182175       -0.0  -291.318   -338.656  0.0\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.calculatesignal_linearapprox-NTuple{12, Any}","page":"API","title":"MRIgeneralizedBloch.calculatesignal_linearapprox","text":"calculatesignal_linearapprox(α, TRF, TR, ω0, B1, m0s, R1f, R2f, Rex, R1s, T2s, R2slT[; grad_list=(undef,), rfphase_increment=[π], m0=:periodic, output=:complexsignal, grad_moment = [i == 1 ? :spoiler_dual : :balanced for i ∈ eachindex(α)])\n\nCalculate the signal or magnetization evolution with the linear approximation of the generalized Bloch model assuming a super-Lorentzian lineshape.\n\nThe simulation assumes a sequence of rectangular RF-pulses with varying flip angles α and RF-pulse durations TRF, but a fixed repetition time TR. Further, it assumes balanced gradient moments.\n\nArguments\n\nα::Vector{Real}: Array of flip angles in radians\nTRF::Vector{Real}: Array of the RF-pulse durations in seconds\nTR::Real: Repetition time in seconds\nω0::Real: Off-resonance frequency in rad/s\nB1::Real: Normalized transmit B1 field, i.e. B1 = 1 corresponds to a well-calibrated B1 field\nm0s::Real: Fractional size of the semi-solid pool; should be in range of 0 to 1\nR1f::Real: Longitudinal relaxation rate of the free pool in 1/seconds\nR2f::Real: Transversal relaxation rate of the free pool in 1/seconds\nRex::Real: Exchange rate between the two spin pools in 1/seconds\nR1f::Real: Longitudinal relaxation rate of the semi-solid pool in 1/seconds\nT2s::Real: Transversal relaxation time of the semi-solid pool in seconds\nR2slT::NTuple{3, Function}: Tuple of three functions: R2sl(TRF, ω1, B1, T2s), dR2sldB1(TRF, ω1, B1, T2s), and R2sldT2s(TRF, ω1, B1, T2s). Can be generated with precompute_R2sl\n\nOptional Arguments:\n\ngrad_list=(undef,): Tuple that specifies the gradients that are calculated; the vector elements can either be undef for no gradient, or any subset/order of grad_list=(grad_m0s(), grad_R1f(), grad_R2f(), grad_Rex(), grad_R1s(), grad_T2s(), grad_ω0(), grad_B1()); the derivative wrt. to apparent R1a = R1f = R1s can be calculated with grad_R1a()\nrfphase_increment=[π]::Vector{Real}: Increment of the RF phase between consecutive pulses. The default value π, together with ω0=0 corresponds to the on-resonance condition. When more than one value is supplied, their resulting signal is stored along the second dimension of the output array.\nm0=:periodic: With the default keyword :periodic, the signal and their derivatives are calculated assuming m(0) = -m(T), where T is the duration of the RF-train. With the keyword :thermal, the magnetization m(0) is initialized with thermal equilibrium [xf, yf, zf, xs, zs] = [0, 0, 1-m0s, 0, m0s], followed by a α[1]/2 - TR/2 prep pulse; and with the keyword :IR, this initialization is followed an inversion pulse of duration TRF[1], (set α[1]=π) and a α[2]/2 - TR/2 prep pulse.\npreppulse=false: if true, a α/2 - TR/2 preparation is applied. In the case of m0=:IR, it is applied after the inversion pulse based on α[2], otherwise it is based on α[1]\noutput=:complexsignal: The default keywords triggers the function to output a complex-valued signal (xf + 1im yf); the keyword output=:realmagnetization triggers an output of the entire (real valued) vector [xf, yf, zf, xs, zs, 1]\ngrad_moment = [i == 1 ? :spoiler_dual : :balanced for i ∈ eachindex(α)]: Different types of gradient moments of each TR are possible (:balanced, :crusher, :spoiler_dual, :spoiler_prepulse). :balanced simulates a TR with all gradient moments nulled. :crusher assumes equivalent (non-zero) gradient moments before and simulates the refocussing path of the extended phase graph. :spoiler_prepulse nulls all transverse magnetization before the RF pulse, emulating an idealized FLASH. :spoiler_dual nulls all transverse magnetization before and after the RF pulse.\n\nExamples\n\njulia> R2slT = precompute_R2sl();\n\njulia> calculatesignal_linearapprox(range(0, π/2, 100), fill(5e-4, 100), 4e-3, 0, 1, 0.1, 1, 15, 30, 6.5, 10e-6, R2slT)\n100×1×1 Array{ComplexF64, 3}:\n[:, :, 1] =\n                  -0.0 - 0.0im\n  0.001973833347251853 + 0.0im\n 0.0021875654283707796 + 0.0im\n  0.004164448431837323 + 0.0im\n  0.004592307591163215 + 0.0im\n  0.006593922316239835 + 0.0im\n  0.007231933411392493 + 0.0im\n  0.009273791037577417 + 0.0im\n  0.010115002530621257 + 0.0im\n  0.012207846285906878 + 0.0im\n                       ⋮\n   0.13200818588649144 + 0.0im\n   0.13125741802520272 + 0.0im\n   0.13046553069014488 + 0.0im\n    0.1296140698825093 + 0.0im\n   0.12872449007846418 + 0.0im\n     0.127780274577417 + 0.0im\n   0.12680111371298092 + 0.0im\n   0.12577221756507703 + 0.0im\n   0.12471167167688699 + 0.0im\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.dG_o_dT2s_x_T2s_gaussian-Tuple{Any}","page":"API","title":"MRIgeneralizedBloch.dG_o_dT2s_x_T2s_gaussian","text":"dG_o_dT2s_x_T2s_gaussian(κ)\n\nEvaluate the derivative of Green's function, corresponding to a Gaussian lineshape, wrt. T2s at κ = (t-τ)/T2s and multiply it by T2s.\n\nThe multiplication is added so that the function merely depends on κ = (t-τ)/T2s. The actual derivative is given by dG_o_dT2s_x_T2s_gaussian((t-τ)/T2s)/T2s.\n\nExamples\n\njulia> t = 100e-6;\n\njulia> τ = 0;\n\njulia> T2s = 10e-6;\n\njulia> dGdT2s = dG_o_dT2s_x_T2s_gaussian((t-τ)/T2s)/T2s\n1.9287498479639177e-15\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.dG_o_dT2s_x_T2s_lorentzian-Tuple{Any}","page":"API","title":"MRIgeneralizedBloch.dG_o_dT2s_x_T2s_lorentzian","text":"dG_o_dT2s_x_T2s_lorentzian(κ)\n\nEvaluate the derivative of Green's function, corresponding to a Lorentzian lineshape, wrt. T2s at κ = (t-τ)/T2s and multiply it by T2s.\n\nThe multiplication is added so that the function merely depends on κ = (t-τ)/T2s. The actual derivative is given by dG_o_dT2s_x_T2s_lorentzian((t-τ)/T2s)/T2s.\n\nExamples\n\njulia> t = 100e-6;\n\njulia> τ = 0;\n\njulia> T2s = 10e-6;\n\njulia> dGdT2s = dG_o_dT2s_x_T2s_lorentzian((t-τ)/T2s)/T2s\n45.39992976248485\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.dG_o_dT2s_x_T2s_superlorentzian-Tuple{Any}","page":"API","title":"MRIgeneralizedBloch.dG_o_dT2s_x_T2s_superlorentzian","text":"dG_o_dT2s_x_T2s_superlorentzian(κ)\n\nEvaluate the derivative of Green's function, corresponding to a super-Lorentzian lineshape, wrt. T2s at κ = (t-τ)/T2s and multiply it by T2s.\n\nThe multiplication is added so that the function merely depends on κ = (t-τ)/T2s. The actual derivative is given by dG_o_dT2s_x_T2s_superlorentzian((t-τ)/T2s)/T2s.\n\nExamples\n\njulia> t = 100e-6;\n\njulia> τ = 0;\n\njulia> T2s = 10e-6;\n\njulia> dGdT2s = dG_o_dT2s_x_T2s_superlorentzian((t-τ)/T2s)/T2s\n15253.09503367097\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.fit_gBloch-Union{Tuple{T}, Tuple{Any, Vector{T}, Vector{T}, Any}} where T<:Real","page":"API","title":"MRIgeneralizedBloch.fit_gBloch","text":"qM = fit_gBloch(data, α, TRF, TR;\n    reM0 = (-Inf,   1,  Inf),\n    imM0 = (-Inf,   0,  Inf),\n    m0s  = (   0, 0.2,    1),\n    R1f  = (   0, 0.3,  Inf),\n    R2f  = (   0,  15,  Inf),\n    Rex  = (   0,  20,  Inf),\n    R1s  = (   0,   3,  Inf),\n    T2s  = (8e-6,1e-5,12e-6),\n    ω0   = (-Inf,   0,  Inf),\n    B1   = (   0,   1,  1.5),\n    R1a  = (   0, 0.7,  Inf),\n    u=1,\n    fit_apparentR1=false,\n    show_trace=false,\n    maxIter=100,\n    R2slT = precompute_R2sl(TRF_min=minimum(TRF), TRF_max=maximum(TRF), T2s_min=minimum(T2s), T2s_max=maximum(T2s), ω1_max=maximum(α ./ TRF), B1_max=maximum(B1)),\n    )\n\nFit the generalized Bloch model for a train of RF pulses and balanced gradient moments to data.\n\nArguments\n\ndata::Vector{Number}: Array of measured data points, either in the time or a compressed domain (cf. u)\nα::Vector{Real}: Array of flip angles in radians; can also be a Vector{Vector{Real}} which simulates each RF pattern and concatenates the signals of each simulation\nTRF::Vector{Real}: Array of the RF-pulse durations in seconds (or Vector{Vector{Real}} if α::Vector{Vector{Real}}`)\nTR::Real: Repetition time in seconds\nω0::Real: Off-resonance frequency in rad/s\n\nOptional Keyword Arguments:\n\nreM0::Union{Real, Tuple{Real, Real, Real}}: Real part of M0; either fixed value as a Real or fit limits thereof as a Tuple with the elements (min, start, max)\nimM0::Union{Real, Tuple{Real, Real, Real}}: Imaginary part of M0; either fixed value as a Real or fit limits thereof as a Tuple with the elements (min, start, max)\nm0s::Union{Real, Tuple{Real, Real, Real}}: Fractional size of the semi-solid pool (should be in range of 0 to 1); either fixed value as a Real or fit limits thereof as a Tuple with the elements (min, start, max)\nR1f::Union{Real, Tuple{Real, Real, Real}}: Longitudinal relaxation rate of the free pool in 1/s; only used in combination with fit_apparentR1=false; either fixed value as a Real or fit limits thereof as a Tuple with the elements (min, start, max)\nR2f::Union{Real, Tuple{Real, Real, Real}}: Transversal relaxation rate of the free pool in 1/s; either fixed value as a Real or fit limits thereof as a Tuple with the elements (min, start, max)\nRex::Union{Real, Tuple{Real, Real, Real}}: Exchange rate between the two spin pools in 1/s; either fixed value as a Real or fit limits thereof as a Tuple with the elements (min, start, max)\nR1s::Union{Real, Tuple{Real, Real, Real}}: Longitudinal relaxation rate of the semi-solid pool in 1/s; only used in combination with fit_apparentR1=false; either fixed value as a Real or fit limits thereof as a Tuple with the elements (min, start, max)\nT2s::Union{Real, Tuple{Real, Real, Real}}: Transversal relaxation time of the semi-solid pool in s; either fixed value as a Real or fit limits thereof as a Tuple with the elements (min, start, max)\nω0::Union{Real, Tuple{Real, Real, Real}}: Off-resonance frequency in rad/s; either fixed value as a Real or fit limits thereof as a Tuple with the elements (min, start, max)\nB1::Union{Real, Tuple{Real, Real, Real}}: Normalized transmit B1 field, i.e. B1 = 1 corresponds to a well-calibrated B1 field; either fixed value as a Real or fit limits thereof as a Tuple with the elements (min, start, max)\nR1a::Union{Real, Tuple{Real, Real, Real}}: Apparent longitudinal relaxation rate in 1/s; only used in combination with fit_apparentR1=true; either fixed value as a Real or fit limits thereof as a Tuple with the elements (min, start, max)\nu::Union{Number, Matrix}: Compression matrix that transform the simulated time series to a series of coefficients. Set to 1 by default to enable the fitting in the time domain\nfit_apparentR1::Bool: Switch between fitting R1f and R1s separately (false; default) and an apparent R1a = R1f = R1s (true)\nshow_trace::Bool: print output during the optimization; default=false\nmaxIter::Int: Maximum number of iteration; default=100\nR2slT::NTuple{3, Function}: Tuple of three functions: R2sl(TRF, ω1, B1, T2s), dR2sldB1(TRF, ω1, B1, T2s), and R2sldT2s(TRF, ω1, B1, T2s). By default generated with precompute_R2sl\n\nExamples\n\nc.f. Non-Linear Least Square Fitting\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.get_bounded_ω1_TRF-Tuple{Any}","page":"API","title":"MRIgeneralizedBloch.get_bounded_ω1_TRF","text":"ω1, TRF = get_bounded_ω1_TRF(x)\n\nTransform a vector of length 2Npulses with values in the range [-Inf, Inf] into two vectors of length Npulses, which describe the bounded controls ω1 and TRF.\n\nArguments\n\nx::Vector{Real}: Control vector of length = 2Npulses with values in the range [-Inf, Inf]\n\nOptional Keyword Arguments:\n\nω1_min::Vector{Real}: elementwise lower bound for ω1 in rad/s\nω1_max::Vector{Real}: elementwise upper bound for ω1 in rad/s\nTRF_min::Vector{Real}: elementwise lower bound for TRF in s\nTRF_max::Vector{Real}: elementwise bound for TRF in s\n\nExamples\n\njulia> x = repeat(range(-1000.0, 1000.0, 100), 2);\n\njulia> ω1, TRF = MRIgeneralizedBloch.get_bounded_ω1_TRF(x)\n([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  6283.185307179586, 6283.185307179586, 6283.185307179586, 6283.185307179586, 6283.185307179586, 6283.185307179586, 6283.185307179586, 6283.185307179586, 6283.185307179586, 6283.185307179586], [0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001  …  0.0005, 0.0005, 0.0005, 0.0005, 0.0005, 0.0005, 0.0005, 0.0005, 0.0005, 0.0005])\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.graham_saturation_rate_single_frequency-Tuple{Function, Function, Real, Real}","page":"API","title":"MRIgeneralizedBloch.graham_saturation_rate_single_frequency","text":"graham_saturation_rate_single_frequency(lineshape, ω1, TRF, Δω)\n\nCalculate saturation rate (in units of 1/s) according to Graham's single frequency approximation.\n\nArguments\n\nlineshape::Function: as a function of ω₀ (in rad/s). Supply, e.g., the anonymous function ω₀ -> lineshape_superlorentzian(ω₀, T2s). Note that the integral over the lineshape has to be 1.\nω1::Function: ω1 in rad/s as a function of time (in units of s) where the puls shape is defined for t ∈ [0,TRF]\nTRF::Real: duration of the RF pulse in s\nΔω::Real: offset frequency in rad/s\n\nExamples\n\njulia> using SpecialFunctions\n\njulia> T2s = 10e-6;\n\njulia> α = π;\n\njulia> TRF = 100e-6;\n\njulia> NSideLobes = 1;\n\njulia> ω1(t) = sinc(2(NSideLobes+1) * t/TRF - (NSideLobes+1)) * α / (sinint((NSideLobes+1)π) * TRF/π / (NSideLobes+1));\n\njulia> Δω = 200;\n\njulia> graham_saturation_rate_single_frequency(ω₀ -> lineshape_superlorentzian(ω₀, T2s), ω1, TRF, Δω)\n419969.3376658947\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.graham_saturation_rate_spectral-Tuple{Function, Real, Real, Real}","page":"API","title":"MRIgeneralizedBloch.graham_saturation_rate_spectral","text":"graham_saturation_rate_spectral(lineshape, ω1, TRF, Δω)\n\nCalculate saturation rate (in units of 1/s) according to Graham's spectral model.\n\nArguments\n\nlineshape::Function: as a function of ω₀ (in rad/s). Supply, e.g., the anonymous function ω₀ -> lineshape_superlorentzian(ω₀, T2s). Note that the integral over the lineshape has to be 1.\nω1::Function: ω1 in rad/s as a function of time (in units of s) where the puls shape is defined for t ∈ [0,TRF]\nTRF::Real: duration of the RF pulse in s\nΔω::Real: offset frequency in rad/s\n\nExamples\n\njulia> using SpecialFunctions\n\njulia> T2s = 10e-6;\n\njulia> α = π;\n\njulia> TRF = 100e-6;\n\njulia> NSideLobes = 1;\n\njulia> ω1(t) = sinc(2(NSideLobes+1) * t/TRF - (NSideLobes+1)) * α / (sinint((NSideLobes+1)π) * TRF/π / (NSideLobes+1));\n\njulia> Δω = 200;\n\njulia> graham_saturation_rate_spectral(ω₀ -> lineshape_superlorentzian(ω₀, T2s), ω1, TRF, Δω)\n56135.388046022905\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.greens_gaussian-Tuple{Any}","page":"API","title":"MRIgeneralizedBloch.greens_gaussian","text":"greens_gaussian(κ)\n\nEvaluate the Green's function corresponding to a Gaussian lineshape at κ = (t-τ)/T2s.\n\nExamples\n\njulia> t = 100e-6;\n\njulia> τ = 0;\n\njulia> T2s = 10e-6;\n\njulia> greens_gaussian((t-τ)/T2s)\n1.9287498479639178e-22\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.greens_lorentzian-Tuple{Any}","page":"API","title":"MRIgeneralizedBloch.greens_lorentzian","text":"greens_lorentzian(κ)\n\nEvaluate the Green's function corresponding to a Lorentzian lineshape at κ = (t-τ)/T2s.\n\nExamples\n\njulia> t = 100e-6;\n\njulia> τ = 0;\n\njulia> T2s = 10e-6;\n\njulia> greens_lorentzian((t-τ)/T2s)\n4.5399929762484854e-5\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.greens_superlorentzian-Tuple{Any}","page":"API","title":"MRIgeneralizedBloch.greens_superlorentzian","text":"greens_superlorentzian(κ)\n\nEvaluate the Green's function corresponding to a super-Lorentzian lineshape at κ = (t-τ)/T2s.\n\nExamples\n\njulia> t = 100e-6;\n\njulia> τ = 0;\n\njulia> T2s = 10e-6;\n\njulia> greens_superlorentzian((t-τ)/T2s)\n0.1471246868094442\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.hamiltonian_linear-NTuple{10, Any}","page":"API","title":"MRIgeneralizedBloch.hamiltonian_linear","text":"hamiltonian_linear(ω1, B1, ω0, T, m0s, R1f, R2f, Rex, R1s, R2s[, dR2sdT2s, dR2sdB1, grad_type])\n\nCalculate the hamiltonian of the linear approximation of the generalized Bloch model.\n\nIf no gradient is supplied, it returns a 6x6 (static) matrix with the dimensions (in this order) [xf, yf, zf, xs, zs, 1]; the attached 1 is a mathematical trick to allow for T_1 relaxation to a non-zero thermal equilibrium. If a gradient is supplied, it returns a 11x11 (static) matrix with the dimensions (in this order) [xf, yf, zf, xs, zs, dxf/dθ, dyf/dθ, dzf/dθ, dxs/dθ, dzs/dθ,  1], where θ is the parameter specified by grad_type\n\nArguments\n\nω1::Real: Rabi frequency in rad/s (rotation about the y-axis)\nB1::Real: Normalized transmit B1 field, i.e. B1 = 1 corresponds to a well-calibrated B1 field\nω0::Real: Larmor (or off-resonance) frequency in rad/s (rotation about the z-axis)\nT::Real: Time in seconds; this can, e.g., be the RF-pulse duration, or the time of free precession with ω1=0\nm0s::Real: Fractional size of the semi-solid pool; should be in range of 0 to 1\nR1f::Real: Longitudinal relaxation rate of the free pool in 1/seconds\nR2f::Real: Transversal relaxation rate of the free pool in 1/seconds\nRex::Real: Exchange rate between the two spin pools in 1/seconds\nR1s::Real: Longitudinal relaxation rate of the semi-solid pool in 1/seconds\nR2s::Real: Transversal relaxation rate of the semi-solid pool in 1/seconds; this number can be calculated with the first function returned by precompute_R2sl to implement the linear approximation described in the generalized Bloch paper\n\nOptional Arguments:\n\ndR2sdT2s::Real: Derivative of linearized R2sl wrt. the actual T2s; only required if grad_type = grad_T2s(); this number can be calculated with the second function returned by precompute_R2sl\ndR2sdB1::Real: Derivative of linearized R2sl wrt. B1; only required if grad_type = grad_B1(); this number can be calculated with the third function returned by precompute_R2sl\ngrad_type::grad_param: grad_m0s(), grad_R1f(), grad_R1s(), grad_R2f(), grad_Rex(), grad_T2s(), grad_ω0(), or grad_B1(); create one hamiltonian for each desired gradient\n\nExamples\n\njulia> α = π;\n\njulia> T = 500e-6;\n\njulia> ω1 = α/T;\n\njulia> B1 = 1;\n\njulia> ω0 = 0;\n\njulia> m0s = 0.1;\n\njulia> R1f = 1;\n\njulia> R2f = 15;\n\njulia> Rex = 30;\n\njulia> R1s = 6.5;\n\njulia> R2s = 1e5;\n\njulia> m0 = [0, 0, 1-m0s, 0, m0s, 1];\n\njulia> (xf, yf, zf, xs, zs, _) = exp(hamiltonian_linear(ω1, B1, ω0, T, m0s, R1f, R2f, Rex, R1s, R2s)) * m0\n6-element StaticArraysCore.SVector{6, Float64} with indices SOneTo(6):\n  0.0010647535813058293\n  0.0\n -0.8957848274535014\n  0.005126529591877105\n  0.08122007142111888\n  1.0\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.interpolate_greens_function-Tuple{Any, Any, Any}","page":"API","title":"MRIgeneralizedBloch.interpolate_greens_function","text":"interpolate_greens_function(f, κmin, κmax)\n\nInterpolate the Green's function f in the range between κmin and κmax.\n\nThe interpolation uses the ApproxFun.jl package that incorporates Chebyshev polynomials and ensures an approximation to machine precision.\n\nExamples\n\njulia> t = 100e-6;\n\njulia> τ = 0;\n\njulia> T2s = 10e-6;\n\njulia> greens_superlorentzian((t-τ)/T2s)\n0.1471246868094442\n\njulia> Gint = interpolate_greens_function(greens_superlorentzian, 0, 20);\n\njulia> Gint((t-τ)/T2s)\n0.14712468680944413\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.precompute_R2sl-Tuple{}","page":"API","title":"MRIgeneralizedBloch.precompute_R2sl","text":"precompute_R2sl([;TRF_min=100e-6, TRF_max=500e-6, T2s_min=5e-6, T2s_max=21e-6, ω1_max=π/TRF_max, B1_max=1.4, greens=greens_superlorentzian])\n\nPre-compute and interpolate the linearized R2sl(TRF, α, B1, T2s) and its derivatives dR2sldB1(TRF, α, B1, T2s), R2sldT2s(TRF, α, B1, T2s) etc. in the range specified by the arguments.\n\nThe function solves the generalized Bloch equations of an isolated semi-solid pool for values in the specified range, calculates the linearized R2sl that minimizes the error of zs at the end of the RF-pulse, and interpolates between the different samples.\n\nOptional Arguments:\n\nTRF_min::Real: lower bound of the RF-pulse duration range in seconds\nTRF_max::Real: upper bound of the RF-pulse duration range in seconds\nT2s_min::Real: lower bound of the T2s range in seconds\nT2s_max::Real: upper bound of the T2s range in seconds\nω1_max::Real: upper bound of the Rabi frequency ω1, the default is the frequency of a 500μs long π-pulse\nB1_max::Real: upper bound of the B1 range, normalized so that B1 = 1 corresponds to a perfectly calibrated RF field\ngreens=greens_superlorentzian: Greens function in the form G(κ) = G((t-τ)/T2s). This package supplies the three Greens functions greens=greens_superlorentzian (default), greens=greens_lorentzian, and greens=greens_gaussian\n\nExamples\n\njulia> R2slT = precompute_R2sl();\n\n\njulia> R2sl, dR2sldB1, R2sldT2s, _ = precompute_R2sl(TRF_min=100e-6, TRF_max=500e-6, T2s_min=5e-6, T2s_max=15e-6, ω1_max=π/500e-6, B1_max=1.4, greens=greens_gaussian);\n\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.second_order_α!-NTuple{4, Any}","page":"API","title":"MRIgeneralizedBloch.second_order_α!","text":"F = second_order_α!(grad_ω1, grad_TRF, ω1, TRF; λ=1, grad_moment=[i[1] == 1 ? :spoiler_dual : :balanced for i ∈ CartesianIndices(ω1)])\n\nCalculate second order penalty of variations of the flip angle α and adds in place to the gradients.\n\nArguments\n\ngrad_ω1::Vector{Real}: Gradient of control, which will be added in place (matrix if more than 1 sequence are optimized)\ngrad_TRF::Vector{Real}: Gradient of control, which will be added in place (matrix if more than 1 sequence are optimized)\nω1::Vector{Real}: Control vector (matrix if more than 1 sequence are optimized)\nTRF::Vector{Real}: Control vector (matrix if more than 1 sequence are optimized)\n\nOptional Keyword Arguments:\n\nλ::Real: regularization parameter\ngrad_moment = [i[1] == 1 ? :spoiler_dual : :balanced for i ∈ CartesianIndices(ω1)]: Different types of gradient moments of each TR are possible (:balanced, :spoilerdual, :crusher). Skip :crusher and :spoilerdual TRs second order penalty\n\nExamples\n\njulia> ω1 = range(0, 2000π, 100);\n\njulia> TRF = range(100e-6, 500e-6, 100);\n\njulia> grad_ω1 = similar(ω1);\n\njulia> grad_TRF = similar(ω1);\n\njulia> F = MRIgeneralizedBloch.second_order_α!(grad_ω1, grad_TRF, ω1, TRF; λ = 1e-3)\n0.005015194549476384\n\n\n\n\n\n","category":"method"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"(Image: )","category":"section"},{"location":"build_literate/OCT/#Optimal-Control","page":"Optimal Control","title":"Optimal Control","text":"This section provides a brief introduction to the package's interface for sequence optimization. We use the Cramer-Rao bound (CRB) to assess a sequence's performance and optimize the amplitudes (ω_1) and durations (T_textRF) of RF-pulses to reduce the CRB, assuming a Balanced Hybrid-State Free Precession Pulse Sequence. For computational efficiency, the derivatives of the CRB wrt. ω_1 and T_textRF are calculated with the adjoint state method common in the optimal control literature.\n\nFor this tutorial, we use the following packages:\n\nusing MRIgeneralizedBloch\nusing LinearAlgebra\nBLAS.set_num_threads(1) # single threaded is faster in this case\nusing Optim             # provides the optimization algorithm\nusing Plots\nplotlyjs(bg = RGBA(31/255,36/255,36/255,1.0), ticks=:native); #hide\nnothing #hide\n\nHere, we optimize the pulse sequence for a predefined set of parameters:\n\nm0s = 0.15\nR1f = 0.5   # 1/s\nR2f = 15    # 1/s\nRex = 30    # 1/s\nR1s = 3     # 1/s\nT2s = 10e-6 # s\nω0 = 0      # rad/s\nB1 = 1;     # in units of B1_nominal\nnothing #hide\n\nand we optimize\n\nNpulses = 200;\nnothing #hide\n\npulses, spaced\n\nTR = 3.5e-3; # s\nnothing #hide\n\napart. The cyle duration of\n\nNpulses * TR\n\nseconds is shorter than the optimal duration, which is in the range of 4-10s. We here use a small Npulses to speed up the computations. The Linear Approximation of the generalized Bloch model is precomputed with\n\nR2slT = precompute_R2sl();\nnothing #hide\n\nIn the calculation of the CRB, we account for following gradients:\n\ngrad_list = (grad_m0s(), grad_R1f(), grad_R2f(), grad_Rex(), grad_R1s(), grad_T2s(), grad_ω0(), grad_B1());\nnothing #hide\n\nand we sum up the CRB of all parameters, weighted by the following vector:\n\nweights = transpose([0, 1, 0, 0, 0, 0, 0, 0, 0]);\nnothing #hide\n\nNote that the vector weights has one more entry compared to the grad_list vector, as the first derivative is always wrt. M_0, regardless of grad_list. Here, we only optimize for the CRB of m_0^s, while accounting for a fit of all 9 model parameters.\n\nWe take some initial guess for the pulse train:\n\nα = abs.(sin.((1:Npulses) * 2π/Npulses));\nnothing #hide\n\ninitialize with a constant TRF = 300μs:\n\nTRF = fill(300e-6, length(α));\nnothing #hide\n\nand define the first RF pulse as a 500μs inversion pulse by modifying vectors accordingly and by defining that crushers are played out before and after the inversion pulse:\n\nα[1] = π\nTRF[1] = 500e-6\ngrad_moment = [i == 1 ? :crusher : :balanced for i ∈ eachindex(α)];\nnothing #hide\n\nWe note that inversion pulses are not optimized by this toolbox. We calculate the initial ω_1\n\nω1 = α ./ TRF;\nnothing #hide\n\nand plot the initial control:\n\np1 = plot(TR*(1:Npulses), α ./ π, ylabel=\"α/π\")\np2 = plot(TR*(1:Npulses), 1e6TRF, ylim=(0, 1e3), xlabel=\"t (s)\", ylabel=\"TRF (μs)\")\np = plot(p1, p2, layout=(2, 1), legend=:none)\nMain.HTMLPlot(p) #hide\n\nWith above defined weights, the function MRIgeneralizedBloch.CRB_gradient_OCT returns the CRB\n\nCRBm0s, grad_ω1, grad_TRF = MRIgeneralizedBloch.CRB_gradient_OCT(ω1, TRF, TR, ω0, B1, m0s, R1f, R2f, Rex, R1s, T2s, R2slT, grad_list, weights; grad_moment)\nCRBm0s\n\nalong with the gradients:\n\np1 = plot(TR*(1:Npulses), grad_ω1  .* ((-1) .^ (1:Npulses)), ylabel=\"∂CRB(m0s) / ∂ω1 (s/rad)\")\np2 = plot(TR*(1:Npulses), grad_TRF .* ((-1) .^ (1:Npulses)), ylabel=\"∂CRB(m0s) / ∂TRF (1/s)\", xlabel=\"t (s)\")\np = plot(p1, p2, layout=(2, 1), legend=:none)\nMain.HTMLPlot(p) #hide\n\nNote that we remove the oscillating nature of the gradient for the display.\n\nIn this example, we limit the control to the following bounds\n\nω1_min  = fill(0,      length(ω1))  # rad/s\nω1_max  = fill(2e3π,   length(ω1))  # rad/s\nTRF_min = fill(100e-6, length(ω1))  # s\nTRF_max = fill(500e-6, length(ω1)); # s\nnothing #hide\n\nand the function MRIgeneralizedBloch.bound_ω1_TRF! modifies ω1 and TRF to comply with these bounds and returns a single vector in the range [-Inf, Inf] that relates to the bounded control by a tanh transformation:\n\nx0 = MRIgeneralizedBloch.bound_ω1_TRF!(ω1, TRF; ω1_min, ω1_max, TRF_min, TRF_max)\n\nFurther, we initialize a gradient of the same length:\n\nG = similar(x0);\nnothing #hide\n\nand define the cost function:\n\nfunction fg!(F, G, x)\n    ω1, TRF = MRIgeneralizedBloch.get_bounded_ω1_TRF(x; ω1_min, ω1_max, TRF_min, TRF_max)\n\n    F, grad_ω1, grad_TRF = MRIgeneralizedBloch.CRB_gradient_OCT(ω1, TRF, TR, ω0, B1, m0s, R1f, R2f, Rex, R1s, T2s, R2slT, grad_list, weights; grad_moment)\n    F = abs(F)\n\n    F += MRIgeneralizedBloch.second_order_α!(grad_ω1, grad_TRF, ω1, TRF; grad_moment, λ=1e4)\n    F += MRIgeneralizedBloch.RF_power!(grad_ω1, grad_TRF, ω1, TRF; λ=1e-3, Pmax=3e6, TR)\n    F += MRIgeneralizedBloch.TRF_TV!(grad_TRF, TRF; grad_moment, λ=1e3)\n\n    MRIgeneralizedBloch.apply_bounds_to_grad!(G, x, grad_ω1, grad_TRF; ω1_min, ω1_max, TRF_min, TRF_max)\n    return F\nend;\nnothing #hide\n\nWe perform the optimization with the package Optim.jl, which requires the cost function fg!(F, G, x) to take the cost, the gradient, and the control as input variables and to over-write the gradient in place. The cost function calculates the gradient of the CRB with above described optimal control code and we, further, add some regularization terms: MRIgeneralizedBloch.second_order_α! penalizes the curvature of α, which smoothes the flip angle train and helps ensuring the hybrid state conditions. The penalty MRIgeneralizedBloch.RF_power! penalizes the power deposition of the RF-pulse train if Sigma_i(ω_1^2i  T_textRFi)  T_textcycle  P_max and helps with compliance to safety limits. Assuming a reasonable λ, the optimization will converge to an average RF-power deposition equal to or less than Pmax in units of (rad/s)². Heuristically, the value Pmax=3e6 (rad/s)² proofed to be a reasonable choice for 3T systems. The penalty MRIgeneralizedBloch.TRF_TV! penalizes fast fluctuations of T_textRF. This penalty is justified by the knowledge that fluctuations of the control have negligible effect if they are fast compared to the biophysical time constants. We note, however, that this penalty is not required and rather ensure beauty of the result and speeds up convergence.\n\nWith all this in place, we can start the actual optimization\n\nresult = optimize(Optim.only_fg!(fg!), # cost function\n    x0,                                # initialization\n    BFGS(),                            # algorithm\n    Optim.Options(\n        iterations=10_000,             # larger number as we use a time limit\n        time_limit=(15*60),            # in seconds\n        )\n    )\n\nAfter transforming the optimized control back into the space of bounded ω_1 and T_textRF values\n\nω1, TRF = MRIgeneralizedBloch.get_bounded_ω1_TRF(result.minimizer; ω1_min, ω1_max, TRF_min, TRF_max)\nα = ω1 .* TRF;\nnothing #hide\n\nwe analyze the CRB(m0s):\n\nCRBm0s, grad_ω1, grad_TRF = MRIgeneralizedBloch.CRB_gradient_OCT(ω1, TRF, TR, ω0, B1, m0s, R1f, R2f, Rex, R1s, T2s, R2slT, grad_list, weights; grad_moment)\nCRBm0s\n\nand observe a substantial reduction. Further, we plot the optimized control:\n\np1 = plot(TR*(1:Npulses), α ./ π, ylabel=\"α/π\")\np2 = plot(TR*(1:Npulses), 1e6TRF, ylim=(0, 1e3), xlabel=\"t (s)\", ylabel=\"TRF (μs)\")\np = plot(p1, p2, layout=(2, 1), legend=:none)\nMain.HTMLPlot(p) #hide\n\nTo further analyze the results, we can calculate and plot all magnetization components:\n\nm = calculatesignal_linearapprox(α, TRF, TR, ω0, B1, m0s, R1f, R2f, Rex, R1s, T2s, R2slT; output=:realmagnetization)\nm = vec(m)\n\nxf = [m[i][1] for i ∈ eachindex(m)]\nyf = [m[i][2] for i ∈ eachindex(m)]\nzf = [m[i][3] for i ∈ eachindex(m)]\nxs = [m[i][4] for i ∈ eachindex(m)]\nzs = [m[i][5] for i ∈ eachindex(m)]\n\np = plot(xlabel=\"t (s)\", ylabel=\"m (normalized)\")\nplot!(p, TR*(1:Npulses), xf ./(1-m0s), label=\"xᶠ\")\nplot!(p, TR*(1:Npulses), yf ./(1-m0s), label=\"yᶠ\")\nplot!(p, TR*(1:Npulses), zf ./(1-m0s), label=\"zᶠ\")\nplot!(p, TR*(1:Npulses), xs ./   m0s , label=\"xˢ\")\nplot!(p, TR*(1:Npulses), zs ./   m0s , label=\"zˢ\")\nMain.HTMLPlot(p) #hide\n\nAnd we can also plot the dynamics of the free spin pool on the Bloch sphere:\n\np = plot(xf, zf, xlabel=\"xf\", ylabel=\"zf\", framestyle = :zerolines, legend=:none)\nMain.HTMLPlot(p) #hide\n\nAs yᶠ is close to zero in this particular case, we neglect it in this 2D plot.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"(Image: )","category":"section"},{"location":"build_literate/Analyze_NMR_PreSat_Data/#Continuous-Wave-Saturation-Experiments","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"The following code analyzes data from a steady-state experiment similar to the original work of Henkelman et al. In this experiment, the magnetization of the coupled spin system is saturated with off-resonant continuous waves of the exponentially spaced frequencies:\n\nΔ = exp.(range(log(0.01e3), log(100e3), length=20)) * 2π # rad/s\n\nand the amplitudes:\n\nω1_dB = -60:5:-5 # dB\nω1 = @. 10^(ω1_dB / 20) * π / 2 / 11.4e-6 # rad/s\n\nThe waves were applied for 7 seconds to ensure a steady state. Thereafter, the magnetization was excited with a π/2-pulse and an FID was acquired. The repetition times was 30s to ensure full recovery to thermal equilibrium.\n\nWe fit the data with Henkelman's closed form solution to this steady-state problem while assuming a Lorentzian lineshape for the free spin pool, and different lineshapes for the semi-solid spin pool:\n\ng_Lorentzian(Δ, T2) = T2 / π / (1 + (T2 * Δ)^2)\ng_Gaussian(Δ, T2) = T2 / sqrt(2π) * exp(-(T2 * Δ)^2 / 2)\ng_superLorentzian(Δ, T2) = T2 * sqrt(2 / π) * quadgk(ct -> exp(- 2 *  (T2 * Δ / (3 * ct^2 - 1))^2) / abs(3 * ct^2 - 1), 0, sqrt(1 / 3), 1)[1];\nnothing #hide\n\nFor this data analysis we need the following packages:\n\nusing MRIgeneralizedBloch\nusing QuadGK\nusing LsqFit\nusing LinearAlgebra\nusing Statistics\nusing Printf\nusing Plots\nplotlyjs(bg=RGBA(31 / 255, 36 / 255, 36 / 255, 1.0), ticks=:native); # hide\nnothing #hide\n\nThe raw data is stored in a separate github repository and the following functions return the URL to the individual files:\n\nMnCl2_data(ω1_dB) = string(\"https://github.com/JakobAsslaender/MRIgeneralizedBloch_NMRData/blob/main/20210419_1mM_MnCl2/ja_PreSat_v2%20(\", ω1_dB, \")/1/data.2d?raw=true\")\nBSA_data(ω1_dB)   = string(\"https://github.com/JakobAsslaender/MRIgeneralizedBloch_NMRData/blob/main/20210416_15%25BSA_2ndBatch/ja_PreSat_v2%20(\", ω1_dB, \")/1/data.2d?raw=true\");\nnothing #hide\n\nwhich can be loaded with functions implemented in this file:\n\ninclude(string(pathof(MRIgeneralizedBloch), \"/../../docs/src/load_NMR_data.jl\"));\nnothing #hide\n\nWe store the off-resonance frequencies and wave amplitudes in a single matrix for convenience:\n\nx = zeros(Float64, length(ω1) * length(Δ), 2)\nx[:,1] = repeat(Δ, length(ω1))\nx[:,2] = vec(repeat(ω1, 1, length(Δ))');\nnothing #hide","category":"section"},{"location":"build_literate/Analyze_NMR_PreSat_Data/#MnCl_2-Sample","page":"Continuous Wave Saturation Experiments","title":"MnCl_2 Sample","text":"We load the first data point of each FID:\n\nM = zeros(Float64, length(Δ), length(ω1))\nfor i = 1:length(ω1_dB)\n    M[:,i] = load_first_datapoint(MnCl2_data(ω1_dB[i]); set_phase=:abs)\nend\nM ./= maximum(M);\nnothing #hide\n\nIn contrast to the inversion-recovery experiment, the phase of the signal was not stable. Therefore, we took the absolute value of the signal by setting the flag set_phase=:abs.\n\nThe MnCl_2-data can be described with a single compartment model:\n\nfunction single_compartment_model(x, p)\n    (m0, R1, T2) = p\n\n    Δ  = @view x[:,1]\n    ω1 = @view x[:,2]\n\n    Rrf = @. π * ω1^2 * g_Lorentzian(Δ, T2)\n    m = @. m0 * R1 / (R1 + Rrf)\n    return m\nend;\nnothing #hide\n\n(cf. Eqs. (14) and (15) in the paper).\n\nAs this model is merely a function of the relaxation times T₁ and T₂, we forgo a fitting routine and use the estimates from the Inversion Recovery Experiments instead:\n\nR1 = 1.479 # 1/s\nT2 = 0.075 # s\nnothing # hide\n\nVisually, this model describes the data well:\n\np = plot(xlabel=\"Δ [rad/s]\", ylabel=\"M / max(M)\", xaxis=:log, legend=:none)\n[scatter!(p, Δ, M[:,i], color=i) for i=1:length(ω1)]\n[plot!(p, Δ, reshape(single_compartment_model(x, [1,R1,T2]), length(Δ), length(ω1))[:,i], color=i) for i=1:length(ω1)]\nMain.HTMLPlot(p) #hide","category":"section"},{"location":"build_literate/Analyze_NMR_PreSat_Data/#Bovine-Serum-Albumin-Sample","page":"Continuous Wave Saturation Experiments","title":"Bovine Serum Albumin Sample","text":"We acquired the same data for the BSA sample, which we load:\n\nfor i = 1:length(ω1_dB)\n    M[:,i] = load_first_datapoint(BSA_data(ω1_dB[i]); set_phase=:abs)\nend\nM ./= maximum(M);\nnothing #hide\n\nWe model the steady-state magnetization as described by Henkelman et al.:\n\nfunction Henkelman_model(x, p; lineshape=:superLorentzian)\n    (m0, m0s, R1f, R1s, T2f, T2s, Rex) = p\n\n    m0s /= 1 - m0s # switch from m0s + m0f = 1 to m0f = 1 normalization\n\n    Δ  = @view x[:,1]\n    ω1 = @view x[:,2]\n\n    Rrf_f = @. π * ω1^2 * g_Lorentzian(Δ, T2f)\n\n    if lineshape == :Lorentzian\n        Rrf_s = @. π * ω1^2 * g_Lorentzian(Δ, T2s)\n    elseif lineshape == :Gaussian\n        Rrf_s = @. π * ω1^2 * g_Gaussian(Δ, T2s)\n    elseif lineshape == :superLorentzian\n        Rrf_s = @. π * ω1^2 * g_superLorentzian(Δ, T2s)\n    end\n\n    m = @. m0 * (R1s * Rex * m0s + Rrf_s * R1f + R1f * R1s + R1f * Rex) / ((R1f + Rrf_f + Rex * m0s) * (R1s + Rrf_s + Rex) - Rex^2 * m0s)\n    return m\nend;\nnothing #hide\n\nHere, we use a fitting routine to demonstrate the best possible fit with each of the three lineshapes. We define an initialization for the fitting routine p0 = [m0, m0s, R1f, R1s, T2f, T2s, Rex] and set some reasonable bounds:\n\np0   = [  1,0.01,   1,   5,0.052,  1e-5, 40]\npmin = [  0,   0,   0,   0,0.052,  1e-6,  1]\npmax = [Inf,   1, Inf, Inf,0.052, 10e-3,100];\nnothing #hide\n\nNote that we fixed T₂ᶠ = 52ms to the value estimated with the Inversion Recovery Experiments as T₂ᶠ is poorly defined by this saturation experiment.","category":"section"},{"location":"build_literate/Analyze_NMR_PreSat_Data/#Super-Lorentzian-Lineshape","page":"Continuous Wave Saturation Experiments","title":"Super-Lorentzian Lineshape","text":"Fitting the model with a super-Lorentzian lineshape to the data achieves good concordance:\n\nfit = curve_fit((x, p) -> Henkelman_model(x, p; lineshape=:superLorentzian), x, vec(M), p0, lower=pmin, upper=pmax)\nfit_std = stderror(fit)\n\np = plot(xlabel=\"Δ [rad/s]\", ylabel=\"M / max(M)\", xaxis=:log, legend=:none)\n[scatter!(p, Δ, M[:,i], color=i) for i=1:length(ω1)]\n[plot!(p, Δ, reshape(Henkelman_model(x, fit.param), length(Δ), length(ω1))[:,i], color=i) for i=1:length(ω1)]\nMain.HTMLPlot(p) #hide","category":"section"},{"location":"build_literate/Analyze_NMR_PreSat_Data/#Lorentzian-Lineshape","page":"Continuous Wave Saturation Experiments","title":"Lorentzian Lineshape","text":"The Lorentzian lineshape, on the other hand, does not fit the data well:\n\nfit = curve_fit((x, p) -> Henkelman_model(x, p; lineshape=:Lorentzian), x, vec(M), p0, lower=pmin, upper=pmax)\nfit_std = stderror(fit)\n\np = plot(xlabel=\"Δ [rad/s]\", ylabel=\"M / max(M)\", xaxis=:log, legend=:none)\n[scatter!(p, Δ, M[:,i], color=i) for i=1:length(ω1)]\n[plot!(p, Δ, reshape(Henkelman_model(x, fit.param), length(Δ), length(ω1))[:,i], color=i) for i=1:length(ω1)]\nMain.HTMLPlot(p) #hide","category":"section"},{"location":"build_literate/Analyze_NMR_PreSat_Data/#Gaussian-Lineshape","page":"Continuous Wave Saturation Experiments","title":"Gaussian Lineshape","text":"And the Gaussian lineshape does not not fit the data well either:\n\nfit = curve_fit((x, p) -> Henkelman_model(x, p; lineshape=:Lorentzian), x, vec(M), p0, lower=pmin, upper=pmax)\nfit_std = stderror(fit)\n\np = plot(xlabel=\"Δ [rad/s]\", ylabel=\"M / max(M)\", xaxis=:log, legend=:none)\n[scatter!(p, Δ, M[:,i], color=i) for i=1:length(ω1)]\n[plot!(p, Δ, reshape(Henkelman_model(x, fit.param), length(Δ), length(ω1))[:,i], color=i) for i=1:length(ω1)]\nMain.HTMLPlot(p) #hide\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"(Image: )","category":"section"},{"location":"build_literate/Analyze_NMR_IR_Data/#Inversion-Recovery-Experiments","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"The following code replicates the NMR data analysis in Figs. 4-6 and complements the paper with additional analyses that are not shown in the paper in the interest of brevity.\n\nFor this analysis we need the following packages:\n\nusing MRIgeneralizedBloch\nusing DifferentialEquations\nusing LinearAlgebra\nusing LsqFit\nusing Statistics\nusing HypothesisTests\nusing Printf\nusing Plots\nplotlyjs(bg=RGBA(31 / 255, 36 / 255, 36 / 255, 1.0), ticks=:native); #hide\nnothing #hide\n\nThe raw data is stored in a separate github repository and the following functions return the URL to the individual files:\n\nMnCl2_data(TRF_scale) = \"https://github.com/JakobAsslaender/MRIgeneralizedBloch_NMRData/blob/main/20210419_1mM_MnCl2/ja_IR_v2%20($TRF_scale)/1/data.2d?raw=true\"\nBSA_data(TRF_scale)   = \"https://github.com/JakobAsslaender/MRIgeneralizedBloch_NMRData/blob/main/20210416_15%25BSA_2ndBatch/ja_IR_v2%20($TRF_scale)/1/data.2d?raw=true\";\nnothing #hide\n\nwhich can be loaded with functions implemented in this file:\n\ninclude(\"$(pathof(MRIgeneralizedBloch))/../../docs/src/load_NMR_data.jl\");\nnothing #hide","category":"section"},{"location":"build_literate/Analyze_NMR_IR_Data/#MnCl_2-Sample","page":"Inversion Recovery Experiments","title":"MnCl_2 Sample","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_IR_Data/#T_2{*,f}-Estimation","page":"Inversion Recovery Experiments","title":"T_2^*f Estimation","text":"We estimate T_2^*f by fitting a mono-exponential decay curve to the FID of the acquisition with T_textRF = 228μs and T_texti = 5s.\n\nM = load_Data(MnCl2_data(1))\nM = M[:, 1]; # select Tᵢ = 5s\nnothing #hide\n\nThe data was measured at the following time points in units of seconds:\n\nT_dwell = 100e-6 # s\nTE = T_dwell * ((1:length(M)) .+ 7) # s\n\nNote that the signal is an FID, so the phrase echo time is a bit misleading.\n\nThe function curve_fit from the LsqFit.jl package is only implemented for real-valued models. To accommodate this, we need to split the data into its real and imaginary part:\n\nTEreal = [TE; TE]\nMreal = [real(M); imag(M)];\nnothing #hide\n\nHere, we are using a simple mono-exponential model with a complex-valued scaling factor p[1] + 1im p[2], the decay time T_2^*f = p[3], and the Larmor frequency p[4]:\n\nFID_model(t, p) = @. [p[1] * exp(-t[1:end÷2] / p[3]) * cos(p[4] * t[1:end÷2]); p[2] * exp(-t[end÷2+1:end] / p[3]) * sin(p[4] * t[end÷2+1:end])];\nnothing #hide\n\nFitting this model to the NMR data estimates T_2^*f:\n\nfit = curve_fit(FID_model, TEreal, Mreal, [1, 1, 0.1, 0])\nT₂star_MnCl2 = fit.param[3] # s\n\nseconds and its uncertainty (also in units of seconds)\n\nstderror(fit)[3] # s\n\nVisually, the plot and the data show good agreement:\n\nMfitted = FID_model(TEreal, fit.param)\nMfitted = Mfitted[1:end÷2] + 1im * Mfitted[end÷2+1:end]\np = plot(xlabel=\"TE [s]\", ylabel=\"|FID(TE)| [a.u.]\")\nplot!(p, TE, abs.(M), label=\"data\")\nplot!(p, TE, abs.(Mfitted), label=@sprintf(\"fit with T₂* = %2.3f ms\", 1e3 * T₂star_MnCl2))\nMain.HTMLPlot(p) #hide\n\nThe relative residual norm of the fit, i.e. textresidual_2M_2 is\n\nnorm(fit.resid) / norm(M)\n\nDespite its small ell_2-norm, the Shapiro-Wilk test rejects the null hypothesis h_0 that the residual is Gaussian or normal distributed with a very small p value:\n\nShapiroWilkTest(fit.resid)\n\nWe note that mono-exponential T_2^* decays assume a Lorentzian distributed magnetic field, which is in general an assumption rather than a well-founded theory.","category":"section"},{"location":"build_literate/Analyze_NMR_IR_Data/#Mono-Exponential-IR-Model","page":"Inversion Recovery Experiments","title":"Mono-Exponential IR Model","text":"We performed several experiments in which we inverted the thermal equilibrium magnetization with rectangular π-pulses with the following pulse durations (in seconds):\n\nTʳᶠmin = 22.8e-6 # s - shortest Tʳᶠ possible on the NMR\nTRF_scale = [1; 2; 5:5:40] # scaling factor\nTʳᶠ = TRF_scale * Tʳᶠmin # s\n\nand acquired inversion recovery data at exponentially spaced inversion times (in seconds):\n\nTᵢ = exp.(range(log(3e-3), log(5), length=20)) # s\nTᵢ .+= 12 * Tʳᶠmin + (13 * 15.065 - 5) * 1e-6 # s - correction factors\n\nWe calculate the Rabi frequencies of the RF pulses and a finer grid of T_texti to plot the IR model:\n\nω₁ = π ./ Tʳᶠ # rad/s\nTᵢplot = exp.(range(log(Tᵢ[1]), log(Tᵢ[end]), length=500)); # s\nnothing #hide\n\nAfter loading and normalizing the data\n\nM = zeros(Float64, length(Tᵢ), length(TRF_scale))\nfor i ∈ eachindex(TRF_scale)\n    M[:, i] = load_first_datapoint(MnCl2_data(TRF_scale[i]))\nend\nM ./= maximum(M);\nnothing #hide\n\nwe analyze each inversion recovery curve that corresponds to a different T_textRF separately. This allows us to fit a simple mono-exponential model\n\nstandard_IR_model(t, p) = @. p[1] - p[3] * exp(-t * p[2]);\nnothing #hide\n\nwhere p[1] is the thermal equilibrium magnetization, p[2] = T_1, and p[1] - p[3] is the magnetization right after the inversion pulse or, equivalently, Minv = p[1] / p[3] - 1 is the inversion efficiency, which is 1 for an ideal π-pulse and smaller otherwise. The parameters are initialized with\n\np0 = [1.0, 1.0, 2.0];\nnothing #hide\n\nand we can loop over T_textRF to perform the fits:\n\nR₁ = similar(M[1, :])\nMinv = similar(R₁)\nresidual = similar(R₁)\np = plot(xlabel=\"Tᵢ [s]\", ylabel=\"zᶠ(Tʳᶠ, Tᵢ) [a.u.]\")\nfor i ∈ eachindex(TRF_scale)\n    Mi = @view M[:, i]\n\n    fit = curve_fit(standard_IR_model, Tᵢ, Mi, p0)\n\n    R₁[i] = fit.param[2]\n    Minv[i] = fit.param[3] / fit.param[1] - 1\n\n    residual[i] = norm(fit.resid) / norm(Mi)\n\n    scatter!(p, Tᵢ, Mi, label=@sprintf(\"Tʳᶠ = %1.2es - data\", Tʳᶠ[i]), color=i)\n    plot!(p, Tᵢplot, standard_IR_model(Tᵢplot, fit.param), label=@sprintf(\"fit with R₁ = %.3f/s; MInv = %.3f\", R₁[i], Minv[i]), color=i)\nend\nMain.HTMLPlot(p) #hide\n\nHere, the data measured with different T_textRF are indicated by markers in different colors, and the corresponding fits are the line plots in the same color. The fitted parameters are denoted in the legend. In the paper, we highlight the estimated inversion efficiency and the relaxation rate of the dataset acquired with T_textRF=228μs:\n\nMinv[1]\n\nR₁[1] # 1/s\n\nand of the dataset acquired with T_textRF=912μs:\n\nMinv[end]\n\nR₁[end] # 1/s\n\nThe mean value of all R₁ estimates is\n\nmean(R₁) # 1/s\n\n1/s and its standard deviation in units of 1/s is\n\nstd(R₁) # 1/s\n\nThe relative residual norm of the fits is on average\n\nmean(residual)","category":"section"},{"location":"build_literate/Analyze_NMR_IR_Data/#Global-IR-Fit","page":"Inversion Recovery Experiments","title":"Global IR Fit","text":"As an alternative to individual fits to the inversion recovery curves with different T_textRF, we can also perform a global fit that accounts for the T_2^*f decay during the inversion pulse. The model first simulates the T_2^*f decay during the inversion pulse, followed by T_1 recovery:\n\nfunction Bloch_IR_model(p, Tʳᶠ, Tᵢ, T2)\n    (m0, m0_inv, R₁) = p\n    R2 = 1 / T2\n\n    M = zeros(Float64, length(Tᵢ), length(Tʳᶠ))\n    for i ∈ eachindex(Tʳᶠ)\n        # simulate inversion pulse\n        ω₁ = π / Tʳᶠ[i]\n        H = [-R2 -ω₁ 0 ;\n              ω₁ -R₁ R₁;\n               0   0 0 ]\n\n        m_inv = m0_inv * (exp(H * Tʳᶠ[i])*[0, 1, 1])[2]\n\n        # simulate T1 recovery\n        H = [-R₁ R₁*m0;\n               0     0]\n\n        for j ∈ eachindex(Tᵢ)\n            M[j, i] = m0 * (exp(H .* (Tᵢ[j] - Tʳᶠ[i] / 2)) * [m_inv, 1])[1]\n        end\n    end\n    return vec(M)\nend;\nnothing #hide\n\nWe use the previously estimated T_2^*f value for the fit:\n\nfit = curve_fit((x, p) -> Bloch_IR_model(p, Tʳᶠ, Tᵢ, T₂star_MnCl2), 1:length(M), vec(M), [1, 0.8, 1])\n\np = plot(xlabel=\"Tᵢ [s]\", ylabel=\"zᶠ(Tʳᶠ, Tᵢ) [a.u.]\")\nfor i ∈ eachindex(Tʳᶠ)\n    scatter!(p, Tᵢ, M[:, i], label=@sprintf(\"Tʳᶠ = %1.2es\", Tʳᶠ[i]), color=i)\n    plot!(p, Tᵢplot, Bloch_IR_model(fit.param, Tʳᶠ[i], Tᵢplot, T₂star_MnCl2), label=@sprintf(\"Tʳᶠ = %1.2es\", Tʳᶠ[i]), color=i)\nend\nMain.HTMLPlot(p) #hide\n\nWith this global fit, we get a very similar relaxation rate in units of 1/s\n\nR₁_MnCl2 = fit.param[3] # 1/s\n\nwith an uncertainty (also in units of 1/s) of\n\nstderror(fit)[3] # 1/s\n\nNote that the relative residual norm is somewhat increased compared to individual fits to each inversion recovery curve:\n\nnorm(fit.resid) / norm(M)","category":"section"},{"location":"build_literate/Analyze_NMR_IR_Data/#Bovine-Serum-Albumin-Sample","page":"Inversion Recovery Experiments","title":"Bovine Serum Albumin Sample","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_IR_Data/#T_2{*,f}-Estimation-2","page":"Inversion Recovery Experiments","title":"T_2^*f Estimation","text":"We repeat the T_2^*f estimation for the bovine serum albumin (BSA) sample by fitting a mono-exponential decay curve to the FID of the acquisition with T_textRF = 228μs and T_texti = 5s.\n\nM = load_Data(BSA_data(1));\nM = M[:, 1] # select Tᵢ = 5s\nMreal = [real(M); imag(M)]\n\nfit = curve_fit(FID_model, TEreal, Mreal, [1.0, 1.0, 0.1, 0.0]);\nnothing #hide\n\nThe estimated T_2^*f of the BSA sample is\n\nT₂star_BSA = fit.param[3] # s\n\nseconds with an uncertainty of\n\nstderror(fit)[3] # s\n\nseconds.\n\nVisually, the plot and the data align well for the BSA sample, too:\n\nMfitted = FID_model(TEreal, fit.param)\nMfitted = Mfitted[1:end÷2] + 1im * Mfitted[end÷2+1:end]\np = plot(xlabel=\"TE [s]\", ylabel=\"|FID(TE)| [a.u.]\")\nplot!(p, TE, abs.(M), label=\"data\")\nplot!(p, TE, abs.(Mfitted), label=@sprintf(\"fit with T₂* = %2.3f ms\", 1e3 * T₂star_BSA))\nMain.HTMLPlot(p) #hide\n\nThe relative residual norm (textresidual_2M_2) is\n\nnorm(fit.resid) / norm(M)\n\nDespite the small residual, the Shapiro-Wilk test indicates that the residual is not normal distributed for this sample either:\n\nShapiroWilkTest(fit.resid)","category":"section"},{"location":"build_literate/Analyze_NMR_IR_Data/#Mono-Exponential-IR-Model-2","page":"Inversion Recovery Experiments","title":"Mono-Exponential IR Model","text":"We also fit a mono-exponential model to each inversion recovery curve of the BSA data:\n\nM = zeros(Float64, length(Tᵢ), length(TRF_scale))\nfor i ∈ eachindex(TRF_scale)\n    M[:, i] = load_first_datapoint(BSA_data(TRF_scale[i]))\nend\nM ./= maximum(M)\n\n\np = plot(xlabel=\"Tᵢ [s]\", ylabel=\"zᶠ(Tʳᶠ, Tᵢ) [a.u.]\")\nfor i ∈ eachindex(TRF_scale)\n    Mi = @view M[:, i]\n\n    fit = curve_fit(standard_IR_model, Tᵢ, Mi, p0)\n\n    R₁[i] = fit.param[2]\n    Minv[i] = fit.param[3] / fit.param[1] - 1\n    residual[i] = norm(fit.resid) / norm(Mi)\n\n    scatter!(p, Tᵢ, Mi, label=@sprintf(\"Tʳᶠ = %1.2es - data\", Tʳᶠ[i]), color=i)\n    plot!(p, Tᵢplot, standard_IR_model(Tᵢplot, fit.param), label=@sprintf(\"fit with R₁ = %.3f/s; MInv = %.3f\", R₁[i], Minv[i]), color=i)\nend\nMain.HTMLPlot(p) #hide\n\nZooming into the early phase of the recovery curve reveals the poor fit quality, in particular for long T_textRF. This is also reflected by a substantially larger relative residual norm compared to the MnCl_2 sample:\n\nmean(residual)\n\nIn the paper, we highlight the estimated inversion efficiency and the relaxation rate of the dataset acquired with T_textRF=228μs\n\nMinv[1]\n\nR₁[1] # 1/s\n\nand of the dataset acquired with T_textRF=912μs\n\nMinv[end]\n\nR₁[end] # 1/s\n\nThe mean value of all R₁ estimates is\n\nmean(R₁) # 1/s\n\nand its standard deviation is substantially larger compared to the same fit of the MnCl_2 sample:\n\nstd(R₁) # 1/s","category":"section"},{"location":"build_literate/Analyze_NMR_IR_Data/#Global-IR-Fit-Generalized-Bloch-Model","page":"Inversion Recovery Experiments","title":"Global IR Fit - Generalized Bloch Model","text":"In order to repeat the global fit that includes all T_textRF values, we have to account for the spin dynamics in the semi-solid pool during the RF-pulse. First, we do this with the proposed generalized Bloch model:\n\nfunction gBloch_IR_model(p, G, Tʳᶠ, TI, R2f)\n    (m0, m0f_inv, m0s, R₁, T₂ˢ, Rex) = p\n    m0f = 1 - m0s\n    ω₁ = π ./ Tʳᶠ\n\n    m0vec = [0, 0, m0f, m0s, 1]\n    m_fun(p, t; idxs=nothing) = typeof(idxs) <: Number ? 0.0 : zeros(5)\n\n\n    H = [-R₁-m0s*Rex     m0f*Rex R₁*m0f;\n             m0s*Rex -R₁-m0f*Rex R₁*m0s;\n              0           0          0 ]\n\n    M = zeros(Float64, length(TI), length(Tʳᶠ))\n    for i ∈ eachindex(Tʳᶠ)\n        param = (ω₁[i], 1, 0, m0s, R₁, R2f, Rex, R₁, T₂ˢ, G)\n        prob = DDEProblem(apply_hamiltonian_gbloch!, m0vec, m_fun, (0.0, Tʳᶠ[i]), param)\n        m = solve(prob, MethodOfSteps(Tsit5())).u[end]\n\n        for j ∈ eachindex(TI)\n            M[j, i] = m0 * (exp(H .* (TI[j] - Tʳᶠ[i] / 2))*[m0f_inv * m[3], m[4], 1])[1]\n        end\n    end\n    return vec(M)\nend;\nnothing #hide\n\nHere, we use assume a super-Lorentzian lineshape, whose Green's function is interpolated to speed up the fitting routine:\n\nT₂ˢ_min = 5e-6 # s\nG_superLorentzian = interpolate_greens_function(greens_superlorentzian, 0, maximum(Tʳᶠ) / T₂ˢ_min);\nnothing #hide\n\nThe fit is initialized with p0 = [m0, m0f_inv, m0_s, R₁, T2_s, Rex] and we set some reasonable bounds to the fitted parameters:\n\np0   = [  1, 0.932,  0.1,   1, 10e-6, 50]\npmin = [  0, 0.100,   .0, 0.3,  1e-9, 10]\npmax = [Inf,   Inf,  1.0, Inf, 20e-6,1e3]\n\nfit_gBloch = curve_fit((x, p) -> gBloch_IR_model(p, G_superLorentzian, Tʳᶠ, Tᵢ, 1 / T₂star_BSA), [], vec(M), p0, lower=pmin, upper=pmax);\nnothing #hide\n\nVisually, the plot and the data align well:\n\np = plot(xlabel=\"Tᵢ [s]\", ylabel=\"zᶠ(Tʳᶠ, Tᵢ) [a.u.]\")\nfor i ∈ eachindex(Tʳᶠ)\n    scatter!(p, Tᵢ, M[:, i], label=@sprintf(\"Tʳᶠ = %1.2es\", Tʳᶠ[i]), color=i)\n    plot!(p, Tᵢplot, gBloch_IR_model(fit_gBloch.param, G_superLorentzian, Tʳᶠ[i], Tᵢplot, 1 / T₂star_BSA), label=@sprintf(\"Tʳᶠ = %1.2es\", Tʳᶠ[i]), color=i)\nend\nMain.HTMLPlot(p) #hide\n\nwhich becomes particularly apparent when zooming into the beginning of the inversion recovery curves. Further, the relative residual norm is much smaller compared to the mono-exponential fit:\n\nnorm(fit_gBloch.resid) / norm(M)\n\nThe estimated parameters are\n\nm0 = fit_gBloch.param[1]\n\nMinv = fit_gBloch.param[2]\n\nm0s = fit_gBloch.param[3]\n\nR₁ = fit_gBloch.param[4] # 1/s\n\nT₂ˢ = 1e6fit_gBloch.param[5] # μs\n\nRex = fit_gBloch.param[6] # 1/s\n\nwith the uncertainties (in the same order)\n\nstderror(fit_gBloch)","category":"section"},{"location":"build_literate/Analyze_NMR_IR_Data/#Global-IR-Fit-Graham's-Spectral-Model","page":"Inversion Recovery Experiments","title":"Global IR Fit - Graham's Spectral Model","text":"For comparison, we repeat the same fit with Graham's spectral model:\n\nfunction Graham_IR_model(p, Tʳᶠ, TI, R2f)\n    (m0, m0f_inv, m0s, R₁, T₂ˢ, Rex) = p\n    m0f = 1 - m0s\n    ω₁ = π ./ Tʳᶠ\n\n    m0vec = [0, 0, m0f, m0s, 1]\n\n    H = [-R₁-m0s*Rex     m0f*Rex R₁*m0f;\n             m0s*Rex -R₁-m0f*Rex R₁*m0s;\n              0           0          0 ]\n\n    M = zeros(Float64, length(TI), length(Tʳᶠ))\n    for i ∈ eachindex(Tʳᶠ)\n        param = (ω₁[i], 1, 0, Tʳᶠ[i], m0s, R₁, R2f, Rex, R₁, T₂ˢ)\n        prob = ODEProblem(apply_hamiltonian_graham_superlorentzian!, m0vec, (0.0, Tʳᶠ[i]), param)\n        m = solve(prob).u[end]\n\n        for j ∈ eachindex(TI)\n            M[j, i] = m0 * (exp(H .* (TI[j] - Tʳᶠ[i] / 2)) * [m0f_inv * m[3], m[4], 1])[1]\n        end\n    end\n    return vec(M)\nend\n\nfit_Graham = curve_fit((x, p) -> Graham_IR_model(p, Tʳᶠ, Tᵢ, 1 / T₂star_BSA), [], vec(M), p0, lower=pmin, upper=pmax);\nnothing #hide\n\nVisually, the plot and the data align substantially worse:\n\np = plot(xlabel=\"Tᵢ [s]\", ylabel=\"zᶠ(Tʳᶠ, Tᵢ) [a.u.]\")\nfor i ∈ eachindex(Tʳᶠ)\n    scatter!(p, Tᵢ, M[:, i], label=@sprintf(\"Tʳᶠ = %1.2es\", Tʳᶠ[i]), color=i)\n    plot!(p, Tᵢplot, Graham_IR_model(fit_Graham.param, Tʳᶠ[i], Tᵢplot, 1 / T₂star_BSA), label=@sprintf(\"Tʳᶠ = %1.2es\", Tʳᶠ[i]), color=i)\nend\nMain.HTMLPlot(p) #hide\n\nwhich becomes particularly apparent when zooming into the beginning of the inversion recovery curves. Further, the relative residual norm is much larger compared to the generalized Bloch fit:\n\nnorm(fit_Graham.resid) / norm(M)\n\nThe estimated parameters are\n\nm0 = fit_Graham.param[1]\n\nMinv = fit_Graham.param[2]\n\nm0s = fit_Graham.param[3]\n\nR₁ = fit_Graham.param[4] # 1/s\n\nT₂ˢ = 1e6fit_Graham.param[5] # μs\n\nRex = fit_Graham.param[6] # 1/s\n\nwith the uncertainties (in the same order)\n\nstderror(fit_Graham)","category":"section"},{"location":"build_literate/Analyze_NMR_IR_Data/#Global-IR-Fit-Sled's-Model","page":"Inversion Recovery Experiments","title":"Global IR Fit - Sled's Model","text":"We also performed the fit with Sled's model:\n\nfunction Sled_IR_model(p, G, Tʳᶠ, TI, R2f)\n    (m0, m0f_inv, m0s, R₁, T₂ˢ, Rex) = p\n    m0f = 1 - m0s\n    ω₁ = π ./ Tʳᶠ\n\n    m0vec = [0, 0, m0f, m0s, 1]\n\n    H = [-R₁-m0s*Rex     m0f*Rex R₁*m0f;\n             m0s*Rex -R₁-m0f*Rex R₁*m0s;\n              0           0          0 ]\n\n    M = zeros(Float64, length(TI), length(Tʳᶠ))\n    for i ∈ eachindex(Tʳᶠ)\n        param = (ω₁[i], 1, 0, m0s, R₁, R2f, Rex, R₁, T₂ˢ, G)\n        prob = ODEProblem(apply_hamiltonian_sled!, m0vec, (0.0, Tʳᶠ[i]), param)\n        m = solve(prob).u[end]\n\n        for j ∈ eachindex(TI)\n            M[j, i] = m0 * (exp(H .* (TI[j] - Tʳᶠ[i] / 2))*[m0f_inv * m[3], m[4], 1])[1]\n        end\n    end\n    return vec(M)\nend\n\nfit_Sled = curve_fit((x, p) -> Sled_IR_model(p, G_superLorentzian, Tʳᶠ, Tᵢ, 1 / T₂star_BSA), [], vec(M), p0, lower=pmin, upper=pmax);\nnothing #hide\n\nVisually, the plot and the data do not align well either:\n\np = plot(xlabel=\"Tᵢ [s]\", ylabel=\"zᶠ(Tʳᶠ, Tᵢ) [a.u.]\")\nfor i ∈ eachindex(Tʳᶠ)\n    scatter!(p, Tᵢ, M[:, i], label=@sprintf(\"Tʳᶠ = %1.2es\", Tʳᶠ[i]), color=i)\n    plot!(p, Tᵢplot, Sled_IR_model(fit_Sled.param, G_superLorentzian, Tʳᶠ[i], Tᵢplot, 1 / T₂star_BSA), label=@sprintf(\"Tʳᶠ = %1.2es\", Tʳᶠ[i]), color=i)\nend\nMain.HTMLPlot(p) #hide\n\nwhich becomes particularly apparent when zooming into the beginning of the inversion recovery curves. Further, the relative residual norm is also large compared to the generalized Bloch fit:\n\nnorm(fit_Sled.resid) / norm(M)\n\nThe estimated parameters are\n\nm0 = fit_Sled.param[1]\n\nMinv = fit_Sled.param[2]\n\nm0s = fit_Sled.param[3]\n\nR₁ = fit_Sled.param[4] # 1/s\n\nT₂ˢ = 1e6fit_Sled.param[5] # μs\n\nRex = fit_Sled.param[6] # 1/s\n\nwith the uncertainties (in the same order)\n\nstderror(fit_Sled)","category":"section"},{"location":"build_literate/Analyze_NMR_IR_Data/#Analysis-of-the-Residuals","page":"Inversion Recovery Experiments","title":"Analysis of the Residuals","text":"In order to visualize how well the three models align with the data at different T_textRF, we calculate the ell_2-norm of the residuals after subtracting the modeled from the measured signal and normalize it by the ell_2-norm of the signal:\n\nresid_gBlo = similar(Tʳᶠ)\nresid_Sled = similar(Tʳᶠ)\nresid_Grah = similar(Tʳᶠ)\nfor i ∈ eachindex(Tʳᶠ)\n    resid_gBlo[i] = norm(gBloch_IR_model(fit_gBloch.param, G_superLorentzian, Tʳᶠ[i], Tᵢ, 1 / T₂star_BSA) .- M[:, i]) / norm(M[:, i])\n    resid_Grah[i] = norm(Graham_IR_model(fit_Graham.param, Tʳᶠ[i], Tᵢ, 1 / T₂star_BSA) .- M[:, i]) / norm(M[:, i])\n    resid_Sled[i] = norm(Sled_IR_model(fit_Sled.param, G_superLorentzian, Tʳᶠ[i], Tᵢ, 1 / T₂star_BSA) .- M[:, i]) / norm(M[:, i])\nend\n\np = plot(xlabel=\"Tʳᶠ [s]\", ylabel=\"relative residual\")\nscatter!(p, Tʳᶠ, resid_gBlo, label=\"generalized Bloch model\")\nscatter!(p, Tʳᶠ, resid_Grah, label=\"Graham's spectral model\")\nscatter!(p, Tʳᶠ, resid_Sled, label=\"Sled's model\")\nMain.HTMLPlot(p) #hide\n\nThis analysis examines the residuals from the actual fits, i.e. it uses the biophysical parameters of respective fit to model the signal. The disadvantage of this approach is that residuals at long T_textRF are negatively affected by the poor fits of Graham's and Sled's models at short T_textRF. This problem is overcome by subtracting the measured signal from signal that is simulated with the biophysical parameters that were estimated by fitting the generalized Bloch model:\n\nfor i ∈ eachindex(Tʳᶠ)\n    resid_gBlo[i] = norm(gBloch_IR_model(fit_gBloch.param, G_superLorentzian, Tʳᶠ[i], Tᵢ, 1 / T₂star_BSA) .- M[:, i]) / norm(M[:, i])\n    resid_Grah[i] = norm(Graham_IR_model(fit_gBloch.param, Tʳᶠ[i], Tᵢ, 1 / T₂star_BSA) .- M[:, i]) / norm(M[:, i])\n    resid_Sled[i] = norm(Sled_IR_model(fit_gBloch.param, G_superLorentzian, Tʳᶠ[i], Tᵢ, 1 / T₂star_BSA) .- M[:, i]) / norm(M[:, i])\nend\n\np = plot(xlabel=\"Tʳᶠ [s]\", ylabel=\"relative residual\")\nscatter!(p, Tʳᶠ, resid_gBlo, label=\"generalized Bloch model\")\nscatter!(p, Tʳᶠ, resid_Grah, label=\"Graham's spectral model\")\nscatter!(p, Tʳᶠ, resid_Sled, label=\"Sled's model\")\nMain.HTMLPlot(p) #hide\n\nOne can observe reduced residuals for Graham's and Sled's models for long T_textRF as a trade off for larger residuals at short T_textRF. Yet, the residuals at long T_textRF are still substantially larger compared to ones of the generalized Bloch model.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"#MRIgeneralizedBloch.jl","page":"Home","title":"MRIgeneralizedBloch.jl","text":"Documentation for the MRIgeneralizedBloch.jl package, which implements the generalized Bloch model for simulating magnetization transfer (MT), as described in our paper. The key innovation of the model is to generalize the original Bloch model to arbitrary lineshapes, such as the super-Lorentzian lineshape which has been shown to describe brain white matter well. This enables a more accurate description of the spin dynamics during short RF-pulses compared to previous MT models.\n\nThe package allows to simulate the dynamics of an isolated semi-solid spin pool during RF-pulses, as well as the dynamics of a coupled spin system with a free spin pool, for which we use the Bloch model, and a semi-solid pool, which we describe with the generalized Bloch model.\n\nSection Simulation of a Single RF Pulse demonstrates the basic and flexible simulation of the spin dynamics during a single RF pulse and Section Balanced Hybrid-State Free Precession Pulse Sequence demonstrates an efficient simulation of a train of RF pulses. Section Non-Linear Least Square Fitting demonstrates a simple method for parameter estimation at the example of a Balanced Hybrid-State Free Precession pulse sequence; and Section Optimal Control outlines the interface for optimizing RF pulse trains for parameter estimation. More details about these topics can be found in the paper Rapid quantitative magnetization transfer imaging: utilizing the hybrid state and the generalized Bloch model.\n\nMore details on the implementation are provided in the Section Generalized Bloch Paper, which reproduces all simulations, data analyses, and figures of the generalized Bloch paper:\n\nPages=[\n        \"build_literate/Greens_functions.md\",\n        \"build_literate/Simulation_ContinuousWave.md\",\n        \"build_literate/Simulation_Pulse.md\",\n        \"build_literate/Analyze_NMR_IR_Data.md\",\n        \"build_literate/Analyze_NMR_PreSat_Data.md\",\n        \"build_literate/Linear_Approximation.md\",\n]\nDepth = 2\n\nThe documentation of all exported functions can be found in the API Section.","category":"section"}]
}
