var documenterSearchIndex = {"docs":
[{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"EditURL = \"../Linear_Approximation.jl\"","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"(Image: )","category":"page"},{"location":"build_literate/Linear_Approximation/#Linear-Approximation","page":"Linear Approximation","title":"Linear Approximation","text":"","category":"section"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"The following code demonstrates the linear approximation of the generalized Bloch model and replicates Figs. 7 and 8 in the paper.","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"For this analysis we need the following packages:","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"using DifferentialEquations\nusing BenchmarkTools\nusing LinearAlgebra\nusing MRIgeneralizedBloch\nusing Plots\nplotlyjs(bg = RGBA(31/255,36/255,36/255,1.0), ticks=:native); #hide\nnothing #hide","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"and we simulate a coupled spin system with the following parameters:","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"m₀ˢ = 0.1\nm₀ᶠ = 1-m₀ˢ\nR₁ = 1 # 1/s\nR₂ᶠ = 1 / 50e-3 # 1/s\nRₓ = 70; # 1/s\nnothing #hide","category":"page"},{"location":"build_literate/Linear_Approximation/#Linearized-T_2{s,l}","page":"Linear Approximation","title":"Linearized T_2^sl","text":"","category":"section"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"We demonstrate the linear approximation at the example of the Green's function corresponding to the super-Lorentzian lineshape, which we interpolate to improve the performance:","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"G = interpolate_greens_function(greens_superlorentzian, 0, 1e-3 / 5e-6);\nnothing #hide","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"The function precompute_R2sl returns another function, R₂ˢˡ(Tʳᶠ, α, B1, T₂ˢ), that interpolates the linearized relaxation rate, as well as functions that describe its derivatives wrt. T_2^s and B_1, respectively:","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"R₂ˢˡ, ∂R₂ˢˡ∂T₂ˢ, ∂R₂ˢˡ∂B₁ = precompute_R2sl(TRF_min=5, TRF_max=100, T2s_min=1, T2s_max=1, ω1_max=π/5, B1_max=1, greens=G);\nnothing #hide","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"The derivatives are not used here and are just assigned for demonstration purposes.","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"In order to replicate Fig. 7, we plot R₂ˢˡ(Tʳᶠ, α, B₁, T₂ˢ) for a varying α and T_textRFT_2^s:","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"α = (0.01:.01:1) * π\nTʳᶠoT₂ˢ = 5:100\n\nTʳᶠoT₂ˢ_m = repeat(reshape(TʳᶠoT₂ˢ, 1, :), length(α), 1)\nα_m = repeat(α, 1, size(TʳᶠoT₂ˢ_m, 2))\n\np = plot(xlabel=\"Tʳᶠ/T₂ˢ\", ylabel=\"α/π\", colorbar_title=\"T₂ˢˡ/T₂ˢ\")\ncontour!(p, TʳᶠoT₂ˢ, α ./ π, 1 ./ R₂ˢˡ.(TʳᶠoT₂ˢ_m, α_m, 1, 1), fill = true)\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Linear_Approximation/#Spin-Dynamics-during-a-single-RF-Pulse","page":"Linear Approximation","title":"Spin Dynamics during a single RF Pulse","text":"","category":"section"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"To replicate Fig. 8a, we simulate and plot the dynamics of a coupled spin system during a single π-pulse, starting from thermal equilibrium.","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"Tʳᶠ = 100e-6 # s\nT₂ˢ = 10e-6 # μs\nm0_5D = [0,0,m₀ᶠ,m₀ˢ,1]\nmfun(p, t; idxs=nothing) = typeof(idxs) <: Number ? 0 : m0_5D; # initialize history function, here with the ability to just call a single index\nnothing #hide","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"The full generalized Bloch model is solved by","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"param = (π/Tʳᶠ, 1, 0, m₀ˢ, R₁, R₂ᶠ, Rₓ, R₁, T₂ˢ, G)\nprob = DDEProblem(apply_hamiltonian_gbloch!, m0_5D, mfun, (0.0, Tʳᶠ), param)\nsol_pi_full = solve(prob);\nnothing #hide","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"and we evaluate the interpolated solution at the following time points:","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"t = (0:.01:1) * Tʳᶠ # s\nMpi_full = zeros(length(t),4)\nfor i in eachindex(t)\n    Mpi_full[i,:] = sol_pi_full(t[i])[1:4]\nend","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"Further, we calculate the linear approximation, which is simulated in a 6D-space as it explicitly models x^s:","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"m0_6D = [0,0,m₀ᶠ,0,m₀ˢ,1]\n\nMpi_appx = similar(Mpi_full)\nfor i in eachindex(t)\n    H = exp(hamiltonian_linear(π/Tʳᶠ, 1, 0, t[i], m₀ˢ, R₁, Rₓ, R₁, R₂ᶠ, R₂ˢˡ(Tʳᶠ, π, 1, T₂ˢ)))\n    Mpi_appx[i,:] = (H * m0_6D)[[1:3;5]]\nend","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"and plot the original generalized Bloch model and its linear approximation for comparison:","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"p = plot(xlabel=\"t [s]\", ylabel=\"m/m₀\")\nplot!(p, t, Mpi_full[:,1] / m₀ᶠ, label=\"xᶠ/m₀ᶠ original model\")\nplot!(p, t, Mpi_appx[:,1] / m₀ᶠ, label=\"xᶠ/m₀ᶠ linear approximation\")\nplot!(p, t, Mpi_full[:,3] / m₀ᶠ, label=\"zᶠ/m₀ᶠ original model\")\nplot!(p, t, Mpi_appx[:,3] / m₀ᶠ, label=\"zᶠ/m₀ᶠ linear approximation\")\nplot!(p, t, Mpi_full[:,4] / m₀ˢ, label=\"zˢ/m₀ˢ original model\")\nplot!(p, t, Mpi_appx[:,4] / m₀ˢ, label=\"zˢ/m₀ˢ linear approximation\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"We observe slight deviations of zˢ during the pulse, but a virtually perfect match at the end of the RF pulse.","category":"page"},{"location":"build_literate/Linear_Approximation/#RF-Pulses-with-Different-Flip-Angles","page":"Linear Approximation","title":"RF Pulses with Different Flip Angles","text":"","category":"section"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"To replicate Fig. 8b, we simulate the spin dynamics during multiple RF pulses with different flip angles α, each simulation starting from thermal equilibrium, and analyze the magnetization at the end of each pulse:","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"α = (.01:.01:1) * π\n\nM_full = zeros(length(α), 4)\nM_appx = similar(M_full)\nfor i in eachindex(α)\n    param = (α[i]/Tʳᶠ, 1, 0, m₀ˢ, R₁, R₂ᶠ, Rₓ, R₁, T₂ˢ, G)\n    prob = DDEProblem(apply_hamiltonian_gbloch!, m0_5D, mfun, (0.0, Tʳᶠ), param)\n    M_full[i,:] = solve(prob)[end][1:4]\n\n    u = exp(hamiltonian_linear(α[i]/Tʳᶠ, 1, 0, Tʳᶠ, m₀ˢ, R₁, R₂ᶠ, Rₓ, R₁, R₂ˢˡ(Tʳᶠ, α[i], 1, T₂ˢ))) * m0_6D\n    M_appx[i,:] = u[[1:3;5]]\nend\n\np = plot(xlabel=\"α/π\", ylabel=\"m/m₀\")\nplot!(p, α/π, M_appx[:,1] / m₀ᶠ, label=\"xᶠ/m₀ˢ original model\")\nplot!(p, α/π, M_full[:,1] / m₀ᶠ, label=\"xᶠ/m₀ˢ linear approximation\")\nplot!(p, α/π, M_appx[:,3] / m₀ᶠ, label=\"zᶠ/m₀ˢ original model\")\nplot!(p, α/π, M_full[:,3] / m₀ᶠ, label=\"zᶠ/m₀ˢ linear approximation\")\nplot!(p, α/π, M_appx[:,4] / m₀ˢ, label=\"zˢ/m₀ˢ original model\")\nplot!(p, α/π, M_full[:,4] / m₀ˢ, label=\"zˢ/m₀ˢ linear approximation\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"Visually, the linear approximation matches the full simulation well. The normalized root-mean-squared error of the linear approximation for x^f is","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"norm(M_appx[:,1] .- M_full[:,1]) / norm(M_full[:,1])","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"for z^f it is","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"norm(M_appx[:,3] .- M_full[:,3]) / norm(M_full[:,3])","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"and for z^s it is","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"norm(M_appx[:,4] .- M_full[:,4]) / norm(M_full[:,4])","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"which confirms the good concordance.","category":"page"},{"location":"build_literate/Linear_Approximation/#Benchmark","page":"Linear Approximation","title":"Benchmark","text":"","category":"section"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"We analyze the execution time for solving the full integro-differential equation:","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"param = (α[end]/Tʳᶠ, 1, 0, m₀ˢ, R₁, R₂ᶠ, Rₓ, R₁, T₂ˢ, G)\nprob = DDEProblem(apply_hamiltonian_gbloch!, m0_5D, mfun, (0.0, Tʳᶠ), param)\n@benchmark solve($prob)","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"The $ symbol interpolates the variable, which improves the accuracy of the timing measurement. We can compare this time to the time it takes to calculate the linear approximation, including the time it takes to evaluate the interpolated R₂ˢˡ:","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"@benchmark exp(hamiltonian_linear($(α[end]/Tʳᶠ), 1, 0, $Tʳᶠ, $m₀ˢ, $R₁, $R₂ᶠ, $Rₓ, $R₁, R₂ˢˡ($Tʳᶠ, $α[end], 1, $T₂ˢ))) * $m0_6D","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"We can see that linear approximation is about 4 orders of magnitude faster compared to the full model.","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"","category":"page"},{"location":"build_literate/Linear_Approximation/","page":"Linear Approximation","title":"Linear Approximation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"EditURL = \"../tutorial_pulsetrain.jl\"","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"(Image: )","category":"page"},{"location":"build_literate/tutorial_pulsetrain/#Balanced-Hybrid-State-Free-Precession-Pulse-Sequence","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"","category":"section"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"This section explains the interface for calculating the spin evolution during a train of RF pulses, assuming balanced gradient moments (cf. Hybrid-state free precession in nuclear magnetic resonance). For this, we need the following packages:","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"using MRIgeneralizedBloch\nusing MAT\nusing Plots\nplotlyjs(bg = RGBA(31/255,36/255,36/255,1.0), ticks=:native); #hide\nnothing #hide","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"and we use the pulse train described in the paper Rapid quantitative magnetization transfer imaging: utilizing the hybrid state and the generalized Bloch model:","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"control = matread(normpath(joinpath(pathof(MRIgeneralizedBloch), \"../../docs/control_MT_v3p2_TR3p5ms_discretized.mat\")))\nα   = control[\"alpha\"]\nTRF = control[\"TRF\"];\nnothing #hide","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"and","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"TR = 3.5e-3; # S\nnothing #hide","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"The control has the following shape:","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"t = TR .* (1:length(TRF))\np1 = plot(t, α/π, ylabel=\"α/π\", label=:none)\np2 = plot(t, TRF, xlabel=\"t (s)\", ylabel=\"TRF (s)\", label=:none)\np = plot(p1, p2, layout=(2,1))\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"We simulate the signal for the following biophysical parameters:","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"m0s = 0.15\nR1f = 0.5   # 1/s\nR2f = 15    # 1/s\nRx = 30     # 1/s\nR1s = 3     # 1/s\nT2s = 10e-6 # s\nω0 = 0      # rad/s\nB1 = 1;     # in units of B1_nominal\nnothing #hide","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"For speed purposes, it is advisable to use the linear approximation of the generalized Bloch model, which requires a precomputed R_2^sl","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"R2slT = precompute_R2sl();\nnothing #hide","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"Now we have everything set up to calculate the signal:","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"s_linapp = calculatesignal_linearapprox(α, TRF, TR, ω0, B1, m0s, R1f, R2f, Rx, R1s, T2s, R2slT)","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"By default, the output is a complex valued array where each element describes the transversal magnetization x^f + i y^f of the free spin pool in each T_textR. With ω_0 = 0, however, the imaginary part of the signal vanishes:","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"p = plot(xlabel=\"t (s)\", ylabel=\"signal (normalized)\"; legend=:topleft)\nplot!(p, t, real.(vec(s_linapp)), label=\"Re(s); lin. approx.\")\nplot!(p, t, imag.(vec(s_linapp)), label=\"Im(s); lin. approx.\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"For comparison, we can also solve the full integro-differential equation (IDE) for each RF pulse, which is more accurate, but much slower:","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"s_ide = calculatesignal_gbloch_ide(α, TRF, TR, ω0, B1, m0s, R1f, R2f, Rx, R1s, T2s)\n\nplot!(p, t, real.(vec(s_ide)), label=\"Re(s); IDE\")\nplot!(p, t, imag.(vec(s_ide)), label=\"Im(s); IDE\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"Clicking on the legend entries allows to select and de-select individual graphs.","category":"page"},{"location":"build_literate/tutorial_pulsetrain/#Real-valued-magnetization-vector","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Real-valued magnetization vector","text":"","category":"section"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"As an alternative to the complex-valued signal, we can also calculate the full magnetization vector (x^f y^f z^f x^s z^s 1) by supplying the keyword argument output=:realmagnetization. Here, x, y, z denote the dimensions in space, the superscripts f and s denote the free and the semi-solid spin pool, respectively. We neglect the y^s component, assuming (without loss of generality) ωₓ = 0 and given that R_2^sl gg ω_0.","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"m_linapp = calculatesignal_linearapprox(α, TRF, TR, ω0, B1, m0s, R1f, R2f, Rx, R1s, T2s, R2slT;\n    output=:realmagnetization)\n\np = plot(xlabel=\"t (s)\", ylabel=\"magnetization (normalized)\"; legend=:topleft)\nplot!(p, t, [m_linapp[i][1] for i=1:size(m_linapp,1)] ./ (1 - m0s), label=\"xᶠ / m₀ᶠ\")\nplot!(p, t, [m_linapp[i][2] for i=1:size(m_linapp,1)] ./ (1 - m0s), label=\"yᶠ / m₀ᶠ\")\nplot!(p, t, [m_linapp[i][3] for i=1:size(m_linapp,1)] ./ (1 - m0s), label=\"zᶠ / m₀ᶠ\")\nplot!(p, t, [m_linapp[i][4] for i=1:size(m_linapp,1)] ./      m0s , label=\"xˢ / m₀ˢ\")\nplot!(p, t, [m_linapp[i][5] for i=1:size(m_linapp,1)] ./      m0s , label=\"zˢ / m₀ˢ\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/tutorial_pulsetrain/#Gradients","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Gradients","text":"","category":"section"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"The same interface can also be used to calculate the derivatives of the signal wrt. the biophysical parameters. One can specify any subset of derivatives in any order with a vector of identifier objects:","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"grad_list=[grad_m0s(), grad_R1f(), grad_R2f(), grad_Rx(), grad_R1s(), grad_T2s(), grad_ω0(), grad_B1()];\nnothing #hide","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"Calling the function calculatesignal_linearapprox with the keyword argument grad_list and this vector","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"s_linapp = calculatesignal_linearapprox(α, TRF, TR, ω0, B1, m0s, R1f, R2f, Rx, R1s, T2s, R2slT;\n    grad_list=grad_list);\nnothing #hide","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"returns the derivatives in the specified order:","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"p = plot(xlabel=\"t (s)\", ylabel=\"signal (normalized)\"; legend=:topleft)\nplot!(p, t, real.(s_linapp[:,1,1]       ), label=\"Re(∂s/∂M₀ )*M₀\")\nplot!(p, t, real.(s_linapp[:,1,2] .* m0s), label=\"Re(∂s/∂m₀ˢ)*m₀ˢ\")\nplot!(p, t, real.(s_linapp[:,1,3] .* R1f), label=\"Re(∂s/∂R₁ᶠ)*R₁ᶠ\")\nplot!(p, t, real.(s_linapp[:,1,4] .* R2f), label=\"Re(∂s/∂R₂ᶠ)*R₂ᶠ\")\nplot!(p, t, real.(s_linapp[:,1,5] .* Rx ), label=\"Re(∂s/∂Rₓ )*Rₓ \")\nplot!(p, t, real.(s_linapp[:,1,6] .* R1s), label=\"Re(∂s/∂R₁ˢ)*R₁ˢ\")\nplot!(p, t, real.(s_linapp[:,1,7] .* T2s), label=\"Re(∂s/∂T₂ˢ)*T₂ˢ\")\nplot!(p, t, real.(s_linapp[:,1,8] .* ω0 ), label=\"Re(∂s/∂ω₀ )*ω₀ \")\nplot!(p, t, real.(s_linapp[:,1,9] .* B1 ), label=\"Re(∂s/∂B₁ )*B₁ \")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"Note that the first row is always the signal itself, which is equivalent to ∂s/∂M₀, as this toolbox always assumes M₀ = 1.","category":"page"},{"location":"build_literate/tutorial_pulsetrain/#Apparent-R","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Apparent R₁","text":"","category":"section"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"Above code calculates separate derivatives for R_1^f and R_1^s. Yet, many publications, including our own paper \"Rapid quantitative magnetization transfer imaging: utilizing the hybrid state and the generalized Bloch model\" assumes an apparent longitudinal relaxation rate R_1^a = R_1^f = R_1^f. The derivatives wrt. this apparent relaxation rate can be calculated with","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"R1a = 1 # 1/s\ngrad_list=[grad_R1a()]\ns_linapp = calculatesignal_linearapprox(α, TRF, TR, ω0, B1, m0s, R1a, R2f, Rx, R1a, T2s, R2slT;\n    grad_list=grad_list)\n\np = plot(xlabel=\"t (s)\", ylabel=\"signal (normalized)\"; legend=:topleft)\nplot!(p, t, real.(s_linapp[:,1,1]       ), label=\"Re(∂s/∂M₀)/M₀\")\nplot!(p, t, real.(s_linapp[:,1,2] .* R1a), label=\"Re(∂s/∂R₁ᵃ)*R₁ᵃ\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"Note that R1a appears here twice in the arguments of the calculatesignal_linearapprox in place of R1f and R1s.","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"","category":"page"},{"location":"build_literate/tutorial_pulsetrain/","page":"Balanced Hybrid-State Free Precession Pulse Sequence","title":"Balanced Hybrid-State Free Precession Pulse Sequence","text":"This page was generated using Literate.jl.","category":"page"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"EditURL = \"../Greens_functions.jl\"","category":"page"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"(Image: )","category":"page"},{"location":"build_literate/Greens_functions/#Green's-Functions","page":"Green's Functions","title":"Green's Functions","text":"","category":"section"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"The Green's functions are given by the Fourier transform of the corresponding lineshapes. For a Lorentzian lineshape, the Green's function is","category":"page"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"\tG(ttau) = exp (-R_2^s (t-tau))  forall  t geq tau","category":"page"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"for a Gaussian lineshape it is","category":"page"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"\tG(ttau) = exp(- R_2^s^2 (t-tau)^2  2))","category":"page"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"and for super-Lorentzian lineshape it is","category":"page"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"\tG(ttau) = int_0^1 exp left(- R_2^s^2 (t - tau)^2 cdot  frac(3 zeta^2 - 1)^28 right) dzeta","category":"page"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"As evident from these equations, the Green's functions are merely a function of kappa = R_2^s cdot (t - tau) = (t - tau)  T_2^s, and in this package we implemented the functions as such: greens_lorentzian(κ), greens_gaussian(κ), and greens_superlorentzian(κ). These functions can be used to reproduce Fig. 1 in the generalized Bloch paper:","category":"page"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"using MRIgeneralizedBloch\nusing Plots\nplotlyjs(bg = RGBA(31/255,36/255,36/255,1.0), ticks=:native); #hide\nnothing #hide","category":"page"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"T₂ˢ = 10e-6 # s\nt = 0 : 1e-6 : 1e-3\np = plot(yaxis=:log, ylim=(1e-6,1), xlabel=\"(t-τ) [ms]\", ylabel=\"G((t-τ)/T₂ˢ)\")\nplot!(p, 1e3t, greens_lorentzian.(t ./ T₂ˢ), label=\"Lorentzian lineshape\")\nplot!(p, 1e3t, greens_gaussian.(t ./ T₂ˢ), label=\"Gaussian lineshape\")\nplot!(p, 1e3t, greens_superlorentzian.(t ./ T₂ˢ), label=\"super-Lorentzian l.\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"","category":"page"},{"location":"build_literate/Greens_functions/","page":"Green's Functions","title":"Green's Functions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"EditURL = \"../tutorial_singlepulse.jl\"","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"(Image: )","category":"page"},{"location":"build_literate/tutorial_singlepulse/#Simulation-of-a-Single-RF-Pulse","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"","category":"section"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"The core of generalized Bloch model is implemented in the function apply_hamiltonian_gbloch!(∂m∂t, m, mfun, p, t), which calculates the derivative ∂m/∂t for a given magnetization vector m and stores it in-place in the variable ∂m∂t. The function interface is written in a format that can be fed directly into a differential equation solver of the DifferentialEquations.jl package.","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"We need the following packages for this tutorial:","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"using MRIgeneralizedBloch\nusing DifferentialEquations\nusing SpecialFunctions\nusing QuadGK\nusing Plots\nplotlyjs(bg = RGBA(31/255,36/255,36/255,1.0), ticks=:native); #hide\nnothing #hide","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"and we define the properties of a coupled spin system:","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"m0s = 0.15\nR1f = 0.5 # 1/s\nR2f = 13 # 1/s\nR1s = 3 # 1/s\nT2s = 12e-6 # s\nRx = 17; # 1/s\nnothing #hide","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"For most parts of this tutorial, we assume a perfectly calibrated, on-resonant RF-pulse:","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"B1 = 1\nω0 = 0; # rad/s\nnothing #hide","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"as well as a super-Lorentzian lineshape. We interpolate the corresponding Green's function in the range TRF ∈ [0, 1000 ⋅ T2s] to improve performance:","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"G = interpolate_greens_function(greens_superlorentzian, 0, 1000);\nnothing #hide","category":"page"},{"location":"build_literate/tutorial_singlepulse/#Rectangular-RF-Pulses","page":"Simulation of a Single RF Pulse","title":"Rectangular RF-Pulses","text":"","category":"section"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"First, we simulate a rectangular RF-pulse with a constant ω1:","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"α = π # rad\nTRF = 500e-6 # s\nω1 = α/TRF # rad/s","category":"page"},{"location":"build_literate/tutorial_singlepulse/#Isolated-Semi-Solid-Spin-Pool","page":"Simulation of a Single RF Pulse","title":"Isolated Semi-Solid Spin Pool","text":"","category":"section"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"The first example demonstrates how to simulate an isolated semi-solid spin pool for which the magnetization vector is defined by m = [zs; 1]. The appended 1 facilitates a more compact implementation of longitudinal relaxation to a non-zero thermal equilibrium. Here, we initialize the magnetization with the thermal equilibrium:","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"m0 = [1; 1];\nnothing #hide","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"The generalized Bloch model is a so-called integro-differential equation where the derivative mt at the time t_1 does not just depend on m(t_1), but on m(t) with t in 0 t_1. This is solved with a delay differential equation (DDE) solver that stores an interpolated history function mfun(p, t), which we use in the apply_hamiltonian_gbloch! function to evaluate the integral. This history function has to be initialized with","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"mfun(p, t) = m0;\nnothing #hide","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"For slight performance improvements, we could also initialize the history function with mfun(p, t; idxs=nothing) = typeof(idxs) <: Number ? m0[idxs] : m0. This syntax allows for direct indexing of the history function in apply_hamiltonian_gbloch!, which improves performance. Following the syntax of the DifferentialEquations.jl package, we can define and solve the differential equation:","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"param = (ω1, B1, ω0, R1s, T2s, G) # defined by apply_hamiltonian_gbloch!\nprob = DDEProblem(apply_hamiltonian_gbloch!, m0, mfun, (0, TRF), param)\nz_gBloch = solve(prob)","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"The function apply_hamiltonian_gbloch! is implemented such that it infers from param = (ω1, B1, ω0, R1s, T2s, G) that you are only supplying the relaxation properties of the semi-solid spin pool and hence it simulates the spin dynamics of an isolated semi-solid spin pool. The DifferentialEquations.jl package also implements a plot function for the solution object, which can be used to display the result:","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"p = plot(z_gBloch, xlabel=\"t [s]\", ylabel=\"zˢ(t)\", idxs=1, label=\"g. Bloch\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"For comparison, we can simulate the signal with Graham's spectral model, which describes an exponential saturation with the rate","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"f_ω1(t) = ω1\nRʳᶠ = graham_saturation_rate_spectral(ω0 -> lineshape_superlorentzian(ω0, T2s), f_ω1, TRF, ω0) # 1/s","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"The function graham_saturation_rate_spectral calculates the spectral power density S(ω₀,Δω,ω₁(t)) of the RF-pulse with an off-resonance frequency Δω and a pulse shape ω₁(t). The spectral power density is the squared absolute value of the pulse's Fourier transform, divided by the pulse duration. Thereafter, the function calculates the integral","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"Rʳᶠ = int_-^+ dω₀ S(ω₀Δωω₁(t)) g(ω₀ T₂ˢ) ","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"where g(ω₀, T₂ˢ) is the spectral lineshape of the spin pool. Given this saturation rate, we can simply solve the ordinary differential equation ∂z/∂t = R₁ (1 - z) - Rʳᶠ z, which has the following analytical solution:","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"z_Graham(t) = (Rʳᶠ * exp(-t * (R1s + Rʳᶠ)) + R1s) / (R1s + Rʳᶠ)\nplot!(p, z_Graham, 0, TRF, label=\"Graham\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"This plot reveals a substantial difference between Graham's spectral model and the generalized Bloch model at the example of a 500μs inversion pulse, as, e.g., used in our in vivo experiments. This also entails a substantial difference in the z-magnetization of the semi-solid spin pool at the end of the RF-pulse:","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"z_gBloch(TRF)[1]","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"z_Graham(TRF)","category":"page"},{"location":"build_literate/tutorial_singlepulse/#Coupled-Spin-System","page":"Simulation of a Single RF Pulse","title":"Coupled Spin System","text":"","category":"section"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"For a coupled spin system, the magnetization vector is defined as m = [xf; yf; zf; zs; 1] and the thermal equilibrium magnetization is given by:","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"m0 = [0; 0; 1-m0s; m0s; 1];\nnothing #hide","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"To indicate to the apply_hamiltonian_gbloch! function that we would like to simulate a coupled spin system, we simple provide it with the properties of both pools in the following format:","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"param = (ω1, B1, ω0, m0s, R1f, R2f, Rx, R1s, T2s, G);\nnothing #hide","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"Thereafter, we can use the same function calls as above to simulate the spin dynamics:","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"prob = DDEProblem(apply_hamiltonian_gbloch!, m0, mfun, (0, TRF), param)\nm_gBloch = solve(prob)\np = plot(m_gBloch, xlabel=\"t [s]\", ylabel=\"m(t)\", idxs=1:4, labels=[\"xᶠ\" \"yᶠ\" \"zᶠ\" \"zˢ\"])\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/tutorial_singlepulse/#Shaped-RF-Pulses","page":"Simulation of a Single RF Pulse","title":"Shaped RF-Pulses","text":"","category":"section"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"The function apply_hamiltonian_gbloch! also allows for the simulation of RF-pulses with arbitrary shapes. To this end, ω₁(t) has to be defined as a function that takes time in seconds as an input and returns ω₁ at this particular point in time. For example, we can define a 1ms sinc-pulse:","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"TRF = 1e-3 # s\nNSideLobes = 1\nf_ω1(t) = sinc(2(NSideLobes+1) * t/TRF - (NSideLobes+1)) * α / (sinint((NSideLobes+1)π) * TRF/π / (NSideLobes+1))\np = plot(f_ω1, 0, TRF, xlabel=\"t [s]\", ylabel=\"ω₁(t)\", labels=:none)\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"NSideLobes defines here the number of side lobes on each side as can be seen in the plot. With numerical integration we can check if the RF-pulse has the correct flip angle:","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"quadgk(f_ω1, 0, TRF)[1] / α","category":"page"},{"location":"build_literate/tutorial_singlepulse/#Isolated-Semi-Solid-Spin-Pool-2","page":"Simulation of a Single RF Pulse","title":"Isolated Semi-Solid Spin Pool","text":"","category":"section"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"In order to calculate the spin dynamics of an isolated semi-solid spin pool during this shaped RF-pulse, we define the same tuple param as we did in Section Rectangular RF-Pulses with the only difference that the first element is a subtype of the abstract type Function:","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"param = (f_ω1, B1, ω0, R1s, T2s, G)\ntypeof(f_ω1) <: Function","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"With this definition of param, we can use the same function call as we did before:","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"m0 = [1; 1]\nprob = DDEProblem(apply_hamiltonian_gbloch!, m0, mfun, (0, TRF), param)\nz_gBloch = solve(prob)\np = plot(z_gBloch, xlabel=\"t [s]\", ylabel=\"zˢ(t)\", idxs=1, label=\"g. Bloch\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"For comparison, we can simulate the signal with Graham's spectral model, which describes an exponential saturation with the rate","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"Rʳᶠ = graham_saturation_rate_spectral(ω0 -> lineshape_superlorentzian(ω0, T2s), f_ω1, TRF, ω0)","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"z_Graham(t) = (Rʳᶠ * exp(-t * (R1s + Rʳᶠ)) + R1s) / (R1s + Rʳᶠ)\nplot!(p, z_Graham, 0, TRF, label=\"Graham\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"z_gBloch(TRF)[1]","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"z_Graham(TRF)","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"The difference between Graham's model and the generalized Bloch model is more pronounced for this 1ms sinc-inversion pulse compared to the 500μs rectangular inversion pulse. We note, however, that the peak pulse amplitude of the sinc-pulse is higher and potentially too high clinical MRI systems.","category":"page"},{"location":"build_literate/tutorial_singlepulse/#Coupled-Spin-System-2","page":"Simulation of a Single RF Pulse","title":"Coupled Spin System","text":"","category":"section"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"We can perform the same change to param to simulate a coupled spin system:","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"param = (f_ω1, B1, ω0, m0s, R1f, R2f, Rx, R1s, T2s, G)\nm0 = [0; 0; 1-m0s; m0s; 1]\nprob = DDEProblem(apply_hamiltonian_gbloch!, m0, mfun, (0, TRF), param)\nm_gBloch = solve(prob)\np = plot(m_gBloch, xlabel=\"t [s]\", ylabel=\"m(t)\", idxs=1:4, labels=[\"xᶠ\" \"yᶠ\" \"zᶠ\" \"zˢ\"])\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"Double click on zˢ in the legend to isolate the semi-solid spin pool in the plot and compare the simulation to the last section.","category":"page"},{"location":"build_literate/tutorial_singlepulse/#ω-Sweep-or-Adiabatic-RF-Pulses","page":"Simulation of a Single RF Pulse","title":"ω₀-Sweep or Adiabatic RF-Pulses","text":"","category":"section"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"The apply_hamiltonian_gbloch!(∂m∂t, m, mfun, p, t) function is also implemented for RF-pulses with a varying RF frequency ω₀(t) as, e.g., used in adiabatic pulses. In order to simulate such pulses, the first element of param has to be ω₁(t)::Function like for Shaped RF-Pulses and, additionally, the third element has to be φ::Function instead of ω₀::Number. Notice two differences here: first, the (abstract) type Function instead of Number will tell the compiler to use the adiabatic-pulse implementation. Second, this implementation requires the phase of the RF-pulse as function of time φ(t) instead of the frequency because φ(t) ≠ ω₀(t) ⋅ t, if ω₀ is a function of time.","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"To demonstrate the interface at a practical example, we can defined a hyperbolic secant adiabatic inversion pulse:","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"TRF = 10.24e-3 # s\nγ = 267.522e6 # gyromagnetic ratio in rad/s/T\nω₁ᵐᵃˣ = 13e-6 * γ # rad/s\nμ = 5 # shape parameter in rad\nβ = 674.1 # shape parameter in 1/s\n\nf_ω1(t) = ω₁ᵐᵃˣ * sech(β * (t - TRF/2)) # rad/s\nf_ω0(t) = -μ * β * tanh(β * (t - TRF/2)) # rad/s\nf_φ(t)  = -μ * log(cosh(β * t) - sinh(β*t) * tanh(β*TRF/2)); # rad\nnothing #hide","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"For this example, we analytically solved the integral φ(t) = int_0^t ω₀(τ) dτ.","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"This pulse a hyperbolic secant amplitude:","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"p = plot(f_ω1, 0, TRF, xlabel=\"t [s]\", ylabel=\"ω₁(t) [rad/s]\", labels=:none)\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"and hyperbolic tangent frequency sweep","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"p = plot(f_ω0, 0, TRF, xlabel=\"t [s]\", ylabel=\"ω₀(t) [rad/s]\", labels=:none)\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"As explained above, we actually don't use the frequency in the implementation. Instead, we use the RF-phase:","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"p = plot(f_φ, 0, TRF, xlabel=\"t [s]\", ylabel=\"φ(t) [rad]\", labels=:none)\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"This interface, of course, also allows for the simulation of an isolated semi-solid spin pool with above described modifications to param. For brevity, however, we here directly simulate a coupled spin pool starting from thermal equilibrium:","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"m0 = [0, 0, 1-m0s, m0s, 1]\np = (f_ω1, B1, f_φ, m0s, R1f, R2f, Rx, R1s, T2s, G)\nm_gBloch = solve(DDEProblem(apply_hamiltonian_gbloch!, m0, mfun, (0, TRF), p))\np = plot(m_gBloch, xlabel=\"t [s]\", ylabel=\"m(t)\", idxs=1:4, labels=[\"xᶠ\" \"yᶠ\" \"zᶠ\" \"zˢ\"])\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"This simulation shows the intended inversion of the free spin pool and a near complete saturation of the semi-solid spin pool (double click on the corresponding legend entry). The transversal magnetization of the free pool exhibits some oscillations and at this point I should highlight a distinct difference between the implementation for adiabatic RF-pulses the above described implementation for constant ω₀: the latter case uses a frame of references that rotates with the RF-frequency about the z-axis, i.e. the RF-pulses rotate the magnetization  with ω₁ about the y-axis and, additionally, the magnetizations rotates with ω₀ about the z-axis. The implementation of the adiabatic pulses uses a rotating frame of reference that is on resonance with the Larmor frequency of the spin isochromat and the phase of the RF-pulse rotates with ω₀(t). To simulate off-resonance, we can simply add a static value to above function or, more precisely, add a phase slope to φ:","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"Δω0 = 1000 # rad/s\nf_φ_or(t) = f_φ(t) + Δω0 * t; # rad\nnothing #hide","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"We can, additionally, change B1 to demonstrate the robustness of adiabatic pulses:","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"B1 = 1.2 # 20% miss-calibration\np = (f_ω1, B1, f_φ_or, m0s, R1f, R2f, Rx, R1s, T2s, G)\nm_gBloch = solve(DDEProblem(apply_hamiltonian_gbloch!, m0, mfun, (0, TRF), p))\np = plot(m_gBloch, xlabel=\"t [s]\", ylabel=\"m(t)\", idxs=1:4, labels=[\"xᶠ\" \"yᶠ\" \"zᶠ\" \"zˢ\"])\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"While the spin dynamics during the pulse is changed, the final magnetization of the free pool is approximately the same compared to the on-resonant isochromat with B1 = 1. The final magnetization of the semi-solid spin pool is, like before, close to zero, but a close look reveals a small negative zˢ-magnetization (double click on zˢ in the plot's legend). The difference to the previous simulation highlights that the dynamics of semi-solid spin pool is not adiabatic and does depend on B₁.","category":"page"},{"location":"build_literate/tutorial_singlepulse/#Transversal-Magnetization-of-the-Semi-Solid-Spin-Pool","page":"Simulation of a Single RF Pulse","title":"Transversal Magnetization of the Semi-Solid Spin Pool","text":"","category":"section"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"Throughout this tutorial, we only ever calculated and plotted the longitudinal magnetization of the semi-solid spin pool. This is foremost a result of way we formulate and solve the generalized Bloch equations (cf. Eq. (9) in the paper). But this implementation is also reflective of the standard use-case in magnetization transfer imaging, where we are foremost interested in the longitudinal magnetization of the semi-solid spin pool and its effect on the free spin pool. If required, however, it is easily possible to calculate the transversal magnetization with Eqs. (4-5) from the paper:","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"ωx(t) = -B1 * f_ω1(t) * sin(f_φ_or(t))\nωy(t) =  B1 * f_ω1(t) * cos(f_φ_or(t))\nzs_gBloch(t) = m_gBloch(t)[4]\nxs_gBloch(t) = quadgk(τ -> G((t - τ) / T2s) * ωx(τ) * zs_gBloch(τ), 0, t)[1]\nys_gBloch(t) = quadgk(τ -> G((t - τ) / T2s) * ωy(τ) * zs_gBloch(τ), 0, t)[1];\nnothing #hide","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"The last two lines calculate the numerical integral of the Green's function multiplied by the oscillating RF-fields. Similar code is also used in the implementation of apply_hamiltonian_gbloch!. Plotting these functions reveals the spin dynamics of the semi-solid spin pool:","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"p = plot(xs_gBloch, 0, TRF, xlabel=\"t [s]\", ylabel=\"m(t)\", label=\"xˢ\")\nplot!(p, ys_gBloch, 0, TRF, label=\"yˢ\")\nplot!(p, zs_gBloch, 0, TRF, label=\"zˢ\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"More details about the interface, including the linear approximation of the generalized Bloch model can found in the following scripts that replicate all simulations, data analyses, and figures of the generalized Bloch paper.","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"","category":"page"},{"location":"build_literate/tutorial_singlepulse/","page":"Simulation of a Single RF Pulse","title":"Simulation of a Single RF Pulse","text":"This page was generated using Literate.jl.","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"EditURL = \"../Simulation_Pulse.jl\"","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"(Image: )","category":"page"},{"location":"build_literate/Simulation_Pulse/#RF-Pulse-Simulation","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"","category":"section"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"The following code replicates the RF-pulse simulation of Fig. 3 and plots the z^s-magnetization at the end of respective pulse.","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"For these simulations we need the following packages:","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"using MRIgeneralizedBloch\nusing QuadGK\nusing DifferentialEquations\nusing SpecialFunctions\nusing Plots\nplotlyjs(bg = RGBA(31/255,36/255,36/255,1.0), ticks=:native); #hide\nnothing #hide","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"and we simulate an isolated semi-solid spin pool with the following parameters:","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"R₁ = 1 # 1/s\nT₂ˢ = 10e-6; # s\nnothing #hide","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"Here, we simulate π-pulses with the following parameters:","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"α = π\nTʳᶠ = exp.(range(log(2e-7), log(1e-1), length=100)) # s\nω₁ = α ./ Tʳᶠ # rad/s\nω₀ = 0; # rad/s\nnothing #hide","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"Replace first line with α = π/4 or α = π/2 to simulate the other two rows of Fig. 3.","category":"page"},{"location":"build_literate/Simulation_Pulse/#Lorentzian-Lineshape","page":"RF-Pulse Simulation","title":"Lorentzian Lineshape","text":"","category":"section"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"In this script, we simulate the three lineshapes separately, starting with the Lorentzian lineshape for which the Bloch model provides a ground truth.","category":"page"},{"location":"build_literate/Simulation_Pulse/#Bloch-Model","page":"RF-Pulse Simulation","title":"Bloch Model","text":"","category":"section"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"We can formulate the Bloch model as","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"partial_t beginpmatrix x  y  z  1 endpmatrix = beginpmatrix\n-R_2  -ω_0  ω_1  0 \nω_0  -R_2  0  0 \n-ω_1  0  -R_1  R_1 \n0  0  0  0\nendpmatrix beginpmatrix x  y  z  1 endpmatrix ","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"where the matrix is the Hamiltonian of the Bloch model. For a constant ω_0 and ω_1, we can evaluate the Bloch model by taking the  matrix exponential of its Hamiltonian:","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"H(ω₁, ω₀, R₂, R₁) = [-R₂ -ω₀  ω₁  0;\n                      ω₀ -R₂   0  0;\n                     -ω₁   0 -R₁ R₁;\n                       0   0   0  0]\n\nz_Bloch = similar(Tʳᶠ)\nfor i = 1:length(Tʳᶠ)\n    (_, _, z_Bloch[i], _)  = exp(H(ω₁[i], ω₀, 1 / T₂ˢ, R₁) * Tʳᶠ[i]) * [0; 0; 1; 1]\nend","category":"page"},{"location":"build_literate/Simulation_Pulse/#Graham's-Spectral-Model","page":"RF-Pulse Simulation","title":"Graham's Spectral Model","text":"","category":"section"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"Graham's spectral model is derived by integrating over the lineshape multiplied by the spectral response function of the RF-pulse. This results in the RF-induced saturation rate Rʳᶠ that is used in an exponential model:","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"Rʳᶠ = @. ω₁^2 * T₂ˢ * ((exp(-Tʳᶠ / T₂ˢ) -1) * T₂ˢ + Tʳᶠ) / Tʳᶠ\nz_Graham_spec_Lorentzian = @. (Rʳᶠ * exp(-Tʳᶠ * (R₁ + Rʳᶠ)) + R₁) / (R₁ + Rʳᶠ);\nnothing #hide","category":"page"},{"location":"build_literate/Simulation_Pulse/#Graham's-Single-Frequency-Approximation","page":"RF-Pulse Simulation","title":"Graham's Single Frequency Approximation","text":"","category":"section"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"In the single frequency approximation, Graham assumes that the RF-pulse has only a single frequency, which reduces Rʳᶠ to","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"g_Lorentzian(ω₀) = T₂ˢ / π ./ (1 .+ (T₂ˢ .* ω₀).^2)\nRʳᶠ = @. π * ω₁^2 * g_Lorentzian(ω₀)\nz_Graham_SF_approx_Lorentzian = @. (Rʳᶠ * exp(-Tʳᶠ * (R₁ + Rʳᶠ)) + R₁) / (R₁ + Rʳᶠ);\nnothing #hide","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"where g_Lorentzian(ω₀) denotes the Lorentzian lineshape.","category":"page"},{"location":"build_literate/Simulation_Pulse/#Sled's-Model","page":"RF-Pulse Simulation","title":"Sled's Model","text":"","category":"section"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"Sled's model is given by the ordinary differential equation (ODE)","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"partial_t z(t) = left(-pi int_0^t G(t-τ) omega_1(τ)^2 dτ right) z(t)  + R_1 (1-z)","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"where G(t-τ) is the Green's function. The Hamiltonian of this ODE is implemented in apply_hamiltonian_sled! and the ODE can be solved with the DifferentialEquations.jl package:","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"z₀ = [1] # initial z-magnetization\nz_Sled_Lorentzian = similar(Tʳᶠ)\nfor i = 1:length(Tʳᶠ)\n    param = (ω₁[i], 1, ω₀, R₁, T₂ˢ, greens_lorentzian)\n    prob = ODEProblem(apply_hamiltonian_sled!, z₀, (0, Tʳᶠ[i]), param)\n    z_Sled_Lorentzian[i] = solve(prob)[end][1]\nend","category":"page"},{"location":"build_literate/Simulation_Pulse/#Generalized-Bloch-Model","page":"RF-Pulse Simulation","title":"Generalized Bloch Model","text":"","category":"section"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"The generalized Bloch model is given by the integro-differential equation (IDE)","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"partial_t z(t) = - ω_1(t) int_0^t G(tτ) ω_1(τ) z(τ) dτ + R_1 (1 - z(t)) ","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"or by","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"partial_t z(t) = - ω_y(t) int_0^t G(tτ) ω_y(τ) z(τ) dτ - ω_x(t) int_0^t G(tτ) ω_x(τ) z(τ) dτ + R_1 (1 - z(t)) ","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"for off-resonant RF-pulses with ω_1 = ω_x + i ω_y. The Hamiltonian of the IDE is implemented in apply_hamiltonian_gbloch! and we can solve this IDE with the delay-differential equation (DDE) solver of the DifferentialEquations.jl package:","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"z_fun(p, t) = [1.0]; # initialize history function (will be populated with an interpolation by the DDE solver)\n\nz_gBloch_Lorentzian = similar(Tʳᶠ)\nfor i = 1:length(Tʳᶠ)\n    param = (ω₁[i], 1, ω₀, R₁, T₂ˢ, greens_lorentzian)\n    prob = DDEProblem(apply_hamiltonian_gbloch!, z₀, z_fun, (0, Tʳᶠ[i]), param)\n    z_gBloch_Lorentzian[i] = solve(prob)[end][1]\nend","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"Now we have solved all five models and can plot the solutions for comparison:","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"p = plot(xaxis=:log, legend=:bottomright, xlabel=\"Tʳᶠ [s]\", ylabel=\"zˢ(Tʳᶠ)\")\nplot!(p, Tʳᶠ, z_gBloch_Lorentzian, label=\"generalized Bloch model\")\nplot!(p, Tʳᶠ, Tʳᶠ .* 0 .+ cos(α), label=\"cos(α)\")\nplot!(p, Tʳᶠ, z_Sled_Lorentzian, label=\"Sled's model\")\nplot!(p, Tʳᶠ, z_Graham_spec_Lorentzian, label=\"Graham's spectral model\")\nplot!(p, Tʳᶠ, z_Graham_SF_approx_Lorentzian, label=\"Graham's single frequency approximation\")\nplot!(p, Tʳᶠ, z_Bloch, label=\"Bloch model\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Simulation_Pulse/#Gaussian-Lineshape","page":"RF-Pulse Simulation","title":"Gaussian Lineshape","text":"","category":"section"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"We can repeat these simulations (with the exception of the Bloch model) for the Gaussian lineshape:","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"Rʳᶠ = @. ω₁^2 * T₂ˢ * (2 * T₂ˢ * (exp(-(Tʳᶠ/T₂ˢ)^2/2)-1) + sqrt(2π) * Tʳᶠ * erf(Tʳᶠ/T₂ˢ/sqrt(2))) / (2 * Tʳᶠ)\nz_Graham_spec_Gaussian = @. (Rʳᶠ * exp(-Tʳᶠ * (R₁ + Rʳᶠ)) + R₁) / (R₁ + Rʳᶠ)\n\ng_Gaussian(ω₀) = T₂ˢ / sqrt(2π) * exp(-(T₂ˢ * ω₀)^2 / 2) # lineshape\nRʳᶠ = @. π * ω₁^2 * g_Gaussian(ω₀)\nz_Graham_SF_approx_Gaussian = @. (Rʳᶠ * exp(-Tʳᶠ * (R₁ + Rʳᶠ)) + R₁) / (R₁ + Rʳᶠ)\n\nz_Sled_Gaussian = similar(Tʳᶠ)\nfor i = 1:length(Tʳᶠ)\n    param = (ω₁[i], 1, ω₀, R₁, T₂ˢ, greens_gaussian)\n    prob = ODEProblem(apply_hamiltonian_sled!, z₀, (0, Tʳᶠ[i]), param)\n    z_Sled_Gaussian[i] = solve(prob)[end][1]\nend\n\nz_gBloch_Gaussian = similar(Tʳᶠ)\nfor i = 1:length(Tʳᶠ)\n    param = (ω₁[i], 1, ω₀, R₁, T₂ˢ, greens_gaussian)\n    prob = DDEProblem(apply_hamiltonian_gbloch!, z₀, z_fun, (0, Tʳᶠ[i]), param)\n    z_gBloch_Gaussian[i] = solve(prob)[end][1]\nend\n\np = plot(xaxis=:log, legend=:bottomright, xlabel=\"Tʳᶠ [s]\", ylabel=\"zˢ(Tʳᶠ)\")\nplot!(p, Tʳᶠ, z_gBloch_Gaussian, label=\"generalized Bloch model\")\nplot!(p, Tʳᶠ, Tʳᶠ .* 0 .+ cos(α), label=\"cos(α)\")\nplot!(p, Tʳᶠ, z_Sled_Gaussian, label=\"Sled's model\")\nplot!(p, Tʳᶠ, z_Graham_spec_Gaussian, label=\"Graham's spectral model\")\nplot!(p, Tʳᶠ, z_Graham_SF_approx_Gaussian, label=\"Graham's single frequency approximation\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Simulation_Pulse/#Super-Lorentzian-Lineshape","page":"RF-Pulse Simulation","title":"Super-Lorentzian Lineshape","text":"","category":"section"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"Further, we can repeat these simulations for the super-Lorentzian lineshape with the exception of Graham's single frequency approximation, as the super-Lorentzian lineshape diverges at ω_0  0.","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"G_superLorentzian = interpolate_greens_function(greens_superlorentzian, 0, maximum(Tʳᶠ)/T₂ˢ)\n\nf_PSD(τ) = quadgk(ct -> (4 / τ / abs(1 - 3 * ct^2) * (exp(- τ^2 / 8 * (1 - 3 * ct^2)^2) - 1) + sqrt(2π) * erf(τ / 2 / sqrt(2) * abs(1 - 3 * ct^2))) / abs(1 - 3 * ct^2), 0.0, 1.0)[1]\nRʳᶠ = @. f_PSD(Tʳᶠ / T₂ˢ) * ω₁^2 * T₂ˢ\nz_Graham_spec_superLorentzian = @. (Rʳᶠ * exp(-Tʳᶠ * (R₁ + Rʳᶠ)) + R₁) / (R₁ + Rʳᶠ)\n\nz_Sled_superLorentzian = similar(Tʳᶠ)\nfor i = 1:length(Tʳᶠ)\n    param = (ω₁[i], 1, ω₀, R₁, T₂ˢ, G_superLorentzian)\n    prob = ODEProblem(apply_hamiltonian_sled!, z₀, (0, Tʳᶠ[i]), param)\n    z_Sled_superLorentzian[i] = solve(prob)[end][1]\nend\n\nz_gBloch_superLorentzian = similar(Tʳᶠ)\nfor i = 1:length(Tʳᶠ)\n    param = (ω₁[i], 1, ω₀, R₁, T₂ˢ, G_superLorentzian)\n    prob = DDEProblem(apply_hamiltonian_gbloch!, z₀, z_fun, (0, Tʳᶠ[i]), param)\n    z_gBloch_superLorentzian[i] = solve(prob)[end][1]\nend\n\np = plot(xaxis=:log, legend=:bottomright, xlabel=\"Tʳᶠ [s]\", ylabel=\"zˢ(Tʳᶠ)\")\nplot!(p, Tʳᶠ, z_gBloch_superLorentzian, label=\"generalized Bloch model\")\nplot!(p, Tʳᶠ, Tʳᶠ .* 0 .+ cos(α), label=\"cos(α)\")\nplot!(p, Tʳᶠ, z_Sled_superLorentzian, label=\"Sled's model\")\nplot!(p, Tʳᶠ, z_Graham_spec_superLorentzian, label=\"Graham's spectral model\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"This simulation reveals the most pronounced deviations of the generalized Bloch model from established models due to the slower decay of the super-Lorentzian Green's function.","category":"page"},{"location":"build_literate/Simulation_Pulse/#Error-Analysis","page":"RF-Pulse Simulation","title":"Error Analysis","text":"","category":"section"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"Assuming a super-Lorentzian lineshape, we quantify the deviations of Sled's model from the generalized Bloch model:","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"Tʳᶠᵢ = 1e-3 # s\nω₁ᵢ = α / Tʳᶠᵢ # rad/s\nparam = (ω₁ᵢ, 1, ω₀, R₁, T₂ˢ, G_superLorentzian)\n\nprob = ODEProblem(apply_hamiltonian_sled!, z₀, (0, Tʳᶠᵢ), param)\nz_Sled_superLorentzian_i = solve(prob)[end][1]\n\nprob = DDEProblem(apply_hamiltonian_gbloch!, z₀, z_fun, (0, Tʳᶠᵢ), param)\nz_gBloch_superLorentzian_i = solve(prob)[end][1]\n\nz_Sled_superLorentzian_i - z_gBloch_superLorentzian_i","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"For T_textRF = 1ms, the deviations are small compared to the thermal equilibrium magnetization z^s_0 = 1, but with T_textRF = 01ms, this deviation becomes sizable:","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"Tʳᶠᵢ = 1e-4 # s\nω₁ᵢ = α / Tʳᶠᵢ # rad/s\nparam = (ω₁ᵢ, 1, ω₀, R₁, T₂ˢ, G_superLorentzian)\n\nprob = ODEProblem(apply_hamiltonian_sled!, z₀, (0, Tʳᶠᵢ), param)\nz_Sled_superLorentzian_i = solve(prob)[end][1]\n\nprob = DDEProblem(apply_hamiltonian_gbloch!, z₀, z_fun, (0, Tʳᶠᵢ), param)\nz_gBloch_superLorentzian_i = solve(prob)[end][1]\n\nz_Sled_superLorentzian_i - z_gBloch_superLorentzian_i","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"","category":"page"},{"location":"build_literate/Simulation_Pulse/","page":"RF-Pulse Simulation","title":"RF-Pulse Simulation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"EditURL = \"../Simulation_ContinuousWave.jl\"","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"(Image: )","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/#Continuous-Wave-Simulation","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"","category":"section"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"The following code replicates the continuous wave simulation of Fig. 2 and is slightly more comprehensive in the sense that all discussed models are simulated.","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"For these simulations we need the following packages:","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"using MRIgeneralizedBloch\nusing DifferentialEquations\nusing QuadGK\nusing Plots\nplotlyjs(bg = RGBA(31/255,36/255,36/255,1.0), ticks=:native); #hide\nnothing #hide","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"and we simulate an isolated semi-solid spin pool with the following parameters:","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"R₁ = 1.0 # 1/s\nT₂ˢ = 10e-6 # s\n\nTʳᶠ = 2e-3 # s\nω₁ = 2000π # rad/s\nω₀ = 200π # rad/s\n\nt = range(0, Tʳᶠ, length=1001) # time points for plotting\ntspan = (0.0, Tʳᶠ); # simulation range\nnothing #hide","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"These parameters correspond to Fig. 2b, the parameters for replicating Fig. 2a are ω₁ = 200π and Tʳᶠ = 1s.","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/#Lorentzian-Lineshape","page":"Continuous Wave Simulation","title":"Lorentzian Lineshape","text":"","category":"section"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"In this script, we simulate the three lineshapes separately, starting with the Lorentzian lineshape for which the Bloch model provides a ground truth.","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/#Bloch-Model","page":"Continuous Wave Simulation","title":"Bloch Model","text":"","category":"section"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"We can formulate the Bloch model as","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"partial_t beginpmatrix x  y  z  1 endpmatrix = beginpmatrix\n-R_2  -ω_0  ω_1  0 \nω_0  -R_2  0  0 \n-ω_1  0  -R_1  R_1 \n0  0  0  0\nendpmatrix beginpmatrix x  y  z  1 endpmatrix ","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"where the matrix is the Hamiltonian of the Bloch model. For a constant ω_0 and ω_1, we can evaluate the Bloch model by taking the  matrix exponential of its Hamiltonian:","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"H(ω₁, ω₀, R₂, R₁) = [-R₂  -ω₀  ω₁  0;\n                       ω₀ -R₂   0  0;\n                      -ω₁   0 -R₁ R₁;\n                        0   0   0  0]\n\nz_Bloch = similar(t)\nfor i = 1:length(t)\n    (_, _, z_Bloch[i], _) = exp(H(ω₁, ω₀, 1 / T₂ˢ, R₁) * t[i]) * [0; 0; 1; 1]\nend","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/#Henkelman's-Steady-State-Solution","page":"Continuous Wave Simulation","title":"Henkelman's Steady-State Solution","text":"","category":"section"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"When assuming an isolated semi-solid pool, Eq. (9) in Henkelman, R. Mark, et al. \"Quantitative interpretation of magnetization transfer.\" Magnetic resonance in medicine 29.6 (1993): 759-766 reduces to","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"g_Lorentzian(ω₀) = T₂ˢ / π / (1 + (T₂ˢ * ω₀)^2)\nz_steady_state_Lorentzian = R₁ / (R₁ + π * ω₁^2 * g_Lorentzian(ω₀))","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"where g_Lorentzian(ω₀) is the Lorentzian lineshape.","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/#Graham's-Single-Frequency-Approximation","page":"Continuous Wave Simulation","title":"Graham's Single Frequency Approximation","text":"","category":"section"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"The lineshape is also used to calculate Graham's single frequency approximation, which describes an exponential decay with the RF-induced saturation rate Rʳᶠ:","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"Rʳᶠ = π * ω₁^2 * g_Lorentzian(ω₀)\nz_Graham_Lorentzian = @. (Rʳᶠ * exp(-t * (R₁ + Rʳᶠ)) + R₁) / (R₁ + Rʳᶠ);\nnothing #hide","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/#Sled's-Model","page":"Continuous Wave Simulation","title":"Sled's Model","text":"","category":"section"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"Sled's model is given by the ordinary differential equation (ODE)","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"partial_t z(t) = left(-pi int_0^t G(t-τ) omega_1(τ)^2 dτ right) z(t)  + R_1 (1-z)","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"where G(t-τ) is the Green's function. The Hamiltonian of this ODE is implemented in apply_hamiltonian_sled! and we solve this ODE with the DifferentialEquations.jl package:","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"z₀ = [1.0] # initial z-magnetization\nparam = (ω₁, 1, ω₀, R₁, T₂ˢ, greens_lorentzian) # defined by apply_hamiltonian_sled!\nprob = ODEProblem(apply_hamiltonian_sled!, z₀, tspan, param)\nz_Sled_Lorentzian = solve(prob);\nnothing #hide","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/#Generalized-Bloch-Model","page":"Continuous Wave Simulation","title":"Generalized Bloch Model","text":"","category":"section"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"The generalized Bloch model is an integro-differential equation (IDE) as it depends on z(τ) instead of z(t):","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"partial_t z(t) = - ω_1(t) int_0^t G(tτ) ω_1(τ) z(τ) dτ + R_1 (1 - z(t)) ","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"For off-resonant RF-pulses with ω_1 = ω_x + i ω_y, it is given by","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"partial_t z(t) = - ω_y(t) int_0^t G(tτ) ω_y(τ) z(τ) dτ - ω_x(t) int_0^t G(tτ) ω_x(τ) z(τ) dτ + R_1 (1 - z(t)) ","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"The Hamiltonian of the IDE is implemented in apply_hamiltonian_gbloch! and we can solve this IDE with the delay-differential equation (DDE) solver of the DifferentialEquations.jl package:","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"zfun(p, t) = [1.0] # initialize history function (will be populated with an interpolation by the DDE solver)\n\nparam = (ω₁, 1, ω₀, R₁, T₂ˢ, greens_lorentzian) # defined by apply_hamiltonian_gbloch!\nprob = DDEProblem(apply_hamiltonian_gbloch!, z₀, zfun, tspan, param)\nz_gBloch_Lorentzian = solve(prob);\nnothing #hide","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"Now that we have solved all five models, we can plot the solutions for comparison:","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"p = plot(xlabel=\"t [ms]\", ylabel=\"zˢ(t)\")\nplot!(p, 1e3t, zero(similar(t)) .+ z_steady_state_Lorentzian, label=\"Henkelman's steady-state\")\nplot!(p, 1e3t, z_Graham_Lorentzian, label=\"Graham's model\")\nplot!(p, 1e3t, (hcat(z_Sled_Lorentzian(t).u...)'), label=\"Sled's model\")\nplot!(p, 1e3t, (hcat(z_gBloch_Lorentzian(t).u...)'), label=\"generalized Bloch model\")\nplot!(p, 1e3t, z_Bloch, label=\"Bloch model\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"Zooming into the plot, reveals virtually perfect (besides numerical differences) agreement between Bloch and generalized Bloch model and subtle, but existing differences when compared to the other models. Choosing a longer T₂ˢ amplifies these differences.","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/#Gaussian-Lineshape","page":"Continuous Wave Simulation","title":"Gaussian Lineshape","text":"","category":"section"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"We can repeat these simulations (with the exception of the Bloch model) for the Gaussian lineshape:","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"g_Gaussian(ω₀) = T₂ˢ / sqrt(2π) * exp(-(T₂ˢ * ω₀)^2 / 2)\nz_steady_state_Gaussian = R₁ / (R₁ + π * ω₁^2 * g_Gaussian(ω₀))\n\nRʳᶠ = π * ω₁^2 * g_Gaussian(ω₀)\nz_Graham_Gaussian = @. (Rʳᶠ * exp(-t * (R₁ + Rʳᶠ)) + R₁) / (R₁ + Rʳᶠ)\n\nparam = (ω₁, 1, ω₀, R₁, T₂ˢ, greens_gaussian) # defined by apply_hamiltonian_sled!\nprob = ODEProblem(apply_hamiltonian_sled!, z₀, tspan, param)\nz_Sled_Gaussian = solve(prob)\n\nprob = DDEProblem(apply_hamiltonian_gbloch!, z₀, zfun, tspan, param)\nz_gBloch_Gaussian = solve(prob)\n\np = plot(xlabel=\"t [ms]\", ylabel=\"zˢ(t)\")\nplot!(p, 1e3t, zero(similar(t)) .+ z_steady_state_Gaussian, label=\"Henkelman's steady-state\")\nplot!(p, 1e3t, z_Graham_Gaussian, label=\"Graham' model\")\nplot!(p, 1e3t, (hcat(z_Sled_Gaussian(t).u...)'), label=\"Sled's model\")\nplot!(p, 1e3t, (hcat(z_gBloch_Gaussian(t).u...)'), label=\"generalized Bloch model\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/#Super-Lorentzian-Lineshape","page":"Continuous Wave Simulation","title":"Super-Lorentzian Lineshape","text":"","category":"section"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"And we can repeat these simulations (with the exception of the Bloch model) for the super-Lorentzian lineshape, which reveals the most pronounced deviations between the models due to the substantially slower decay of the Green's function:","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"g_superLorentzian(ω₀) = sqrt(2 / π) * T₂ˢ * quadgk(ct -> exp(-2 * (T₂ˢ * ω₀ / abs(3 * ct^2 - 1))^2) / abs(3 * ct^2 - 1), 0.0, sqrt(1 / 3), 1)[1]\nz_steady_state_superLorentzian = R₁ / (R₁ + π * ω₁^2 * g_superLorentzian(ω₀))\n\nRʳᶠ = π * ω₁^2 * g_superLorentzian(ω₀)\nz_Graham_superLorentzian = @. (Rʳᶠ * exp(-t * (R₁ + Rʳᶠ)) + R₁) / (R₁ + Rʳᶠ)\n\nG_superLorentzian = interpolate_greens_function(greens_superlorentzian, 0, Tʳᶠ/T₂ˢ)\n\nparam = (ω₁, 1, ω₀, R₁, T₂ˢ, G_superLorentzian)\nprob = ODEProblem(apply_hamiltonian_sled!, z₀, tspan, param)\nz_Sled_superLorentzian = solve(prob)\n\nprob = DDEProblem(apply_hamiltonian_gbloch!, z₀, zfun, tspan, param)\nz_gBloch_superLorentzian = solve(prob)\n\n\np = plot(xlabel=\"t [ms]\", ylabel=\"zˢ(t)\")\nplot!(p, 1e3t, zero(similar(t)) .+ z_steady_state_superLorentzian, label=\"Henkelman's steady-state\")\nplot!(p, 1e3t, z_Graham_superLorentzian, label=\"Graham's model\")\nplot!(p, 1e3t, (hcat(z_Sled_superLorentzian(t).u...)'), label=\"Sled's model\")\nplot!(p, 1e3t, (hcat(z_gBloch_superLorentzian(t).u...)'), label=\"generalized Bloch model\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"","category":"page"},{"location":"build_literate/Simulation_ContinuousWave/","page":"Continuous Wave Simulation","title":"Continuous Wave Simulation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"EditURL = \"../NLLS.jl\"","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"(Image: )","category":"page"},{"location":"build_literate/NLLS/#Non-Linear-Least-Square-Fitting","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"","category":"section"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"This section gives a brief overview of the interface to fit the generalized Bloch model to hybrid-state free precession data. We use the LsqFit.jl package and supply the algorithm with analytic gradients that are calculated with the calculatesignal_linearapprox function that implements the linear approximation of the generalized Bloch model for a train of rectangular RF pulses.","category":"page"},{"location":"build_literate/NLLS/#Basic-Interface","page":"Non-Linear Least Square Fitting","title":"Basic Interface","text":"","category":"section"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"This tutorial uses the following packages:","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"using MRIgeneralizedBloch\nusing MAT\nusing LinearAlgebra\nusing Plots\nplotlyjs(bg = RGBA(31/255,36/255,36/255,1.0), ticks=:native); #hide\nnothing #hide","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"and we demonstrate the concept at the example of the RF pulse train that we published in the paper Rapid quantitative magnetization transfer imaging: utilizing the hybrid state and the generalized Bloch model:","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"control = matread(normpath(joinpath(pathof(MRIgeneralizedBloch), \"../../docs/control_MT_v3p2_TR3p5ms_discretized.mat\")))\nα   = control[\"alpha\"]\nTRF = control[\"TRF\"]\n\nTR = 3.5e-3\nt = TR .* (1:length(TRF));\nnothing #hide","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"As an example we can assume the following ground truth parameters","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"m0s = 0.15\nR1f = 0.5 # 1/s\nR2f = 17 # 1/s\nRx = 30 # 1/s\nR1s = 3 # 1/s\nT2s = 12e-6 # s\nω0 = 100 # rad/s\nB1 = 0.9; # in units of B1_nominal\nnothing #hide","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"precompute the linear approximation","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"R2slT = precompute_R2sl();\nnothing #hide","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"and simulate the signal:","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"s = calculatesignal_linearapprox(α, TRF, TR, ω0, B1, m0s, R1f, R2f, Rx, R1s, T2s, R2slT)\ns = vec(s)","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"To make this example a bit more realistic, we add complex valued Gaussian noise:","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"s .+= 0.01 * randn(ComplexF64, size(s));\nnothing #hide","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"Now we can fit the model to the noisy data:","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"qM = fit_gBloch(s, α, TRF, TR; R2slT=R2slT)","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"The last keyword argument is optional. It allows to recycle the precomputed R2sl, which improves speed. If not specified, it is re-calculated internally.","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"The results are stored in a struct and we can access the fitted parameters with","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"qM.m0s","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"qM.R1f # 1/s","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"qM.R2f # 1/s","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"qM.Rx # 1/s","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"qM.R1s # 1/s","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"1e6qM.T2s # μs","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"qM.ω0 # rad/s","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"qM.B1 # 1/B1_nominal","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"We can also simulate the signal with the fitted parameters","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"s_fitted = calculatesignal_linearapprox(α, TRF, TR, qM.ω0, qM.B1, qM.m0s, qM.R1f, qM.R2f, qM.Rx, qM.R1s, qM.T2s, R2slT)\ns_fitted = vec(s_fitted);\nnothing #hide","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"and compare it to the noisy data:","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"p = plot(xlabel=\"t (s)\", ylabel=\"signal (normalized)\", legend=:topleft)\nplot!(p, t, real.(s), label=\"Re(s)\")\nplot!(p, t, imag.(s), label=\"Im(s)\")\nplot!(p, t, real.(s_fitted), label=\"Re(s_fitted)\")\nplot!(p, t, imag.(s_fitted), label=\"Im(s_fitted)\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/NLLS/#Bounds-and-Fixed-Parameters","page":"Non-Linear Least Square Fitting","title":"Bounds and Fixed Parameters","text":"","category":"section"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"Above example uses the default bounds","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"reM0 = (-Inf,   1,  Inf)","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"imM0 = (-Inf,   0,  Inf)","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"m0s  = (   0, 0.2,    1)","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"R1f  = (   0, 0.3,  Inf)","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"R2f  = (   0,  15,  Inf)","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"Rx   = (   0,  20,  Inf)","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"R1s  = (   0,   3,  Inf)","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"T2s  = (8e-6,1e-5,12e-6)","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"ω0   = (-Inf,   0,  Inf)","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"B1   = (   0,   1,  1.5)","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"where the three entries refer to (minimum, start_value, maximum) (cf. fit_gBloch).","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"With keyword arguments, one can modify each of these bounds. For example:","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"qM = fit_gBloch(s, α, TRF, TR; R2slT=R2slT, m0s  = (0.1, 0.3, 0.5))","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"starts the fit at m0s = 0.3 and uses a lower bound of 0.1 and an upper bound of 0.5. Alternatively, one also fix parameters to specified values:","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"qM = fit_gBloch(s, α, TRF, TR; R2slT=R2slT, ω0 = 0, B1 = 1)","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"In this case, the derivatives wrt. ω0 and B1 are not calculated and the result is accordingly","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"qM.ω0","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"qM.B1","category":"page"},{"location":"build_literate/NLLS/#Linear-Compression","page":"Non-Linear Least Square Fitting","title":"Linear Compression","text":"","category":"section"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"As originally suggested by McGivney et al. for MR Fingerprinting, the manifold of signal evolution or fingerprints is low rank and it is often beneficial to reconstruct images directly in this domain. We can calculate a low rank basis with","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"sv = Array{ComplexF64}(undef, length(s), 50)\nfor i=1:size(sv,2)\n    sv[:,i] = calculatesignal_linearapprox(α, TRF, TR, 500randn(), 0.8 + 0.4rand(), rand(), rand(), 20rand(), 30rand(), 3rand(), 8e-6+5e-6rand(), R2slT)\nend\nu, _, _ = svd(sv)\nu = u[:,1:9];\nnothing #hide","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"where the rank 9 was chosen heuristically. The noisy signal can be compressed with","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"sc = u' * s","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"and fitted by calling fit_gBloch with the keyword argument u=u:","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"qM = fit_gBloch(sc, α, TRF, TR; R2slT=R2slT, u=u)","category":"page"},{"location":"build_literate/NLLS/#Apparent-R_1","page":"Non-Linear Least Square Fitting","title":"Apparent R_1","text":"","category":"section"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"Above fits tread R1f and R1s of the free and the semi-solid as independent parameters. As we discussed in our paper, many publications in the literature assume an apparent R1a = R1f = R1s. The corresponding model can be fitted by specifying fit_apparentR1=true:","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"R1a = 1 # 1/s\ns = calculatesignal_linearapprox(α, TRF, TR, ω0, B1, m0s, R1a, R2f, Rx, R1a, T2s, R2slT)\nqM = fit_gBloch(vec(s), α, TRF, TR; fit_apparentR1=true, R1a = (0, 0.7, Inf), R2slT=R2slT)","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"Here, we specified the limits of R1a explicitly, which is optional.","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"","category":"page"},{"location":"build_literate/NLLS/","page":"Non-Linear Least Square Fitting","title":"Non-Linear Least Square Fitting","text":"This page was generated using Literate.jl.","category":"page"},{"location":"api/","page":"API","title":"API","text":"Author = \"Jakob Assländer\"\nCurrentModule = MRIgeneralizedBloch","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"In the following, you find the documentation of all exported functions of the MRIgeneralizedBloch.jl package:","category":"page"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [MRIgeneralizedBloch]","category":"page"},{"location":"api/#MRIgeneralizedBloch.CRB_gradient_OCT-NTuple{14, Any}","page":"API","title":"MRIgeneralizedBloch.CRB_gradient_OCT","text":"CRB, grad_ω1, grad_TRF = CRB_gradient_OCT(ω1, TRF, TR, ω0, B1, m0s, R1f, R2f, Rx, R1s, T2s, R2slT, grad_list, weights; isInversionPulse = [true; falses(length(ω1)-1)])\n\nCalculate the Cramer-Rao bound of a pulse sequence along with the derivatives wrt. ω1 and TRF.\n\nArguments\n\nω1::Vector{Real}: Control vector of length = Npulses\nTRF::Vector{Real}: Control vector of length = Npulses\nTR::Real: Repetition time in seconds\nω0::Real: Off-resonance frequency in rad/s\nB1::Real: Normalized transmit B1 field, i.e. B1 = 1 corresponds to a well-calibrated B1 field\nm0s::Real: Fractional size of the semi-solid pool; should be in range of 0 to 1\nR1f::Real: Longitudinal relaxation rate of the free pool in 1/seconds\nR2f::Real: Transversal relaxation rate of the free pool in 1/seconds\nRx::Real: Exchange rate between the two spin pools in 1/seconds\nR1f::Real: Longitudinal relaxation rate of the semi-solid pool in 1/seconds\nT2s::Real: Transversal relaxation time of the semi-solid pool in seconds\nR2slT::NTuple{3, Function}: Tuple of three functions: R2sl(TRF, ω1, B1, T2s), dR2sldB1(TRF, ω1, B1, T2s), and R2sldT2s(TRF, ω1, B1, T2s). Can be generated with precompute_R2sl\ngrad_list::Vector{<:grad_param}: Vector that specifies the gradients that are calculated; the vector elements can either be any subset/order of grad_list=[grad_m0s(), grad_R1f(), grad_R2f(), grad_Rx(), grad_R1s(), grad_T2s(), grad_ω0(), grad_B1()]; the derivative wrt. to apparent R1a = R1f = R1s can be calculated with grad_R1a()\nweights::transpose(Vector{Real}): Row vector of weights applied to the Cramer-Rao bounds (CRB) of the individual parameters. The first entry always refers to the CRB of M0, followed by the values defined in grad_list in the order defined therein. Hence, the vector weights has to have one more entry than grad_list\n\nOptional Keyword Arguments:\n\nisInversionPulse::Vector{Bool}: Indicates all inversion pulses; must have the same length as α; the default = [true; falses(length(ω1)-1)] indicates that the first pulse is an inversion pulse and all others are not\n\nExamples\n\njulia> CRB, grad_ω1, grad_TRF = MRIgeneralizedBloch.CRB_gradient_OCT(rand(100) .* π, rand(100) .* 400e-6 .+ 100e-6, 3.5e-3, 0, 1, 0.15, 0.5, 15, 30, 2, 10e-6, precompute_R2sl(), [grad_m0s(), grad_R1f()], transpose([0, 1, 1]); isInversionPulse = [true, falses(99)...])\n(2.6266536440386683e20, [0.0, -8.357210433553662e19, 1.8062863407658156e20, -9.181952733568582e19, 2.0889419004304123e20, -1.0127412004909923e20, 1.1472963520187394e20, -6.048455202064828e19, 1.6635577264610125e20, -1.2997982001201938e20  …  -4.0462197701237735e19, 4.4051154836362985e19, -5.703747921741744e19, 1.1580676614266505e20, -1.2930234020298534e20, 1.4073548384507303e20, -9.192708958806614e19, 1.3584033382847213e20, -3.697066939905562e19, 6.313101282386484e19], [0.0, -7.51230331957692e23, 9.811932053428692e23, -1.0734285487552513e24, 6.675582483464475e23, -3.1051435697300785e23, 2.8969707405246626e23, -1.1612336440328984e24, 6.698477560905162e23, -1.8718360662340176e22  …  -2.7429211167215447e23, 2.5368127989367466e23, -6.640000159002342e23, 1.7977260470624765e23, -3.6616011555760077e23, 4.9307219096771845e23, -7.650701790011881e23, 4.5704084508410106e23, -1.0229952455676927e24, 9.526419421729279e23])\n\n\nc.f. Optimal Control\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.RF_power!-NTuple{4, Any}","page":"API","title":"MRIgeneralizedBloch.RF_power!","text":"F = RF_power!(grad_ω1, grad_TRF, ω1, TRF; idx=(ω1 .* TRF) .≉ π, λ=1, Pmax=3e6, TR=3.5e-3)\n\nCalculate RF power penalty and over-write the gradients in place.\n\nArguments\n\ngrad_ω1::Vector{Real}: Gradient of control, which will be over-written in place\ngrad_TRF::Vector{Real}: Gradient of control, which will be over-written in place\nω1::Vector{Real}: Control vector\nTRF::Vector{Real}: Control vector\n\nOptional Keyword Arguments:\n\nidx::Vector{Bool}: index of flip angles that are considered. Set individual individual pulses to false to exclude, e.g., inversion pulses\nλ::Real: regularization parameter\nPmax::Real: Maximum average power deposition in (rad/s)²; everything above this value will be penalized and with an appropriate λ, the resulting power will be equal to or less than this value.\nTR::Real: Repetition time of the pulse sequence\n\nExamples\n\njulia> ω1 = 4000π * rand(100);\n\njulia> TRF = 500e-6 * rand(100);\n\njulia> grad_ω1 = similar(ω1);\n\njulia> grad_TRF = similar(ω1);\n\njulia> F = MRIgeneralizedBloch.RF_power!(grad_ω1, grad_TRF, ω1, TRF; λ=1e3, Pmax=2.85e5)\n1.2099652735600044e16\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.TRF_TV!-Tuple{Any, Any, Any}","page":"API","title":"MRIgeneralizedBloch.TRF_TV!","text":"F = TRF_TV!(grad_TRF, ω1, TRF; idx=(ω1 .* TRF) .≉ π, λ = 1)\n\nCalculate the total variation penalty of TRF and over-write grad_TRF in place.\n\nArguments\n\ngrad_TRF::Vector{Real}: Gradient of control, which will be over-written in place\nω1::Vector{Real}: Control vector\nTRF::Vector{Real}: Control vector\n\nOptional Keyword Arguments:\n\nidx::Vector{Bool}: index of flip angles that are considered. Set individual individual pulses to false to exclude, e.g., inversion pulses\nλ::Real: regularization parameter\n\nExamples\n\njulia> ω1 = 4000π * rand(100);\n\njulia> TRF = 500e-6 * rand(100);\n\njulia> grad_TRF = similar(ω1);\n\njulia> F = MRIgeneralizedBloch.TRF_TV!(grad_TRF, ω1, TRF; λ = 1e-3)\n1.5456176321183175e-5\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.apply_hamiltonian_gbloch!-Tuple{Any, Any, Any, NTuple{11, Any}, Any}","page":"API","title":"MRIgeneralizedBloch.apply_hamiltonian_gbloch!","text":"apply_hamiltonian_gbloch!(∂m∂t, m, mfun, p, t)\n\nApply the generalized Bloch Hamiltonian to m and write the resulting derivative wrt. time into ∂m∂t.\n\nArguments\n\n∂m∂t::Vector{Real}: Vector describing to derivative of m wrt. time; this vector has to be of the same size as m, but can contain any value, which is replaced by H * m\nm::Vector{Real}: Vector the spin ensemble state of the form [xf, yf, zf, zs, 1] if now gradient is calculated or of the form [xf, yf, zf, zs, 1, ∂xf/∂θ1, ∂yf/∂θ1, ∂zf/∂θ1, ∂zs/∂θ1, 0, ..., ∂xf/∂θn, ∂yf/∂θn, ∂zf/∂θn, ∂zs/∂θn, 0] if n derivatives wrt. θn are calculated\nmfun: History function; can be initialized with mfun(p, t; idxs=nothing) = typeof(idxs) <: Real ? 0.0 : zeros(5n + 5) for n gradients, and is then updated by the delay differential equation solvers\np::NTuple{6,Any}: (ω1, B1, ω0, R1s, T2s, g) or\np::NTuple{6,Any}: (ω1, B1,  φ, R1s, T2s, g) or\np::NTuple{10,Any}: (ω1, B1, ω0, m0s, R1f, R2f, Rx, R1s, T2s, g) or\np::NTuple{10,Any}: (ω1, B1,  φ, m0s, R1f, R2f, Rx, R1s, T2s, g) or\np::NTuple{12,Any}: (ω1, B1, ω0, m0s, R1f, R2f, Rx, R1s, T2s, g, dG_o_dT2s_x_T2s, grad_list) or\np::NTuple{12,Any}: (ω1, B1, ω0, m0s, R1f, R2f, Rx, R1s, T2s, g, dG_o_dT2s_x_T2s, grad_list) with the following entries\nω1::Real: Rabi frequency in rad/s (rotation about the y-axis) or\nω1(t)::Function: Rabi frequency in rad/s as a function of time for shaped RF-pulses\nB1::Real: B1 scaling normalized so that B1=1 corresponds to a perfectly calibrated RF field\nω0::Real: Larmor or off-resonance frequency in rad/s or\nφ::Function: RF-phase in rad as a function of time for frequency/phase-sweep pulses (works only in combination with ω1(t)::Function)\nm0s::Real: Fractional semi-solid spin pool size in the range of 0 to 1\nR1f::Real: Longitudinal spin relaxation rate of the free pool in 1/seconds\nR2f::Real: Transversal spin relaxation rate of the free pool in 1/seconds\nRx::Real: Exchange rate between the two pools in 1/seconds\nR1s::Real: Longitudinal spin relaxation rate of the semi-solid pool in 1/seconds\nT2s::Real: Transversal spin relaxation time of the semi-solid pool in seconds\ng::Function: Green's function of the form G(κ) = G((t-τ)/T2s)\ndG_o_dT2s_x_T2s::Function: Derivative of the Green's function wrt. T2s, multiplied by T2s; of the form dG_o_dT2s_x_T2s(κ) = dG_o_dT2s_x_T2s((t-τ)/T2s)\ngrad_list::Vector{grad_param}: List of gradients to be calculated, i.e., any subset of [grad_m0s(), grad_R1f(), grad_R2f(), grad_Rx(), grad_R1s(), grad_T2s(), grad_ω0(), grad_B1()]; length of the vector must be n (cf. arguments m and ∂m∂t); the derivative wrt. to apparent R1a = R1f = R1s can be calculated with grad_R1a()\nt::Real: Time in seconds\n\nOptional:\n\npulsetype=:normal: Use default for a regular RF-pulse; the option pulsetype=:inversion should be handled with care as it is only intended to calculate the saturation of the semi-solid pool and its derivative.\n\nExamples\n\njulia> using DifferentialEquations\n\n\njulia> α = π/2;\n\njulia> TRF = 100e-6;\n\njulia> ω1 = α/TRF;\n\njulia> B1 = 1;\n\njulia> ω0 = 0;\n\njulia> m0s = 0.2;\n\njulia> R1f = 1/3;\n\njulia> R2f = 15;\n\njulia> R1s = 2;\n\njulia> T2s = 10e-6;\n\njulia> Rx = 30;\n\njulia> G = interpolate_greens_function(greens_superlorentzian, 0, TRF / T2s);\n\n\njulia> m0 = [0; 0; 1-m0s; m0s; 1];\n\njulia> mfun(p, t; idxs=nothing) = typeof(idxs) <: Real ? 0.0 : zeros(5);\n\njulia> sol = solve(DDEProblem(apply_hamiltonian_gbloch!, m0, mfun, (0, TRF), (ω1, B1, ω0, m0s, R1f, R2f, Rx, R1s, T2s, G)))\nretcode: Success\nInterpolation: specialized 4th order \"free\" interpolation, specialized 2nd order \"free\" stiffness-aware interpolation\nt: 9-element Vector{Float64}:\n 0.0\n 1.375006182301112e-7\n 1.512506800531223e-6\n 8.042561696923577e-6\n 2.107848894861101e-5\n 3.9114182159866e-5\n 6.26879358261189e-5\n 9.147711414688425e-5\n 0.0001\nu: 9-element Vector{Vector{Float64}}:\n [0.0, 0.0, 0.8, 0.2, 1.0]\n [0.0017278806030763402, 0.0, 0.7999981340131751, 0.19999953350448, 1.0]\n [0.019004717382235078, 0.0, 0.7997742277135814, 0.19994357804868362, 1.0]\n [0.10079111348917136, 0.0, 0.7936248122939504, 0.19842287240368398, 1.0]\n [0.2600257867257624, 0.0, 0.7565529666157949, 0.1898191304278861, 1.0]\n [0.46104237829774064, 0.0, 0.6537239462232086, 0.16937683398576228, 1.0]\n [0.6661740376622253, 0.0, 0.44261209248221817, 0.13589311206074786, 1.0]\n [0.7923117772809817, 0.0, 0.10713073823030607, 0.09390260581965477, 1.0]\n [0.7994211188442756, 0.0, 0.0004403374305009168, 0.08214809659226184, 1.0]\n\njulia> using Plots\n\njulia> plot(sol, labels=[\"xf\" \"yf\" \"zf\" \"zs\" \"1\"], xlabel=\"t (s)\", ylabel=\"m(t)\");\n\n\n\n\njulia> dG_o_dT2s_x_T2s = interpolate_greens_function(dG_o_dT2s_x_T2s_superlorentzian, 0, TRF / T2s);\n\n\njulia> grad_list = [grad_R2f(), grad_m0s()];\n\n\njulia> m0 = [0; 0; 1-m0s; m0s; 1; zeros(5*length(grad_list))];\n\n\njulia> mfun(p, t; idxs=nothing) = typeof(idxs) <: Real ? 0.0 : zeros(5 + 5*length(grad_list));\n\njulia> sol = solve(DDEProblem(apply_hamiltonian_gbloch!, m0, mfun, (0, TRF), (ω1, B1, ω0, m0s, R1f, R2f, Rx, R1s, T2s, G, dG_o_dT2s_x_T2s, grad_list)));\n\n\n\n\njulia> plot(sol);\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.apply_hamiltonian_sled!-Tuple{Any, Any, Tuple{Real, Real, Real, Real, Real, Function}, Any}","page":"API","title":"MRIgeneralizedBloch.apply_hamiltonian_sled!","text":"apply_hamiltonian_sled!(∂m∂t, m, p, t)\n\nApply Sled's Hamiltonian to m and write the resulting derivative wrt. time into ∂m∂t.\n\nArguments\n\n∂m∂t::Vector{<:Real}: Vector of length 1 describing to derivative of m wrt. time; this vector can contain any value, which is replaced by H * m\nm::Vector{<:Real}: Vector of length 1 describing the zs magnetization\np::NTuple{6 or 10, Any}: (ω1, B1, ω0, R1s, T2s, g) for a simulating an isolated semi-solid pool or (ω1, B1, ω0, m0s, R1f, R2f, Rx, R1s, T2s, g) for simulating a coupled spin system; with\nω1::Real: Rabi frequency in rad/s (rotation about the y-axis) or\nω1(t)::Function: Rabi frequency in rad/s as a function of time for shaped RF-pulses\nB1::Real: B1 scaling normalized so that B1=1 corresponds to a perfectly calibrated RF field\nω0::Real: Larmor or off-resonance frequency in rad/s (is only used for the free spin pool)\nR1f::Real: Longitudinal spin relaxation rate of the free pool in 1/seconds\nR2f::Real: Transversal spin relaxation rate of the free pool in 1/seconds\nR1s::Real: Longitudinal spin relaxation rate of the semi-solid in 1/seconds\nRx::Real: Exchange rate between the two pools in 1/seconds\nT2s::Real: Transversal spin relaxation time in seconds\ng::Function: Green's function of the form G(κ) = G((t-τ)/T2s)\nt::Real: Time in seconds\n\nExamples\n\njulia> using DifferentialEquations\n\n\njulia> α = π/2;\n\njulia> TRF = 100e-6;\n\njulia> ω1 = α/TRF;\n\njulia> B1 = 1;\n\njulia> ω0 = 0;\n\njulia> R1s = 2;\n\njulia> T2s = 10e-6;\n\njulia> G = interpolate_greens_function(greens_superlorentzian, 0, TRF / T2s);\n\njulia> m0 = [1];\n\njulia> sol = solve(ODEProblem(apply_hamiltonian_sled!, m0, (0, TRF), (ω1, 1, ω0, R1s, T2s, G)), Tsit5())\nretcode: Success\nInterpolation: specialized 4th order \"free\" interpolation\nt: 3-element Vector{Float64}:\n 0.0\n 7.475414666720001e-5\n 0.0001\nu: 3-element Vector{Vector{Float64}}:\n [1.0]\n [0.6313928231811967]\n [0.4895365449661915]\n\njulia> using Plots\n\njulia> plot(sol, labels=[\"zs\"], xlabel=\"t (s)\", ylabel=\"m(t)\");\n\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.bound_ω1_TRF!-Tuple{Any, Any}","page":"API","title":"MRIgeneralizedBloch.bound_ω1_TRF!","text":"x = bound_ω1_TRF!(ω1, TRF; ω1_min = 0, ω1_max = 2e3π, TRF_min = 100e-6, TRF_max = 500e-6)\n\nBound the controls ω1 and TRF (over-written in place) and return a vector of length 2Npulses with values in the range [-Inf, Inf] that relate to the bounded ω1 and TRF via the tanh function.\n\nArguments\n\nω1::Vector{Real}: Control vector of length Npulses\nTRF::Vector{Real}: Control vector of length Npulses\n\nOptional Keyword Arguments (see above for defaults):\n\nω1_min::Real: lower bound for ω1 in rad/s\nω1_max::Real: upper bound for ω1 in rad/s\nTRF_min::Real: lower bound for TRF in s\nTRF_max::Real: upper bound for TRF in s\n\nExamples\n\njulia> ω1 = 4000π * rand(100);\n\njulia> TRF = 500e-6 * rand(100);\n\njulia> x = MRIgeneralizedBloch.bound_ω1_TRF!(ω1, TRF)\n200-element Vector{Float64}:\n  Inf\n   0.3084393995336273\n  -0.222010414402936\n   0.1981882670715111\n  Inf\n  -0.3590504865635206\n  Inf\n  Inf\n  Inf\n  Inf\n   ⋮\n  -1.3069326972020265\n -Inf\n   4.449542946745821\n   0.06378289522574039\n   0.2699178281115771\n   1.271412541641303\n  -0.46991502137668045\n  -1.4377324062335655\n  -0.9746661706753423\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.calculatesignal_gbloch_ide-NTuple{11, Any}","page":"API","title":"MRIgeneralizedBloch.calculatesignal_gbloch_ide","text":"calculatesignal_gbloch_ide(α, TRF, TR, ω0, B1, m0s, R1f, R2f, Rx, R1s, T2s[; grad_list, Ncyc=2, output=:complexsignal])\n\nCalculate the signal or magnetization evolution with the full generalized Bloch model assuming a super-Lorentzian lineshape (slow).\n\nThe simulation assumes a sequence of rectangular RF-pulses with varying flip angles α and RF-pulse durations TRF, but a fixed repetition time TR. Further, it assumes balanced gradient moments.\n\nArguments\n\nα::Vector{Real}: Array of flip angles in radians\nTRF::Vector{Real}: Array of the RF-pulse durations in seconds\nTR::Real: Repetition time in seconds\nω0::Real: Off-resonance frequency in rad/s\nB1::Real: Normalized transmit B1 field, i.e. B1 = 1 corresponds to a well-calibrated B1 field\nm0s::Real: Fractional size of the semi-solid pool; should be in range of 0 to 1\nR1f::Real: Longitudinal relaxation rate of the free pool in 1/seconds\nR2f::Real: Transversal relaxation rate of the free pool in 1/seconds\nRx::Real: Exchange rate between the two spin pools in 1/seconds\nR1s::Real: Longitudinal relaxation rate of the semi-solid pool in 1/seconds\nT2s::Real: Transversal relaxation time of the semi-solid pool in seconds\n\nOptional:\n\ngrad_list=[]: Vector that specifies the gradients that are calculated; the vector can either be empty [] for no gradient, or contain any subset/order of grad_list=[grad_m0s(), grad_R1s(), grad_R2f(), grad_Rx(), grad_R1s(), grad_T2s(), grad_ω0(), grad_B1()]; the derivative wrt. to apparent R1a = R1f = R1s can be calculated with grad_R1a()\nNcyc=2: The magnetization is initialized with thermal equilibrium and then performed Ncyc times and only the last cycle is stored. The default value is usually a good approximation for antiperiodic boundary conditions. Increase the number for higher precision at the cost of computation time.\noutput=:complexsignal: The default keywords triggers the function to output a complex-valued signal (xf + 1im yf); the keyword output=:realmagnetization triggers an output of the entire (real valued) vector [xf, yf, zf, xs, zs]\ngreens=(greens_superlorentzian, dG_o_dT2s_x_T2s_superlorentzian): Tuple of a Greens function G(κ) = G((t-τ)/T2s) and its partial derivative wrt. T2s, multiplied by T2s ∂G((t-τ)/T2s)/∂T2s * T2s. This package supplies the three Greens functions greens=(greens_superlorentzian, dG_o_dT2s_x_T2s_superlorentzian) (default), greens=(greens_lorentzian, dG_o_dT2s_x_T2s_lorentzian), and greens=(greens_gaussian, dG_o_dT2s_x_T2s_gaussian)\n\nExamples\n\njulia> calculatesignal_gbloch_ide(ones(100)*π/2, ones(100)*5e-4, 4e-3, 0, 1, 0.2, 0.3, 15, 20, 2, 10e-6)\n100×1 Matrix{ComplexF64}:\n  -0.007966316445310092 + 0.0im\n  0.0012590590420428192 - 0.0im\n  -0.006088855588249714 + 0.0im\n   0.002418738940913121 - 0.0im\n  -0.004361339394954344 + 0.0im\n  0.0034891358222515403 - 0.0im\n -0.0027633710605856443 + 0.0im\n   0.004483217942995644 - 0.0im\n -0.0012812573504847747 + 0.0im\n    0.00540885403652597 - 0.0im\n                        ⋮\n   0.017760808273166742 - 0.0im\n    0.01757611897551337 + 0.0im\n    0.01781395094611674 - 0.0im\n    0.01764385633643124 + 0.0im\n   0.017863575856212052 - 0.0im\n   0.017706926034820797 + 0.0im\n   0.017909914934264796 - 0.0im\n    0.01776565037417232 + 0.0im\n   0.017953184893722073 - 0.0im\n\njulia> calculatesignal_gbloch_ide(ones(100)*π/2, ones(100)*5e-4, 4e-3, 0, 1, 0.2, 0.3, 15, 20, 2, 10e-6; grad_list=[grad_R1f(), grad_T2s()], output=:realmagnetization)\n100×15 transpose(::Matrix{Float64}) with eltype Float64:\n -0.00796627   0.0   0.000637773  …   0.0   -10.8757  -335.26   0.0\n  0.00125903  -0.0  -0.00700671      -0.0   125.882   -326.977  0.0\n -0.00608882   0.0   0.00185086       0.0   -30.4187  -317.56   0.0\n  0.00241873  -0.0  -0.00520622      -0.0    96.1776  -309.906  0.0\n -0.00436133   0.0   0.00296471       0.0   -47.5803  -302.948  0.0\n  0.003489    -0.0  -0.00354518   …  -0.0    69.5148  -298.697  0.0\n -0.00276366   0.0   0.00399588       0.0   -62.8453  -294.886  0.0\n  0.00448273  -0.0  -0.00200673      -0.0    45.3179  -292.783  0.0\n -0.00128187   0.0   0.00495478       0.0   -76.6573  -290.321  0.0\n  0.00540814  -0.0  -0.000578836     -0.0    23.1756  -289.245  0.0\n  ⋮                               ⋱\n  0.0177563   -0.0   0.0175372       -0.0  -290.779   -349.855  0.0\n  0.0175716    0.0   0.0177845        0.0  -295.347   -350.002  0.0\n  0.0178094   -0.0   0.0176073       -0.0  -292.44    -350.163  0.0\n  0.0176393    0.0   0.0178359        0.0  -296.668   -350.3    0.0\n  0.017859    -0.0   0.0176727    …  -0.0  -294.001   -350.451  0.0\n  0.0177024    0.0   0.0178838        0.0  -297.914   -350.579  0.0\n  0.0179053   -0.0   0.0177335       -0.0  -295.467   -350.72   0.0\n  0.0177611    0.0   0.0179286        0.0  -299.09    -350.84   0.0\n  0.0179486   -0.0   0.0177902       -0.0  -296.845   -350.972  0.0\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.calculatesignal_graham_ode-NTuple{11, Any}","page":"API","title":"MRIgeneralizedBloch.calculatesignal_graham_ode","text":"calculatesignal_graham_ode(α, TRF, TR, ω0, B1, m0s, R1f, R2f, Rx, R1s, T2s[; grad_list, Ncyc=2, output=:complexsignal])\n\nCalculate the signal or magnetization evolution with Graham's spectral model assuming a super-Lorentzian lineshape.\n\nThe simulation assumes a sequence of rectangular RF-pulses with varying flip angles α and RF-pulse durations TRF, but a fixed repetition time TR. Further, it assumes balanced gradient moments.\n\nArguments\n\nα::Vector{Real}: Array of flip angles in radians\nTRF::Vector{Real}: Array of the RF-pulse durations in seconds\nTR::Real: Repetition time in seconds\nω0::Real: Off-resonance frequency in rad/s\nB1::Real: Normalized transmit B1 field, i.e. B1 = 1 corresponds to a well-calibrated B1 field\nm0s::Real: Fractional size of the semi-solid pool; should be in range of 0 to 1\nR1f::Real: Longitudinal relaxation rate of the free pool in 1/seconds\nR2f::Real: Transversal relaxation rate of the free pool in 1/seconds\nRx::Real: Exchange rate between the two spin pools in 1/seconds\nR1s::Real: Longitudinal relaxation rate of the semi-solid pool in 1/seconds\nT2s::Real: Transversal relaxation time of the semi-solid pool in seconds\n\nOptional:\n\ngrad_list=[]: Vector that specifies the gradients that are calculated; the vector can either be empty [] for no gradient, or contain any subset/order of grad_list=[grad_m0s(), grad_R1f(), grad_R2f(), grad_Rx(), grad_R1s(), grad_T2s(), grad_ω0(), grad_B1(), grad_R1a()]\nNcyc=2: The magnetization is initialized with thermal equilibrium and then performed Ncyc times and only the last cycle is stored. The default value is usually a good approximation for antiperiodic boundary conditions. Increase the number for higher precision at the cost of computation time.\noutput=:complexsignal: The default keywords triggers the function to output a complex-valued signal (xf + 1im yf); the keyword output=:realmagnetization triggers an output of the entire (real valued) vector [xf, yf, zf, xs, zs]\n\nExamples\n\njulia> calculatesignal_graham_ode(ones(100)*π/2, ones(100)*5e-4, 4e-3, 0, 1, 0.2, 0.3, 15, 20, 2, 10e-6)\n100×1 Matrix{ComplexF64}:\n   -0.00807345119181352 + 0.0im\n   0.001268643290482942 - 0.0im\n -0.0061786944372399285 + 0.0im\n  0.0024358658178670984 - 0.0im\n  -0.004437476277201395 + 0.0im\n   0.003516464649840319 - 0.0im\n -0.0028315542520438736 + 0.0im\n   0.004523902250379144 - 0.0im\n -0.0013422299483389865 + 0.0im\n   0.005454562034842185 - 0.0im\n                        ⋮\n   0.018148222040953822 - 0.0im\n    0.01795769661414946 + 0.0im\n   0.018204860876661903 - 0.0im\n    0.01802936310261858 + 0.0im\n    0.01825782014256292 - 0.0im\n   0.018096168912467753 + 0.0im\n   0.018307337729977783 - 0.0im\n    0.01815844450117701 + 0.0im\n   0.018353636229654767 - 0.0im\n\njulia> calculatesignal_graham_ode(ones(100)*π/2, ones(100)*5e-4, 4e-3, 0, 1, 0.2, 0.3, 15, 20, 2, 10e-6; grad_list=[grad_R1f(), grad_T2s()], output=:realmagnetization)\n100×15 transpose(::Matrix{Float64}) with eltype Float64:\n -0.0080756    0.0   0.000643162  …   0.0   -10.4986  -323.634  0.0\n  0.00126867  -0.0  -0.00710692      -0.0   123.078   -316.358  0.0\n -0.00618067   0.0   0.00186482       0.0   -29.4458  -307.862  0.0\n  0.00243634  -0.0  -0.0052899       -0.0    94.1692  -300.821  0.0\n -0.00443746   0.0   0.00298646       0.0   -46.1422  -294.116  0.0\n  0.00351386  -0.0  -0.00361718   …  -0.0    68.262   -289.421  0.0\n -0.00282882   0.0   0.00402793       0.0   -61.0236  -285.242  0.0\n  0.00451808  -0.0  -0.00206741      -0.0    44.7888  -282.867  0.0\n -0.00133608   0.0   0.00499316       0.0   -74.4075  -280.79   0.0\n  0.00544896  -0.0  -0.00062663      -0.0    23.2536  -280.148  0.0\n  ⋮                               ⋱\n  0.0181755   -0.0   0.0179431       -0.0  -285.071   -337.48   0.0\n  0.0179911    0.0   0.0181963        0.0  -289.591   -337.634  0.0\n  0.0182343   -0.0   0.018019        -0.0  -286.777   -337.804  0.0\n  0.0180645    0.0   0.0182531        0.0  -290.964   -337.948  0.0\n  0.0182893   -0.0   0.0180898    …  -0.0  -288.383   -338.106  0.0\n  0.0181329    0.0   0.0183062        0.0  -292.261   -338.241  0.0\n  0.0183407   -0.0   0.0181559       -0.0  -289.895   -338.39   0.0\n  0.0181968    0.0   0.0183559        0.0  -293.488   -338.516  0.0\n  0.0183888   -0.0   0.0182175       -0.0  -291.318   -338.656  0.0\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.calculatesignal_linearapprox-NTuple{12, Any}","page":"API","title":"MRIgeneralizedBloch.calculatesignal_linearapprox","text":"calculatesignal_linearapprox(α, TRF, TR, ω0, B1, m0s, R1f, R2f, Rx, R1s, T2s, R2slT[; grad_list=[undef], rfphase_increment=[π], m0=:periodic, output=:complexsignal, isInversionPulse = [true; falses(length(α)-1)]])\n\nCalculate the signal or magnetization evolution with the linear approximation of the generalized Bloch model assuming a super-Lorentzian lineshape.\n\nThe simulation assumes a sequence of rectangular RF-pulses with varying flip angles α and RF-pulse durations TRF, but a fixed repetition time TR. Further, it assumes balanced gradient moments.\n\nArguments\n\nα::Vector{Real}: Array of flip angles in radians\nTRF::Vector{Real}: Array of the RF-pulse durations in seconds\nTR::Real: Repetition time in seconds\nω0::Real: Off-resonance frequency in rad/s\nB1::Real: Normalized transmit B1 field, i.e. B1 = 1 corresponds to a well-calibrated B1 field\nm0s::Real: Fractional size of the semi-solid pool; should be in range of 0 to 1\nR1f::Real: Longitudinal relaxation rate of the free pool in 1/seconds\nR2f::Real: Transversal relaxation rate of the free pool in 1/seconds\nRx::Real: Exchange rate between the two spin pools in 1/seconds\nR1f::Real: Longitudinal relaxation rate of the semi-solid pool in 1/seconds\nT2s::Real: Transversal relaxation time of the semi-solid pool in seconds\nR2slT::NTuple{3, Function}: Tuple of three functions: R2sl(TRF, ω1, B1, T2s), dR2sldB1(TRF, ω1, B1, T2s), and R2sldT2s(TRF, ω1, B1, T2s). Can be generated with precompute_R2sl\n\nOptional:\n\ngrad_list=[undef]: Vector that specifies the gradients that are calculated; the vector elements can either be undef for no gradient, or any subset/order of grad_list=[grad_m0s(), grad_R1f(), grad_R2f(), grad_Rx(), grad_R1s(), grad_T2s(), grad_ω0(), grad_B1()]; the derivative wrt. to apparent R1a = R1f = R1s can be calculated with grad_R1a()\nrfphase_increment=[π]::Vector{Real}: Increment of the RF phase between consecutive pulses. The default value π, together with ω0=0 corresponds to the on-resonance condition. When more than one value is supplied, their resulting signal is stored along the second dimension of the output array.\nm0=:periodic: With the default keyword :periodic, the signal and their derivatives are calculated assuming m(0) = -m(T), where T is the duration of the RF-train. With the keyword :thermal, the magnetization m(0) is initialized with thermal equilibrium [xf, yf, zf, xs, zs] = [0, 0, 1-m0s, 0, m0s], followed by a α[1]/2 - TR/2 prep pulse; and with the keyword :IR, this initialization is followed an inversion pulse of duration TRF[1], (set α[1]=π) and a α[2]/2 - TR/2 prep pulse.\npreppulse=false: if true, a α/2 - TR/2 preparation is applied. In the case of m0=:IR, it is applied after the inversion pulse based on α[2], otherwise it is based on α[1]\noutput=:complexsignal: The default keywords triggers the function to output a complex-valued signal (xf + 1im yf); the keyword output=:realmagnetization triggers an output of the entire (real valued) vector [xf, yf, zf, xs, zs, 1]\nisInversionPulse::Vector{Bool}: Indicates all inversion pulses; must have the same length as α; the default = [true; falses(length(α)-1)] indicates that the first pulse is an inversion pulse and all others are not\n\nExamples\n\njulia> R2slT = precompute_R2sl();\n\n\njulia> calculatesignal_linearapprox(ones(100)*π/2, ones(100)*5e-4, 4e-3, 0, 1, 0.1, 1, 15, 30, 6.5, 10e-6, R2slT)\n100×1×1 Array{ComplexF64, 3}:\n[:, :, 1] =\n  -0.029305987774458163 - 0.0im\n   0.004329424678273618 + 0.0im\n  -0.022761409373843695 + 0.0im\n   0.008280330224850314 + 0.0im\n  -0.016751305727868086 + 0.0im\n   0.011921649143708494 + 0.0im\n   -0.01119057989041819 + 0.0im\n   0.015305608440952356 + 0.0im\n -0.0060267918180664974 + 0.0im\n   0.018463027499697613 + 0.0im\n                        ⋮\n   0.061531473509660414 + 0.0im\n    0.06081400768357244 + 0.0im\n     0.0617257515931871 + 0.0im\n   0.061064216222629225 + 0.0im\n     0.0619074570531536 + 0.0im\n    0.06129750535994419 + 0.0im\n   0.062077399758002534 + 0.0im\n   0.061515021919442275 + 0.0im\n    0.06223633770306246 + 0.0im\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.dG_o_dT2s_x_T2s_gaussian-Tuple{Any}","page":"API","title":"MRIgeneralizedBloch.dG_o_dT2s_x_T2s_gaussian","text":"dG_o_dT2s_x_T2s_gaussian(κ)\n\nEvaluate the derivative of Green's function, corresponding to a Gaussian lineshape, wrt. T2s at κ = (t-τ)/T2s and multiply it by T2s.\n\nThe multiplication is added so that the function merely depends on κ = (t-τ)/T2s. The actual derivative is given by dG_o_dT2s_x_T2s_gaussian((t-τ)/T2s)/T2s.\n\nExamples\n\njulia> t = 100e-6;\n\njulia> τ = 0;\n\njulia> T2s = 10e-6;\n\njulia> dGdT2s = dG_o_dT2s_x_T2s_gaussian((t-τ)/T2s)/T2s\n1.9287498479639177e-15\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.dG_o_dT2s_x_T2s_lorentzian-Tuple{Any}","page":"API","title":"MRIgeneralizedBloch.dG_o_dT2s_x_T2s_lorentzian","text":"dG_o_dT2s_x_T2s_lorentzian(κ)\n\nEvaluate the derivative of Green's function, corresponding to a Lorentzian lineshape, wrt. T2s at κ = (t-τ)/T2s and multiply it by T2s.\n\nThe multiplication is added so that the function merely depends on κ = (t-τ)/T2s. The actual derivative is given by dG_o_dT2s_x_T2s_lorentzian((t-τ)/T2s)/T2s.\n\nExamples\n\njulia> t = 100e-6;\n\njulia> τ = 0;\n\njulia> T2s = 10e-6;\n\njulia> dGdT2s = dG_o_dT2s_x_T2s_lorentzian((t-τ)/T2s)/T2s\n45.39992976248485\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.dG_o_dT2s_x_T2s_superlorentzian-Tuple{Any}","page":"API","title":"MRIgeneralizedBloch.dG_o_dT2s_x_T2s_superlorentzian","text":"dG_o_dT2s_x_T2s_superlorentzian(κ)\n\nEvaluate the derivative of Green's function, corresponding to a super-Lorentzian lineshape, wrt. T2s at κ = (t-τ)/T2s and multiply it by T2s.\n\nThe multiplication is added so that the function merely depends on κ = (t-τ)/T2s. The actual derivative is given by dG_o_dT2s_x_T2s_superlorentzian((t-τ)/T2s)/T2s.\n\nExamples\n\njulia> t = 100e-6;\n\njulia> τ = 0;\n\njulia> T2s = 10e-6;\n\njulia> dGdT2s = dG_o_dT2s_x_T2s_superlorentzian((t-τ)/T2s)/T2s\n15253.095033670965\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.fit_gBloch-Union{Tuple{T}, Tuple{Any, Vector{T}, Vector{T}, Any}} where T<:Real","page":"API","title":"MRIgeneralizedBloch.fit_gBloch","text":"qM = fit_gBloch(data, α, TRF, TR;\n    reM0 = (-Inf,   1,  Inf),\n    imM0 = (-Inf,   0,  Inf),\n    m0s  = (   0, 0.2,    1),\n    R1f  = (   0, 0.3,  Inf),\n    R2f  = (   0,  15,  Inf),\n    Rx   = (   0,  20,  Inf),\n    R1s  = (   0,   3,  Inf),\n    T2s  = (8e-6,1e-5,12e-6),\n    ω0   = (-Inf,   0,  Inf),\n    B1   = (   0,   1,  1.5),\n    R1a  = (   0, 0.7,  Inf),\n    u=1,\n    fit_apparentR1=false,\n    show_trace=false,\n    maxIter=100,\n    R2slT = precompute_R2sl(TRF_min=minimum(TRF), TRF_max=maximum(TRF), T2s_min=minimum(T2s), T2s_max=maximum(T2s), ω1_max=maximum(α ./ TRF), B1_max=maximum(B1)),\n    )\n\nFit the generalized Bloch model for a train of RF pulses and balanced gradient moments to data.\n\nArguments\n\ndata::Vector{Number}: Array of measured data points, either in the time or a compressed domain (cf. u)\nα::Vector{Real}: Array of flip angles in radians; can also be a Vector{Vector{Real}} which simulates each RF pattern and concatenates the signals of each simulation\nTRF::Vector{Real}: Array of the RF-pulse durations in seconds (or Vector{Vector{Real}} if α::Vector{Vector{Real}}`)\nTR::Real: Repetition time in seconds\nω0::Real: Off-resonance frequency in rad/s\n\nOptional Keyword Arguments:\n\nreM0::Union{Real, Tuple{Real, Real, Real}}: Real part of M0; either fixed value as a Real or fit limits thereof as a Tuple with the elements (min, start, max)\nimM0::Union{Real, Tuple{Real, Real, Real}}: Imaginary part of M0; either fixed value as a Real or fit limits thereof as a Tuple with the elements (min, start, max)\nm0s::Union{Real, Tuple{Real, Real, Real}}: Fractional size of the semi-solid pool (should be in range of 0 to 1); either fixed value as a Real or fit limits thereof as a Tuple with the elements (min, start, max)\nR1f::Union{Real, Tuple{Real, Real, Real}}: Longitudinal relaxation rate of the free pool in 1/s; only used in combination with fit_apparentR1=false; either fixed value as a Real or fit limits thereof as a Tuple with the elements (min, start, max)\nR2f::Union{Real, Tuple{Real, Real, Real}}: Transversal relaxation rate of the free pool in 1/s; either fixed value as a Real or fit limits thereof as a Tuple with the elements (min, start, max)\nRx::Union{Real, Tuple{Real, Real, Real}}: Exchange rate between the two spin pools in 1/s; either fixed value as a Real or fit limits thereof as a Tuple with the elements (min, start, max)\nR1s::Union{Real, Tuple{Real, Real, Real}}: Longitudinal relaxation rate of the semi-solid pool in 1/s; only used in combination with fit_apparentR1=false; either fixed value as a Real or fit limits thereof as a Tuple with the elements (min, start, max)\nT2s::Union{Real, Tuple{Real, Real, Real}}: Transversal relaxation time of the semi-solid pool in s; either fixed value as a Real or fit limits thereof as a Tuple with the elements (min, start, max)\nω0::Union{Real, Tuple{Real, Real, Real}}: Off-resonance frequency in rad/s; either fixed value as a Real or fit limits thereof as a Tuple with the elements (min, start, max)\nB1::Union{Real, Tuple{Real, Real, Real}}: Normalized transmit B1 field, i.e. B1 = 1 corresponds to a well-calibrated B1 field; either fixed value as a Real or fit limits thereof as a Tuple with the elements (min, start, max)\nR1a::Union{Real, Tuple{Real, Real, Real}}: Apparent longitudinal relaxation rate in 1/s; only used in combination with fit_apparentR1=true; either fixed value as a Real or fit limits thereof as a Tuple with the elements (min, start, max)\nu::Union{Number, Matrix}: Compression matrix that transform the simulated time series to a series of coefficients. Set to 1 by default to enable the fitting in the time domain\nfit_apparentR1::Bool: Switch between fitting R1f and R1s separately (false; default) and an apparent R1a = R1f = R1s (true)\nshow_trace::Bool: print output during the optimization; default=false\nmaxIter::Int: Maximum number of iteration; default=100\nR2slT::NTuple{3, Function}: Tuple of three functions: R2sl(TRF, ω1, B1, T2s), dR2sldB1(TRF, ω1, B1, T2s), and R2sldT2s(TRF, ω1, B1, T2s). By default generated with precompute_R2sl\n\nExamples\n\nc.f. Non-Linear Least Square Fitting\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.get_bounded_ω1_TRF-Tuple{Any}","page":"API","title":"MRIgeneralizedBloch.get_bounded_ω1_TRF","text":"ω1, TRF = get_bounded_ω1_TRF(x; ω1_min = 0, ω1_max = 2e3π, TRF_min = 100e-6, TRF_max = 500e-6)\n\nTransform a vector of length 2Npulses with values in the range [-Inf, Inf] into two vectors of length Npulses, which describe the bounded controls ω1 and TRF.\n\nArguments\n\nx::Vector{Real}: Control vector of length = 2Npulses with values in the range [-Inf, Inf]\n\nOptional Keyword Arguments:\n\nω1_min::Real: lower bound for ω1 in rad/s\nω1_max::Real: upper bound for ω1 in rad/s\nTRF_min::Real: lower bound for TRF in s\nTRF_max::Real: upper bound for TRF in s\n\nExamples\n\njulia> x = 1000 * randn(2 * 100);\n\njulia> ω1, TRF = MRIgeneralizedBloch.get_bounded_ω1_TRF(x)\n([0.0, 6283.185307179586, 0.0, 0.0, 6283.185307179586, 6283.185307179586, 6283.185307179586, 6283.185307179586, 0.0, 0.0  …  0.0, 0.0, 6283.185307179586, 6283.185307179586, 6283.185307179586, 6283.185307179586, 0.0, 0.0, 1.4115403811440933e-9, 0.0], [0.0005, 0.0001, 0.0001, 0.0005, 0.0005, 0.0005, 0.0005, 0.0005, 0.0001, 0.0005  …  0.0005, 0.0005, 0.0001, 0.0001, 0.0001, 0.0004999999277453363, 0.0005, 0.0001, 0.0001, 0.0001])\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.graham_saturation_rate_single_frequency-Tuple{Function, Function, Real, Real}","page":"API","title":"MRIgeneralizedBloch.graham_saturation_rate_single_frequency","text":"graham_saturation_rate_single_frequency(lineshape, ω1, TRF, Δω)\n\nCalculate saturation rate (in units of 1/s) according to Graham's single frequency approximation.\n\nArguments\n\nlineshape::Function: as a function of ω₀ (in rad/s). Supply, e.g., the anonymous function ω₀ -> lineshape_superlorentzian(ω₀, T2s). Note that the integral over the lineshape has to be 1.\nω1::Function: ω1 in rad/s as a function of time (in units of s) where the puls shape is defined for t ∈ [0,TRF]\nTRF::Real: duration of the RF pulse in s\nΔω::Real: offset frequency in rad/s\n\nExamples\n\njulia> using SpecialFunctions\n\njulia> T2s = 10e-6;\n\njulia> α = π;\n\njulia> TRF = 100e-6;\n\njulia> NSideLobes = 1;\n\njulia> ω1(t) = sinc(2(NSideLobes+1) * t/TRF - (NSideLobes+1)) * α / (sinint((NSideLobes+1)π) * TRF/π / (NSideLobes+1));\n\njulia> Δω = 200;\n\njulia> graham_saturation_rate_single_frequency(ω₀ -> lineshape_superlorentzian(ω₀, T2s), ω1, TRF, Δω)\n419969.3376658947\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.graham_saturation_rate_spectral-Tuple{Function, Function, Real, Real}","page":"API","title":"MRIgeneralizedBloch.graham_saturation_rate_spectral","text":"graham_saturation_rate_spectral(lineshape, ω1, TRF, Δω)\n\nCalculate saturation rate (in units of 1/s) according to Graham's spectral model.\n\nArguments\n\nlineshape::Function: as a function of ω₀ (in rad/s). Supply, e.g., the anonymous function ω₀ -> lineshape_superlorentzian(ω₀, T2s). Note that the integral over the lineshape has to be 1.\nω1::Function: ω1 in rad/s as a function of time (in units of s) where the puls shape is defined for t ∈ [0,TRF]\nTRF::Real: duration of the RF pulse in s\nΔω::Real: offset frequency in rad/s\n\nExamples\n\njulia> using SpecialFunctions\n\njulia> T2s = 10e-6;\n\njulia> α = π;\n\njulia> TRF = 100e-6;\n\njulia> NSideLobes = 1;\n\njulia> ω1(t) = sinc(2(NSideLobes+1) * t/TRF - (NSideLobes+1)) * α / (sinint((NSideLobes+1)π) * TRF/π / (NSideLobes+1));\n\njulia> Δω = 200;\n\njulia> graham_saturation_rate_spectral(ω₀ -> lineshape_superlorentzian(ω₀, T2s), ω1, TRF, Δω)\n56135.388046022905\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.greens_gaussian-Tuple{Any}","page":"API","title":"MRIgeneralizedBloch.greens_gaussian","text":"greens_gaussian(κ)\n\nEvaluate the Green's function corresponding to a Gaussian lineshape at κ = (t-τ)/T2s.\n\nExamples\n\njulia> t = 100e-6;\n\njulia> τ = 0;\n\njulia> T2s = 10e-6;\n\njulia> greens_gaussian((t-τ)/T2s)\n1.9287498479639178e-22\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.greens_lorentzian-Tuple{Any}","page":"API","title":"MRIgeneralizedBloch.greens_lorentzian","text":"greens_lorentzian(κ)\n\nEvaluate the Green's function corresponding to a Lorentzian lineshape at κ = (t-τ)/T2s.\n\nExamples\n\njulia> t = 100e-6;\n\njulia> τ = 0;\n\njulia> T2s = 10e-6;\n\njulia> greens_lorentzian((t-τ)/T2s)\n4.5399929762484854e-5\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.greens_superlorentzian-Tuple{Any}","page":"API","title":"MRIgeneralizedBloch.greens_superlorentzian","text":"greens_superlorentzian(κ)\n\nEvaluate the Green's function corresponding to a super-Lorentzian lineshape at κ = (t-τ)/T2s.\n\nExamples\n\njulia> t = 100e-6;\n\njulia> τ = 0;\n\njulia> T2s = 10e-6;\n\njulia> greens_superlorentzian((t-τ)/T2s)\n0.1471246868094442\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.hamiltonian_linear-NTuple{10, Any}","page":"API","title":"MRIgeneralizedBloch.hamiltonian_linear","text":"hamiltonian_linear(ω1, B1, ω0, T, m0s, R1f, R2f, Rx, R1s, R2s[, dR2sdT2s, dR2sdB1, grad_type])\n\nCalculate the hamiltonian of the linear approximation of the generalized Bloch model.\n\nIf no gradient is supplied, it returns a 6x6 (static) matrix with the dimensions (in this order) [xf, yf, zf, xs, zs, 1]; the attached 1 is a mathematical trick to allow for T_1 relaxation to a non-zero thermal equilibrium. If a gradient is supplied, it returns a 11x11 (static) matrix with the dimensions (in this order) [xf, yf, zf, xs, zs, dxf/dθ, dyf/dθ, dzf/dθ, dxs/dθ, dzs/dθ,  1], where θ is the parameter specified by grad_type\n\nArguments\n\nω1::Real: Rabi frequency in rad/s (rotation about the y-axis)\nB1::Real: Normalized transmit B1 field, i.e. B1 = 1 corresponds to a well-calibrated B1 field\nω0::Real: Larmor (or off-resonance) frequency in rad/s (rotation about the z-axis)\nT::Real: Time in seconds; this can, e.g., be the RF-pulse duration, or the time of free precession with ω1=0\nm0s::Real: Fractional size of the semi-solid pool; should be in range of 0 to 1\nR1f::Real: Longitudinal relaxation rate of the free pool in 1/seconds\nR2f::Real: Transversal relaxation rate of the free pool in 1/seconds\nRx::Real: Exchange rate between the two spin pools in 1/seconds\nR1s::Real: Longitudinal relaxation rate of the semi-solid pool in 1/seconds\nR2s::Real: Transversal relaxation rate of the semi-solid pool in 1/seconds; this number can be calculated with the first function returned by precompute_R2sl to implement the linear approximation described in the generalized Bloch paper\n\nOptional:\n\ndR2sdT2s::Real: Derivative of linearized R2sl wrt. the actual T2s; only required if grad_type = grad_T2s(); this number can be calculated with the second function returned by precompute_R2sl\ndR2sdB1::Real: Derivative of linearized R2sl wrt. B1; only required if grad_type = grad_B1(); this number can be calculated with the third function returned by precompute_R2sl\ngrad_type::grad_param: grad_m0s(), grad_R1f(), grad_R1s(), grad_R2f(), grad_Rx(), grad_T2s(), grad_ω0(), or grad_B1(); create one hamiltonian for each desired gradient\n\nExamples\n\njulia> α = π;\n\njulia> T = 500e-6;\n\njulia> ω1 = α/T;\n\njulia> B1 = 1;\n\njulia> ω0 = 0;\n\njulia> m0s = 0.1;\n\njulia> R1f = 1;\n\njulia> R2f = 15;\n\njulia> Rx = 30;\n\njulia> R1s = 6.5;\n\njulia> R2s = 1e5;\n\njulia> m0 = [0, 0, 1-m0s, 0, m0s, 1];\n\njulia> (xf, yf, zf, xs, zs, _) = exp(hamiltonian_linear(ω1, B1, ω0, T, m0s, R1f, R2f, Rx, R1s, R2s)) * m0\n6-element StaticArraysCore.SVector{6, Float64} with indices SOneTo(6):\n  0.0010647535813058293\n  0.0\n -0.8957848274535014\n  0.005126529591877105\n  0.08122007142111888\n  1.0\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.interpolate_greens_function-Tuple{Any, Any, Any}","page":"API","title":"MRIgeneralizedBloch.interpolate_greens_function","text":"interpolate_greens_function(f, κmin, κmax)\n\nInterpolate the Green's function f in the range between κmin and κmax.\n\nThe interpolation uses the ApproxFun.jl package that incorporates Chebyshev polynomials and ensures an approximation to machine precision.\n\nExamples\n\njulia> t = 100e-6;\n\njulia> τ = 0;\n\njulia> T2s = 10e-6;\n\njulia> greens_superlorentzian((t-τ)/T2s)\n0.1471246868094442\n\njulia> Gint = interpolate_greens_function(greens_superlorentzian, 0, 20);\n\n\njulia> Gint((t-τ)/T2s)\n0.14712468680944407\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.precompute_R2sl-Tuple{}","page":"API","title":"MRIgeneralizedBloch.precompute_R2sl","text":"precompute_R2sl([;TRF_min=100e-6, TRF_max=500e-6, T2s_min=5e-6, T2s_max=21e-6, ω1_max=π/TRF_max, B1_max=1.5, greens=greens_superlorentzian])\n\nPre-compute and interpolate the linearized R2sl(TRF, α, B1, T2s) and its derivatives dR2sldB1(TRF, α, B1, T2s), R2sldT2s(TRF, α, B1, T2s) etc. in the range specified by the arguments.\n\nThe function solves the generalized Bloch equations of an isolated semi-solid pool for values in the specified range, calculates the linearized R2sl that minimizes the error of zs at the end of the RF-pulse, and interpolates between the different samples.\n\nOptional Arguments:\n\nTRF_min::Real: lower bound of the RF-pulse duration range in seconds\nTRF_max::Real: upper bound of the RF-pulse duration range in seconds\nT2s_min::Real: lower bound of the T2s range in seconds\nT2s_max::Real: upper bound of the T2s range in seconds\nω1_max::Real: upper bound of the Rabi frequency ω1, the default is the frequency of a 500μs long π-pulse\nB1_max::Real: upper bound of the B1 range, normalized so that B1 = 1 corresponds to a perfectly calibrated RF field\ngreens=greens_superlorentzian: Greens function in the form G(κ) = G((t-τ)/T2s). This package supplies the three Greens functions greens=greens_superlorentzian (default), greens=greens_lorentzian, and greens=greens_gaussian\n\nExamples\n\njulia> R2slT = precompute_R2sl();\n\n\njulia> R2sl, dR2sldB1, R2sldT2s, _ = precompute_R2sl(TRF_min=100e-6, TRF_max=500e-6, T2s_min=5e-6, T2s_max=15e-6, ω1_max=π/500e-6, B1_max=1.3, greens=greens_gaussian);\n\n\n\n\n\n\n","category":"method"},{"location":"api/#MRIgeneralizedBloch.second_order_α!-NTuple{4, Any}","page":"API","title":"MRIgeneralizedBloch.second_order_α!","text":"F = second_order_α!(grad_ω1, grad_TRF, ω1, TRF; idx=(ω1 .* TRF) .≉ π, λ = 1)\n\nCalculate second order penalty of variations of the flip angle α and over-write the gradients in place.\n\nArguments\n\ngrad_ω1::Vector{Real}: Gradient of control, which will be over-written in place\ngrad_TRF::Vector{Real}: Gradient of control, which will be over-written in place\nω1::Vector{Real}: Control vector\nTRF::Vector{Real}: Control vector\n\nOptional Keyword Arguments:\n\nidx::Vector{Bool}: index of flip angles that are considered. Set individual individual pulses to false to exclude, e.g., inversion pulses\nλ::Real: regularization parameter\n\nExamples\n\njulia> ω1 = 4000π * rand(100);\n\njulia> TRF = 500e-6 * rand(100);\n\njulia> grad_ω1 = similar(ω1);\n\njulia> grad_TRF = similar(ω1);\n\njulia> F = MRIgeneralizedBloch.second_order_α!(grad_ω1, grad_TRF, ω1, TRF; λ = 1e-3)\n0.3272308747790844\n\n\n\n\n\n","category":"method"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"EditURL = \"../OCT.jl\"","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"(Image: )","category":"page"},{"location":"build_literate/OCT/#Optimal-Control","page":"Optimal Control","title":"Optimal Control","text":"","category":"section"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"This section provides a brief introduction to the package's interface for sequence optimization. We use the Cramer-Rao bound (CRB) to assess a sequence's performance and optimize the amplitudes (ω_1) and durations (T_textRF) of RF-pulses to reduce the CRB, assuming a Balanced Hybrid-State Free Precession Pulse Sequence. For computational efficiency, the derivatives of the CRB wrt. ω_1 and T_textRF are calculated with the adjoint state method common in the optimal control literature.","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"For this tutorial, we use the following packages:","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"using MRIgeneralizedBloch\nusing LinearAlgebra\nBLAS.set_num_threads(1) # single threaded is faster in this case\nusing Optim             # provides the optimization algorithm\nusing Plots\nplotlyjs(bg = RGBA(31/255,36/255,36/255,1.0), ticks=:native); #hide\nnothing #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"Here, we optimize the pulse sequence for a predefined set of parameters:","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"m0s = 0.15\nR1f = 0.5   # 1/s\nR2f = 15    # 1/s\nRx = 30     # 1/s\nR1s = 3     # 1/s\nT2s = 10e-6 # s\nω0 = 0      # rad/s\nB1 = 1;     # in units of B1_nominal\nnothing #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"and we optimize","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"Npulses = 200;\nnothing #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"pulses, spaced","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"TR = 3.5e-3; # s\nnothing #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"apart. The cyle duration of","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"Npulses * TR","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"seconds is shorter than the optimal duration, which is in the range of 4-10s. We here use a small Npulses to speed up the computations. The Linear Approximation of the generalized Bloch model is precomputed with","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"R2slT = precompute_R2sl();\nnothing #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"In the calculation of the CRB, we account for following gradients:","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"grad_list = [grad_m0s(), grad_R1f(), grad_R2f(), grad_Rx(), grad_R1s(), grad_T2s(), grad_ω0(), grad_B1()];\nnothing #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"and we sum up the CRB of all parameters, weighted by the following vector:","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"weights = transpose([0, 1, 0, 0, 0, 0, 0, 0, 0]);\nnothing #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"Note that the vector weights has one more entry compared to the grad_list vector, as the first derivative is always wrt. M_0, regardless of grad_list. Here, we only optimize for the CRB of m_0^s, while accounting for a fit of all 9 model parameters.","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"We take some initial guess for the pulse train:","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"α = abs.(sin.((1:Npulses) * 2π/Npulses));\nnothing #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"initialize with a constant TRF = 300μs:","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"TRF = 300e-6 .* one.(α);\nnothing #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"and define the first RF pulse as a 500μs inversion pulse by modifying vectors accordingly and by creating a bit vector that indicates the position of the inversion pulse:","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"α[1] = π\nTRF[1] = 500e-6\nisInversionPulse = [true; falses(length(α)-1)];\nnothing #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"We note that inversion pulses are not optimized by this toolbox. We calculate the initial ω_1","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"ω1 = α ./ TRF;\nnothing #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"and plot the initial control:","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"p1 = plot(TR*(1:Npulses), α ./ π, ylabel=\"α/π\")\np2 = plot(TR*(1:Npulses), 1e6TRF, ylim=(0, 1e3), xlabel=\"t (s)\", ylabel=\"TRF (μs)\")\np = plot(p1, p2, layout=(2, 1), legend=:none)\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"With above defined weights, the function MRIgeneralizedBloch.CRB_gradient_OCT returns the CRB","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"(CRBm0s, grad_ω1, grad_TRF) = MRIgeneralizedBloch.CRB_gradient_OCT(ω1, TRF, TR, ω0, B1, m0s, R1f, R2f, Rx, R1s, T2s, R2slT, grad_list, weights, isInversionPulse=isInversionPulse)\nCRBm0s","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"along with the gradients:","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"p1 = plot(TR*(1:Npulses), grad_ω1  .* ((-1) .^ (1:Npulses)), ylabel=\"∂CRB(m0s) / ∂ω1 (s/rad)\")\np2 = plot(TR*(1:Npulses), grad_TRF .* ((-1) .^ (1:Npulses)), ylabel=\"∂CRB(m0s) / ∂TRF (1/s)\", xlabel=\"t (s)\")\np = plot(p1, p2, layout=(2, 1), legend=:none)\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"Note that we remove the oscillating nature of the gradient for the display.","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"In this example, we limit the control to the following bounds","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"ω1_min  = 0      # rad/s\nω1_max  = 2e3π   # rad/s\nTRF_min = 100e-6 # s\nTRF_max = 500e-6; # s\nnothing #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"and the function MRIgeneralizedBloch.bound_ω1_TRF! modifies ω1 and TRF to comply with these bounds and returns a single vector in the range [-Inf, Inf] that relates to the bounded control by a tanh transformation:","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"x0 = MRIgeneralizedBloch.bound_ω1_TRF!(ω1, TRF; ω1_min = ω1_min, ω1_max = ω1_max, TRF_min = TRF_min, TRF_max = TRF_max)","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"Further, we initialize a gradient of the same length:","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"G = similar(x0);\nnothing #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"and define the cost function:","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"function fg!(F, G, x)\n    ω1, TRF = MRIgeneralizedBloch.get_bounded_ω1_TRF(x; ω1_min = ω1_min, ω1_max = ω1_max, TRF_min = TRF_min, TRF_max = TRF_max)\n\n    (F, grad_ω1, grad_TRF) = MRIgeneralizedBloch.CRB_gradient_OCT(ω1, TRF, TR, ω0, B1, m0s, R1f, R2f, Rx, R1s, T2s, R2slT, grad_list, weights, isInversionPulse=isInversionPulse)\n    F = abs(F)\n\n    F += MRIgeneralizedBloch.second_order_α!(grad_ω1, grad_TRF, ω1, TRF; idx=isInversionPulse, λ=1e4)\n    F += MRIgeneralizedBloch.RF_power!(grad_ω1, grad_TRF, ω1, TRF; idx=isInversionPulse, λ=1e-3, Pmax=3e6, TR=TR)\n    F += MRIgeneralizedBloch.TRF_TV!(grad_TRF, ω1, TRF; idx=isInversionPulse, λ=1e3)\n\n    MRIgeneralizedBloch.apply_bounds_to_grad!(G, x, grad_ω1, grad_TRF; ω1_min = ω1_min, ω1_max = ω1_max, TRF_min = TRF_min, TRF_max = TRF_max)\n    return F\nend;\nnothing #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"We perform the optimization with the package Optim.jl, which requires the cost function fg!(F, G, x) to take the cost, the gradient, and the control as input variables and to over-write the gradient in place. The cost function calculates the gradient of the CRB with above described optimal control code and we, further, add some regularization terms: MRIgeneralizedBloch.second_order_α! penalizes the curvature of α, which smoothes the flip angle train and helps ensuring the hybrid state conditions. The penalty MRIgeneralizedBloch.RF_power! penalizes the power deposition of the RF-pulse train if Sigma_i(ω_1^2i  T_textRFi)  T_textcycle  P_max and helps with compliance to safety limits. Assuming a reasonable λ, the optimization will converge to an average RF-power deposition equal to or less than Pmax in units of (rad/s)². Heuristically, the value Pmax=3e6 (rad/s)² proofed to be a reasonable choice for 3T systems. The penalty MRIgeneralizedBloch.TRF_TV! penalizes fast fluctuations of T_textRF. This penalty is justified by the knowledge that fluctuations of the control have negligible effect if they are fast compared to the biophysical time constants. We note, however, that this penalty is not required and rather ensure beauty of the result and speeds up convergence.","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"With all this in place, we can start the actual optimization","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"result = optimize(Optim.only_fg!(fg!), # cost function\n    x0,                                # initialization\n    BFGS(),                            # algorithm\n    Optim.Options(\n        iterations=10_000,             # larger number as we use a time limit\n        time_limit=(15*60)             # in seconds\n        )\n    )","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"After transforming the optimized control back into the space of bounded ω_1 and T_textRF values","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"ω1, TRF = MRIgeneralizedBloch.get_bounded_ω1_TRF(result.minimizer; ω1_min = ω1_min, ω1_max = ω1_max, TRF_min = TRF_min, TRF_max = TRF_max)\nα = ω1 .* TRF;\nnothing #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"we analyze the CRB(m0s):","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"(CRBm0s, grad_ω1, grad_TRF) = MRIgeneralizedBloch.CRB_gradient_OCT(ω1, TRF, TR, ω0, B1, m0s, R1f, R2f, Rx, R1s, T2s, R2slT, grad_list, weights, isInversionPulse=isInversionPulse)\nCRBm0s","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"and observe a substantial reduction. Further, we plot the optimized control:","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"p1 = plot(TR*(1:Npulses), α ./ π, ylabel=\"α/π\")\np2 = plot(TR*(1:Npulses), 1e6TRF, ylim=(0, 1e3), xlabel=\"t (s)\", ylabel=\"TRF (μs)\")\np = plot(p1, p2, layout=(2, 1), legend=:none)\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"To further analyze the results, we can calculate and plot all magnetization components:","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"m = calculatesignal_linearapprox(α, TRF, TR, ω0, B1, m0s, R1f, R2f, Rx, R1s, T2s, R2slT; output=:realmagnetization)\nm = vec(m)\n\nxf = [m[i][1] for i=1:length(m)]\nyf = [m[i][2] for i=1:length(m)]\nzf = [m[i][3] for i=1:length(m)]\nxs = [m[i][4] for i=1:length(m)]\nzs = [m[i][5] for i=1:length(m)]\n\np = plot(xlabel=\"t (s)\", ylabel=\"m (normalized)\")\nplot!(p, TR*(1:Npulses), xf ./(1-m0s), label=\"xᶠ\")\nplot!(p, TR*(1:Npulses), yf ./(1-m0s), label=\"yᶠ\")\nplot!(p, TR*(1:Npulses), zf ./(1-m0s), label=\"zᶠ\")\nplot!(p, TR*(1:Npulses), xs ./   m0s , label=\"xˢ\")\nplot!(p, TR*(1:Npulses), zs ./   m0s , label=\"zˢ\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"And we can also plot the dynamics of the free spin pool on the Bloch sphere:","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"p = plot(xf, zf, xlabel=\"xf\", ylabel=\"zf\", framestyle = :zerolines, legend=:none)\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"As yᶠ is close to zero in this particular case, we neglect it in this 2D plot.","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"","category":"page"},{"location":"build_literate/OCT/","page":"Optimal Control","title":"Optimal Control","text":"This page was generated using Literate.jl.","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"EditURL = \"../Analyze_NMR_PreSat_Data.jl\"","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"(Image: )","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/#Continuous-Wave-Saturation-Experiments","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"The following code analyzes data from a steady-state experiment similar to the original work of Henkelman et al. In this experiment, the magnetization of the coupled spin system is saturated with off-resonant continuous waves of the exponentially spaced frequencies:","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"Δ = exp.(range(log(0.01e3), log(100e3), length=20)) * 2π # rad/s","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"and the amplitudes:","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"ω1_dB = -60:5:-5 # dB\nω1 = @. 10^(ω1_dB / 20) * π / 2 / 11.4e-6 # rad/s","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"The waves were applied for 7 seconds to ensure a steady state. Thereafter, the magnetization was excited with a π/2-pulse and an FID was acquired. The repetition times was 30s to ensure full recovery to thermal equilibrium.","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"We fit the data with Henkelman's closed form solution to this steady-state problem while assuming a Lorentzian lineshape for the free spin pool, and different lineshapes for the semi-solid spin pool:","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"g_Lorentzian(Δ, T2) = T2 / π / (1 + (T2 * Δ)^2)\ng_Gaussian(Δ, T2) = T2 / sqrt(2π) * exp(-(T2 * Δ)^2 / 2)\ng_superLorentzian(Δ, T2) = T2 * sqrt(2 / π) * quadgk(ct -> exp(- 2 *  (T2 * Δ / (3 * ct^2 - 1))^2) / abs(3 * ct^2 - 1), 0, sqrt(1 / 3), 1)[1];\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"For this data analysis we need the following packages:","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"using MRIgeneralizedBloch\nusing QuadGK\nusing LsqFit\nusing LinearAlgebra\nusing Statistics\nusing Printf\nusing Plots\nplotlyjs(bg=RGBA(31 / 255, 36 / 255, 36 / 255, 1.0), ticks=:native); # hide\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"The raw data is stored in a separate github repository and the following functions return the URL to the individual files:","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"MnCl2_data(ω1_dB) = string(\"https://github.com/JakobAsslaender/MRIgeneralizedBloch_NMRData/blob/main/20210419_1mM_MnCl2/ja_PreSat_v2%20(\", ω1_dB, \")/1/data.2d?raw=true\")\nBSA_data(ω1_dB)   = string(\"https://github.com/JakobAsslaender/MRIgeneralizedBloch_NMRData/blob/main/20210416_15%25BSA_2ndBatch/ja_PreSat_v2%20(\", ω1_dB, \")/1/data.2d?raw=true\");\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"which can be loaded with functions implemented in this file:","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"include(string(pathof(MRIgeneralizedBloch), \"/../../docs/src/load_NMR_data.jl\"));\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"We store the off-resonance frequencies and wave amplitudes in a single matrix for convenience:","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"x = zeros(Float64, length(ω1) * length(Δ), 2)\nx[:,1] = repeat(Δ, length(ω1))\nx[:,2] = vec(repeat(ω1, 1, length(Δ))');\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/#MnCl_2-Sample","page":"Continuous Wave Saturation Experiments","title":"MnCl_2 Sample","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"We load the first data point of each FID:","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"M = zeros(Float64, length(Δ), length(ω1))\nfor i = 1:length(ω1_dB)\n    M[:,i] = load_first_datapoint(MnCl2_data(ω1_dB[i]); set_phase=:abs)\nend\nM ./= maximum(M);\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"In contrast to the inversion-recovery experiment, the phase of the signal was not stable. Therefore, we took the absolute value of the signal by setting the flag set_phase=:abs.","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"The MnCl_2-data can be described with a single compartment model:","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"function single_compartment_model(x, p)\n    (m0, R1, T2) = p\n\n    Δ  = @view x[:,1]\n    ω1 = @view x[:,2]\n\n    Rrf = @. π * ω1^2 * g_Lorentzian(Δ, T2)\n    m = @. m0 * R1 / (R1 + Rrf)\n    return m\nend;\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"(cf. Eqs. (14) and (15) in the paper).","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"As this model is merely a function of the relaxation times T₁ and T₂, we forgo a fitting routine and use the estimates from the Inversion Recovery Experiments instead:","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"R1 = 1.479 # 1/s\nT2 = 0.075 # s\nnothing # hide","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"Visually, this model describes the data well:","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"p = plot(xlabel=\"Δ [rad/s]\", ylabel=\"M / max(M)\", xaxis=:log, legend=:none)\n[scatter!(p, Δ, M[:,i], color=i) for i=1:length(ω1)]\n[plot!(p, Δ, reshape(single_compartment_model(x, [1,R1,T2]), length(Δ), length(ω1))[:,i], color=i) for i=1:length(ω1)]\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/#Bovine-Serum-Albumin-Sample","page":"Continuous Wave Saturation Experiments","title":"Bovine Serum Albumin Sample","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"We acquired the same data for the BSA sample, which we load:","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"for i = 1:length(ω1_dB)\n    M[:,i] = load_first_datapoint(BSA_data(ω1_dB[i]); set_phase=:abs)\nend\nM ./= maximum(M);\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"We model the steady-state magnetization as described by Henkelman et al.:","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"function Henkelman_model(x, p; lineshape=:superLorentzian)\n    (m0, m0s, R1f, R1s, T2f, T2s, Rx) = p\n\n    m0s /= 1 - m0s # switch from m0s + m0f = 1 to m0f = 1 normalization\n\n    Δ  = @view x[:,1]\n    ω1 = @view x[:,2]\n\n    Rrf_f = @. π * ω1^2 * g_Lorentzian(Δ, T2f)\n\n    if lineshape == :Lorentzian\n        Rrf_s = @. π * ω1^2 * g_Lorentzian(Δ, T2s)\n    elseif lineshape == :Gaussian\n        Rrf_s = @. π * ω1^2 * g_Gaussian(Δ, T2s)\n    elseif lineshape == :superLorentzian\n        Rrf_s = @. π * ω1^2 * g_superLorentzian(Δ, T2s)\n    end\n\n    m = @. m0 * (R1s * Rx * m0s + Rrf_s * R1f + R1f * R1s + R1f * Rx) / ((R1f + Rrf_f + Rx * m0s) * (R1s + Rrf_s + Rx) - Rx^2 * m0s)\n    return m\nend;\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"Here, we use a fitting routine to demonstrate the best possible fit with each of the three lineshapes. We define an initialization for the fitting routine p0 = [m0, m0s, R1f, R1s, T2f, T2s, Rx] and set some reasonable bounds:","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"p0   = [  1,0.01,   1,   5,0.052,  1e-5, 40]\npmin = [  0,   0,   0,   0,0.052,  1e-6,  1]\npmax = [Inf,   1, Inf, Inf,0.052, 10e-3,100];\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"Note that we fixed T₂ᶠ = 52ms to the value estimated with the Inversion Recovery Experiments as T₂ᶠ is poorly defined by this saturation experiment.","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/#Super-Lorentzian-Lineshape","page":"Continuous Wave Saturation Experiments","title":"Super-Lorentzian Lineshape","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"Fitting the model with a super-Lorentzian lineshape to the data achieves good concordance:","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"fit = curve_fit((x, p) -> Henkelman_model(x, p; lineshape=:superLorentzian), x, vec(M), p0, lower=pmin, upper=pmax)\nfit_std = stderror(fit)\n\np = plot(xlabel=\"Δ [rad/s]\", ylabel=\"M / max(M)\", xaxis=:log, legend=:none)\n[scatter!(p, Δ, M[:,i], color=i) for i=1:length(ω1)]\n[plot!(p, Δ, reshape(Henkelman_model(x, fit.param), length(Δ), length(ω1))[:,i], color=i) for i=1:length(ω1)]\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/#Lorentzian-Lineshape","page":"Continuous Wave Saturation Experiments","title":"Lorentzian Lineshape","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"The Lorentzian lineshape, on the other hand, does not fit the data well:","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"fit = curve_fit((x, p) -> Henkelman_model(x, p; lineshape=:Lorentzian), x, vec(M), p0, lower=pmin, upper=pmax)\nfit_std = stderror(fit)\n\np = plot(xlabel=\"Δ [rad/s]\", ylabel=\"M / max(M)\", xaxis=:log, legend=:none)\n[scatter!(p, Δ, M[:,i], color=i) for i=1:length(ω1)]\n[plot!(p, Δ, reshape(Henkelman_model(x, fit.param), length(Δ), length(ω1))[:,i], color=i) for i=1:length(ω1)]\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/#Gaussian-Lineshape","page":"Continuous Wave Saturation Experiments","title":"Gaussian Lineshape","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"And the Gaussian lineshape does not not fit the data well either:","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"fit = curve_fit((x, p) -> Henkelman_model(x, p; lineshape=:Lorentzian), x, vec(M), p0, lower=pmin, upper=pmax)\nfit_std = stderror(fit)\n\np = plot(xlabel=\"Δ [rad/s]\", ylabel=\"M / max(M)\", xaxis=:log, legend=:none)\n[scatter!(p, Δ, M[:,i], color=i) for i=1:length(ω1)]\n[plot!(p, Δ, reshape(Henkelman_model(x, fit.param), length(Δ), length(ω1))[:,i], color=i) for i=1:length(ω1)]\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"","category":"page"},{"location":"build_literate/Analyze_NMR_PreSat_Data/","page":"Continuous Wave Saturation Experiments","title":"Continuous Wave Saturation Experiments","text":"This page was generated using Literate.jl.","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"EditURL = \"../Analyze_NMR_IR_Data.jl\"","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"(Image: )","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/#Inversion-Recovery-Experiments","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"The following code replicates the NMR data analysis in Figs. 4-6 and complements the paper with additional analyses that are not shown in the paper in the interest of brevity.","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"For this analysis we need the following packages:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"using MRIgeneralizedBloch\nusing DifferentialEquations\nusing LinearAlgebra\nusing LsqFit\nusing Statistics\nimport Pingouin\nusing Printf\nusing Formatting\nusing Plots\nplotlyjs(bg = RGBA(31/255,36/255,36/255,1.0), ticks=:native); #hide\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"The raw data is stored in a separate github repository and the following functions return the URL to the individual files:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"MnCl2_data(TRF_scale) = string(\"https://github.com/JakobAsslaender/MRIgeneralizedBloch_NMRData/blob/main/20210419_1mM_MnCl2/ja_IR_v2%20(\", TRF_scale, \")/1/data.2d?raw=true\")\nBSA_data(TRF_scale)   = string(\"https://github.com/JakobAsslaender/MRIgeneralizedBloch_NMRData/blob/main/20210416_15%25BSA_2ndBatch/ja_IR_v2%20(\", TRF_scale, \")/1/data.2d?raw=true\");\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"which can be loaded with functions implemented in this file:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"include(string(pathof(MRIgeneralizedBloch), \"/../../docs/src/load_NMR_data.jl\"));\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/#MnCl_2-Sample","page":"Inversion Recovery Experiments","title":"MnCl_2 Sample","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_IR_Data/#T_2{*,f}-Estimation","page":"Inversion Recovery Experiments","title":"T_2^*f Estimation","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"We estimate T_2^*f by fitting a mono-exponential decay curve to the FID of the acquisition with T_textRF = 228μs and T_texti = 5s.","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"M = load_Data(MnCl2_data(1))\nM = M[:,1]; # select Tᵢ = 5s\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"The data was measured at the following time points in units of seconds:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"T_dwell = 100e-6 # s\nTE = T_dwell * ((1:length(M)) .+ 7) # s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Note that the signal is an FID, so the phrase echo time is a bit misleading.","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"The function curve_fit from the LsqFit.jl package is only implemented for real-valued models. To accommodate this, we need to split the data into its real and imaginary part:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"TEreal = [TE;TE]\nMreal = [real(M);imag(M)];\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Here, we are using a simple mono-exponential model with a complex-valued scaling factor p[1] + 1im p[2], the decay time T_2^*f = p[3], and the Larmor frequency p[4]:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"FID_model(t, p) = @. [p[1] * exp(- t[1:end ÷ 2] / p[3]) * cos(p[4] * t[1:end ÷ 2]); p[2] * exp(- t[end ÷ 2 + 1:end] / p[3]) * sin(p[4] * t[end ÷ 2 + 1:end])];\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Fitting this model to the NMR data estimates T_2^*f:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"fit = curve_fit(FID_model, TEreal, Mreal, [1, 1, 0.1, 0])\nT₂star_MnCl2 = fit.param[3] # s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"seconds and its uncertainty (also in units of seconds)","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"stderror(fit)[3] # s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Visually, the plot and the data show good agreement:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Mfitted = FID_model(TEreal, fit.param)\nMfitted = Mfitted[1:end÷2] + 1im * Mfitted[end÷2+1:end]\np = plot(xlabel=\"TE [s]\", ylabel=\"|FID(TE)| [a.u.]\")\nplot!(p, TE, abs.(M), label=\"data\")\nplot!(p, TE, abs.(Mfitted), label=@sprintf(\"fit with T₂* = %2.3f ms\", 1e3 * T₂star_MnCl2))\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"The relative residual norm of the fit, i.e. textresidual_2M_2 is","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"norm(fit.resid) / norm(M)","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Despite its small ell_2-norm, the Shapiro-Wilk test indicates that the residual is not Gaussian or normal distributed at a significance level of α=0.05","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Pingouin.normality(fit.resid, α=0.05)","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"We note that mono-exponential T_2^* decays assume a Lorentzian distributed magnetic field, which is in general an assumption rather than a well-founded theory.","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/#Mono-Exponential-IR-Model","page":"Inversion Recovery Experiments","title":"Mono-Exponential IR Model","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"We performed several experiments in which we inverted the thermal equilibrium magnetization with rectangular π-pulses with the following pulse durations (in seconds):","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Tʳᶠmin = 22.8e-6 # s - shortest Tʳᶠ possible on the NMR\nTRF_scale = [1;2;5:5:40] # scaling factor\nTʳᶠ = TRF_scale * Tʳᶠmin # s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"and acquired inversion recovery data at exponentially spaced inversion times (in seconds):","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Tᵢ = exp.(range(log(3e-3), log(5), length=20)) # s\nTᵢ .+= 12 * Tʳᶠmin + (13 * 15.065 - 5) * 1e-6 # s - correction factors","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"We calculate the Rabi frequencies of the RF pulses and a finer grid of T_texti to plot the IR model:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"ω₁ = π ./ Tʳᶠ # rad/s\nTᵢplot = exp.(range(log(Tᵢ[1]), log(Tᵢ[end]), length=500)); # s\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"After loading and normalizing the data","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"M = zeros(Float64, length(Tᵢ), length(TRF_scale))\nfor i = 1:length(TRF_scale)\n    M[:,i] = load_first_datapoint(MnCl2_data(TRF_scale[i]))\nend\nM ./= maximum(M);\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"we analyze each inversion recovery curve that corresponds to a different T_textRF separately. This allows us to fit a simple mono-exponential model","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"standard_IR_model(t, p) = @. p[1] - p[3] * exp(- t * p[2]);\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"where p[1] is the thermal equilibrium magnetization, p[2] = T_1, and p[1] - p[3] is the magnetization right after the inversion pulse or, equivalently, Minv = p[1] / p[3] - 1 is the inversion efficiency, which is 1 for an ideal π-pulse and smaller otherwise. The parameters are initialized with","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"p0 = [1.0, 1.0, 2.0];\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"and we can loop over T_textRF to perform the fits:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"R₁ = similar(M[1,:])\nMinv = similar(R₁)\nresidual = similar(R₁)\np = plot(xlabel=\"Tᵢ [s]\", ylabel=\"zᶠ(Tʳᶠ, Tᵢ) [a.u.]\")\nfor i = 1:length(TRF_scale)\n    Mi = @view M[:,i]\n\n    fit = curve_fit(standard_IR_model, Tᵢ, Mi, p0)\n\n    R₁[i] = fit.param[2]\n    Minv[i] = fit.param[3] / fit.param[1] - 1\n\n    residual[i] = norm(fit.resid) / norm(Mi)\n\n    scatter!(p, Tᵢ, Mi, label=@sprintf(\"Tʳᶠ = %1.2es - data\", Tʳᶠ[i]), color=i)\n    plot!(p, Tᵢplot, standard_IR_model(Tᵢplot, fit.param), label=@sprintf(\"fit with R₁ = %.3f/s; MInv = %.3f\", R₁[i], Minv[i]), color=i)\nend\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Here, the data measured with different T_textRF are indicated by markers in different colors, and the corresponding fits are the line plots in the same color. The fitted parameters are denoted in the legend. In the paper, we highlight the estimated inversion efficiency and the relaxation rate of the dataset acquired with T_textRF=228μs:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Minv[1]","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"R₁[1] # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"and of the dataset acquired with T_textRF=912μs:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Minv[end]","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"R₁[end] # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"The mean value of all R₁ estimates is","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"mean(R₁) # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"1/s and its standard deviation in units of 1/s is","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"std(R₁) # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"The relative residual norm of the fits is on average","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"mean(residual)","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/#Global-IR-Fit","page":"Inversion Recovery Experiments","title":"Global IR Fit","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"As an alternative to individual fits to the inversion recovery curves with different T_textRF, we can also perform a global fit that accounts for the T_2^*f decay during the inversion pulse. The model first simulates the T_2^*f decay during the inversion pulse, followed by T_1 recovery:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"function Bloch_IR_model(p, Tʳᶠ, Tᵢ, T2)\n    (m0, m0_inv, R₁) = p\n    R2 = 1 / T2\n\n    M = zeros(Float64, length(Tᵢ), length(Tʳᶠ))\n    for i = 1:length(Tʳᶠ)\n        # simulate inversion pulse\n        ω₁ = π / Tʳᶠ[i]\n        H = [-R2 -ω₁ 0 ;\n              ω₁ -R₁ R₁;\n               0   0 0 ]\n\n        m_inv = m0_inv * (exp(H * Tʳᶠ[i]) * [0,1,1])[2]\n\n        # simulate T1 recovery\n        H = [-R₁ R₁*m0;\n               0     0]\n\n        for j = 1:length(Tᵢ)\n            M[j,i] = m0 * (exp(H .* (Tᵢ[j] - Tʳᶠ[i] / 2)) * [m_inv,1])[1]\n        end\n    end\n    return vec(M)\nend;\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"We use the previously estimated T_2^*f value for the fit:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"fit = curve_fit((x, p) -> Bloch_IR_model(p, Tʳᶠ, Tᵢ, T₂star_MnCl2), 1:length(M), vec(M), [ 1, .8, 1])\n\np = plot(xlabel=\"Tᵢ [s]\", ylabel=\"zᶠ(Tʳᶠ, Tᵢ) [a.u.]\")\nfor i=1:length(Tʳᶠ)\n    scatter!(p, Tᵢ, M[:,i], label=@sprintf(\"Tʳᶠ = %1.2es\", Tʳᶠ[i]), color=i)\n    plot!(p, Tᵢplot, Bloch_IR_model(fit.param, Tʳᶠ[i], Tᵢplot, T₂star_MnCl2), label=@sprintf(\"Tʳᶠ = %1.2es\", Tʳᶠ[i]), color=i)\nend\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"With this global fit, we get a very similar relaxation rate in units of 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"R₁_MnCl2 = fit.param[3] # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"with an uncertainty (also in units of 1/s) of","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"stderror(fit)[3] # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Note that the relative residual norm is somewhat increased compared to individual fits to each inversion recovery curve:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"norm(fit.resid) / norm(M)","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/#Bovine-Serum-Albumin-Sample","page":"Inversion Recovery Experiments","title":"Bovine Serum Albumin Sample","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_IR_Data/#T_2{*,f}-Estimation-2","page":"Inversion Recovery Experiments","title":"T_2^*f Estimation","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"We repeat the T_2^*f estimation for the bovine serum albumin (BSA) sample by fitting a mono-exponential decay curve to the FID of the acquisition with T_textRF = 228μs and T_texti = 5s.","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"M = load_Data(BSA_data(1));\nM = M[:,1] # select Tᵢ = 5s\nMreal = [real(M);imag(M)]\n\nfit = curve_fit(FID_model, TEreal, Mreal, [1.0, 1.0, .1, 0.0]);\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"The estimated T_2^*f of the BSA sample is","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"T₂star_BSA = fit.param[3] # s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"seconds with an uncertainty of","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"stderror(fit)[3] # s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"seconds.","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Visually, the plot and the data align well for the BSA sample, too:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Mfitted = FID_model(TEreal, fit.param)\nMfitted = Mfitted[1:end÷2] + 1im * Mfitted[end÷2+1:end]\np = plot(xlabel=\"TE [s]\", ylabel=\"|FID(TE)| [a.u.]\")\nplot!(p, TE, abs.(M), label=\"data\")\nplot!(p, TE, abs.(Mfitted), label=@sprintf(\"fit with T₂* = %2.3f ms\", 1e3 * T₂star_BSA))\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"The relative residual norm (textresidual_2M_2) is","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"norm(fit.resid) / norm(M)","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Despite the small residual, the Shapiro-Wilk test indicates that the residual is not normal distributed for this sample either:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Pingouin.normality(fit.resid, α=0.05)","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/#Mono-Exponential-IR-Model-2","page":"Inversion Recovery Experiments","title":"Mono-Exponential IR Model","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"We also fit a mono-exponential model to each inversion recovery curve of the BSA data:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"M = zeros(Float64, length(Tᵢ), length(TRF_scale))\nfor i = 1:length(TRF_scale)\n    M[:,i] = load_first_datapoint(BSA_data(TRF_scale[i]))\nend\nM ./= maximum(M)\n\n\np = plot(xlabel=\"Tᵢ [s]\", ylabel=\"zᶠ(Tʳᶠ, Tᵢ) [a.u.]\")\nfor i = 1:length(TRF_scale)\n    Mi = @view M[:,i]\n\n    fit = curve_fit(standard_IR_model, Tᵢ, Mi, p0)\n\n    R₁[i] = fit.param[2]\n    Minv[i] = fit.param[3] / fit.param[1] - 1\n    residual[i] = norm(fit.resid) / norm(Mi)\n\n    scatter!(p, Tᵢ, Mi, label=@sprintf(\"Tʳᶠ = %1.2es - data\", Tʳᶠ[i]), color=i)\n    plot!(p, Tᵢplot, standard_IR_model(Tᵢplot, fit.param), label=@sprintf(\"fit with R₁ = %.3f/s; MInv = %.3f\", R₁[i], Minv[i]), color=i)\nend\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Zooming into the early phase of the recovery curve reveals the poor fit quality, in particular for long T_textRF. This is also reflected by a substantially larger relative residual norm compared to the MnCl_2 sample:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"mean(residual)","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"In the paper, we highlight the estimated inversion efficiency and the relaxation rate of the dataset acquired with T_textRF=228μs","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Minv[1]","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"R₁[1] # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"and of the dataset acquired with T_textRF=912μs","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Minv[end]","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"R₁[end] # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"The mean value of all R₁ estimates is","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"mean(R₁) # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"and its standard deviation is substantially larger compared to the same fit of the MnCl_2 sample:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"std(R₁) # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/#Global-IR-Fit-Generalized-Bloch-Model","page":"Inversion Recovery Experiments","title":"Global IR Fit - Generalized Bloch Model","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"In order to repeat the global fit that includes all T_textRF values, we have to account for the spin dynamics in the semi-solid pool during the RF-pulse. First, we do this with the proposed generalized Bloch model:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"function gBloch_IR_model(p, G, Tʳᶠ, TI, R2f)\n    (m0, m0f_inv, m0s, R₁, T₂ˢ, Rx) = p\n    m0f = 1 - m0s\n    ω₁ = π ./ Tʳᶠ\n\n    m0vec = [0, 0, m0f, m0s, 1]\n    m_fun(p, t; idxs=nothing) = typeof(idxs) <: Number ? 0.0 : zeros(5)\n\n\n    H = [-R₁-m0s*Rx     m0f*Rx R₁*m0f;\n             m0s*Rx -R₁-m0f*Rx R₁*m0s;\n              0          0         0 ]\n\n    M = zeros(Float64, length(TI), length(Tʳᶠ))\n    for i = 1:length(Tʳᶠ)\n        param = (ω₁[i], 1, 0, m0s, R₁, R2f, Rx, R₁, T₂ˢ, G)\n        prob = DDEProblem(apply_hamiltonian_gbloch!, m0vec, m_fun, (0.0, Tʳᶠ[i]), param)\n        m = solve(prob)[end]\n\n        for j = 1:length(TI)\n            M[j,i] = m0 * (exp(H .* (TI[j] - Tʳᶠ[i] / 2)) * [m0f_inv * m[3],m[4],1])[1]\n        end\n    end\n    return vec(M)\nend;\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Here, we use assume a super-Lorentzian lineshape, whose Green's function is interpolated to speed up the fitting routine:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"T₂ˢ_min = 5e-6 # s\nG_superLorentzian = interpolate_greens_function(greens_superlorentzian, 0, maximum(Tʳᶠ)/T₂ˢ_min);\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"The fit is initialized with p0 = [m0, m0f_inv, m0_s, R₁, T2_s, Rx] and we set some reasonable bounds to the fitted parameters:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"p0   = [  1, 0.932,  0.1,   1, 10e-6, 50]\npmin = [  0, 0.100,   .0, 0.3,  1e-9, 10]\npmax = [Inf,   Inf,  1.0, Inf, 20e-6,1e3]\n\nfit_gBloch = curve_fit((x, p) -> gBloch_IR_model(p, G_superLorentzian, Tʳᶠ, Tᵢ, 1/T₂star_BSA), [], vec(M), p0, lower=pmin, upper=pmax);\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Visually, the plot and the data align well:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"p = plot(xlabel=\"Tᵢ [s]\", ylabel=\"zᶠ(Tʳᶠ, Tᵢ) [a.u.]\")\nfor i=1:length(Tʳᶠ)\n    scatter!(p, Tᵢ, M[:,i], label=@sprintf(\"Tʳᶠ = %1.2es\", Tʳᶠ[i]), color=i)\n    plot!(p, Tᵢplot, gBloch_IR_model(fit_gBloch.param, G_superLorentzian, Tʳᶠ[i], Tᵢplot, 1/T₂star_BSA), label=@sprintf(\"Tʳᶠ = %1.2es\", Tʳᶠ[i]), color=i)\nend\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"which becomes particularly apparent when zooming into the beginning of the inversion recovery curves. Further, the relative residual norm is much smaller compared to the mono-exponential fit:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"norm(fit_gBloch.resid) / norm(M)","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"The estimated parameters are","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"m0 = fit_gBloch.param[1]","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Minv = fit_gBloch.param[2]","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"m0s = fit_gBloch.param[3]","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"R₁ = fit_gBloch.param[4] # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"T₂ˢ = 1e6fit_gBloch.param[5] # μs","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Rx = fit_gBloch.param[6] # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"with the uncertainties (in the same order)","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"stderror(fit_gBloch)","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/#Global-IR-Fit-Graham's-Spectral-Model","page":"Inversion Recovery Experiments","title":"Global IR Fit - Graham's Spectral Model","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"For comparison, we repeat the same fit with Graham's spectral model:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"function Graham_IR_model(p, Tʳᶠ, TI, R2f)\n    (m0, m0f_inv, m0s, R₁, T₂ˢ, Rx) = p\n    m0f = 1 - m0s\n    ω₁ = π ./ Tʳᶠ\n\n    m0vec = [0, 0, m0f, m0s, 1]\n\n    H = [-R₁-m0s*Rx     m0f*Rx R₁*m0f;\n             m0s*Rx -R₁-m0f*Rx R₁*m0s;\n              0          0         0 ]\n\n    M = zeros(Float64, length(TI), length(Tʳᶠ))\n    for i = 1:length(Tʳᶠ)\n        param = (ω₁[i], 1, 0, Tʳᶠ[i], m0s, R₁, R2f, Rx, R₁, T₂ˢ)\n        prob = ODEProblem(apply_hamiltonian_graham_superlorentzian!, m0vec, (0.0, Tʳᶠ[i]), param)\n        m = solve(prob)[end]\n\n        for j = 1:length(TI)\n            M[j,i] = m0 * (exp(H .* (TI[j] - Tʳᶠ[i] / 2)) * [m0f_inv * m[3],m[4],1])[1]\n        end\n    end\n    return vec(M)\nend\n\nfit_Graham = curve_fit((x, p) -> Graham_IR_model(p, Tʳᶠ, Tᵢ, 1/T₂star_BSA), [], vec(M), p0, lower=pmin, upper=pmax);\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Visually, the plot and the data align substantially worse:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"p = plot(xlabel=\"Tᵢ [s]\", ylabel=\"zᶠ(Tʳᶠ, Tᵢ) [a.u.]\")\nfor i=1:length(Tʳᶠ)\n    scatter!(p, Tᵢ, M[:,i], label=@sprintf(\"Tʳᶠ = %1.2es\", Tʳᶠ[i]), color=i)\n    plot!(p, Tᵢplot, Graham_IR_model(fit_Graham.param, Tʳᶠ[i], Tᵢplot, 1/T₂star_BSA), label=@sprintf(\"Tʳᶠ = %1.2es\", Tʳᶠ[i]), color=i)\nend\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"which becomes particularly apparent when zooming into the beginning of the inversion recovery curves. Further, the relative residual norm is much larger compared to the generalized Bloch fit:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"norm(fit_Graham.resid) / norm(M)","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"The estimated parameters are","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"m0 = fit_Graham.param[1]","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Minv = fit_Graham.param[2]","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"m0s = fit_Graham.param[3]","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"R₁ = fit_Graham.param[4] # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"T₂ˢ = 1e6fit_Graham.param[5] # μs","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Rx = fit_Graham.param[6] # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"with the uncertainties (in the same order)","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"stderror(fit_Graham)","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/#Global-IR-Fit-Sled's-Model","page":"Inversion Recovery Experiments","title":"Global IR Fit - Sled's Model","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"We also performed the fit with Sled's model:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"function Sled_IR_model(p, G, Tʳᶠ, TI, R2f)\n    (m0, m0f_inv, m0s, R₁, T₂ˢ, Rx) = p\n    m0f = 1 - m0s\n    ω₁ = π ./ Tʳᶠ\n\n    m0vec = [0, 0, m0f, m0s, 1]\n\n    H = [-R₁-m0s*Rx     m0f*Rx R₁*m0f;\n             m0s*Rx -R₁-m0f*Rx R₁*m0s;\n              0          0         0 ]\n\n    M = zeros(Float64, length(TI), length(Tʳᶠ))\n    for i = 1:length(Tʳᶠ)\n        param = (ω₁[i], 1, 0, m0s, R₁, R2f, Rx, R₁, T₂ˢ, G)\n        prob = ODEProblem(apply_hamiltonian_sled!, m0vec, (0.0, Tʳᶠ[i]), param)\n        m = solve(prob)[end]\n\n        for j = 1:length(TI)\n            M[j,i] = m0 * (exp(H .* (TI[j] - Tʳᶠ[i] / 2)) * [m0f_inv * m[3],m[4],1])[1]\n        end\n    end\n    return vec(M)\nend\n\nfit_Sled = curve_fit((x, p) -> Sled_IR_model(p, G_superLorentzian, Tʳᶠ, Tᵢ, 1/T₂star_BSA), [], vec(M), p0, lower=pmin, upper=pmax);\nnothing #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Visually, the plot and the data do not align well either:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"p = plot(xlabel=\"Tᵢ [s]\", ylabel=\"zᶠ(Tʳᶠ, Tᵢ) [a.u.]\")\nfor i=1:length(Tʳᶠ)\n    scatter!(p, Tᵢ, M[:,i], label=@sprintf(\"Tʳᶠ = %1.2es\", Tʳᶠ[i]), color=i)\n    plot!(p, Tᵢplot, Sled_IR_model(fit_Sled.param, G_superLorentzian, Tʳᶠ[i], Tᵢplot, 1/T₂star_BSA), label=@sprintf(\"Tʳᶠ = %1.2es\", Tʳᶠ[i]), color=i)\nend\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"which becomes particularly apparent when zooming into the beginning of the inversion recovery curves. Further, the relative residual norm is also large compared to the generalized Bloch fit:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"norm(fit_Sled.resid) / norm(M)","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"The estimated parameters are","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"m0 = fit_Sled.param[1]","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Minv = fit_Sled.param[2]","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"m0s = fit_Sled.param[3]","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"R₁ = fit_Sled.param[4] # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"T₂ˢ = 1e6fit_Sled.param[5] # μs","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"Rx = fit_Sled.param[6] # 1/s","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"with the uncertainties (in the same order)","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"stderror(fit_Sled)","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/#Analysis-of-the-Residuals","page":"Inversion Recovery Experiments","title":"Analysis of the Residuals","text":"","category":"section"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"In order to visualize how well the three models align with the data at different T_textRF, we calculate the ell_2-norm of the residuals after subtracting the modeled from the measured signal and normalize it by the ell_2-norm of the signal:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"resid_gBlo = similar(Tʳᶠ)\nresid_Sled = similar(Tʳᶠ)\nresid_Grah = similar(Tʳᶠ)\nfor i=1:length(Tʳᶠ)\n    resid_gBlo[i] = norm(gBloch_IR_model(fit_gBloch.param, G_superLorentzian, Tʳᶠ[i], Tᵢ, 1/T₂star_BSA) .- M[:,i]) / norm(M[:,i])\n    resid_Grah[i] = norm(Graham_IR_model(fit_Graham.param, Tʳᶠ[i], Tᵢ, 1/T₂star_BSA)                    .- M[:,i]) / norm(M[:,i])\n    resid_Sled[i] = norm(Sled_IR_model(  fit_Sled.param,   G_superLorentzian, Tʳᶠ[i], Tᵢ, 1/T₂star_BSA) .- M[:,i]) / norm(M[:,i])\nend\n\np = plot(xlabel=\"Tʳᶠ [s]\", ylabel=\"relative residual\")\nscatter!(p, Tʳᶠ, resid_gBlo, label=\"generalized Bloch model\")\nscatter!(p, Tʳᶠ, resid_Grah, label=\"Graham's spectral model\")\nscatter!(p, Tʳᶠ, resid_Sled, label=\"Sled's model\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"This analysis examines the residuals from the actual fits, i.e. it uses the biophysical parameters of respective fit to model the signal. The disadvantage of this approach is that residuals at long T_textRF are negatively affected by the poor fits of Graham's and Sled's models at short T_textRF. This problem is overcome by subtracting the measured signal from signal that is simulated with the biophysical parameters that were estimated by fitting the generalized Bloch model:","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"for i=1:length(Tʳᶠ)\n    resid_gBlo[i] = norm(gBloch_IR_model(fit_gBloch.param, G_superLorentzian, Tʳᶠ[i], Tᵢ, 1/T₂star_BSA) .- M[:,i]) / norm(M[:,i])\n    resid_Grah[i] = norm(Graham_IR_model(fit_gBloch.param, Tʳᶠ[i], Tᵢ, 1/T₂star_BSA)                    .- M[:,i]) / norm(M[:,i])\n    resid_Sled[i] = norm(Sled_IR_model(  fit_gBloch.param, G_superLorentzian, Tʳᶠ[i], Tᵢ, 1/T₂star_BSA) .- M[:,i]) / norm(M[:,i])\nend\n\np = plot(xlabel=\"Tʳᶠ [s]\", ylabel=\"relative residual\")\nscatter!(p, Tʳᶠ, resid_gBlo, label=\"generalized Bloch model\")\nscatter!(p, Tʳᶠ, resid_Grah, label=\"Graham's spectral model\")\nscatter!(p, Tʳᶠ, resid_Sled, label=\"Sled's model\")\nMain.HTMLPlot(p) #hide","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"One can observe reduced residuals for Graham's and Sled's models for long T_textRF as a trade off for larger residuals at short T_textRF. Yet, the residuals at long T_textRF are still substantially larger compared to ones of the generalized Bloch model.","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"","category":"page"},{"location":"build_literate/Analyze_NMR_IR_Data/","page":"Inversion Recovery Experiments","title":"Inversion Recovery Experiments","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MRIgeneralizedBloch","category":"page"},{"location":"#MRIgeneralizedBloch.jl","page":"Home","title":"MRIgeneralizedBloch.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for the MRIgeneralizedBloch.jl package, which implements the generalized Bloch model for simulating magnetization transfer (MT), as described in our paper. The key innovation of the model is to generalize the original Bloch model to arbitrary lineshapes, such as the super-Lorentzian lineshape which has been shown to describe brain white matter well. This enables a more accurate description of the spin dynamics during short RF-pulses compared to previous MT models.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package allows to simulate the dynamics of an isolated semi-solid spin pool during RF-pulses, as well as the dynamics of a coupled spin system with a free spin pool, for which we use the Bloch model, and a semi-solid pool, which we describe with the generalized Bloch model.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Section Simulation of a Single RF Pulse demonstrates the basic and flexible simulation of the spin dynamics during a single RF pulse and Section Balanced Hybrid-State Free Precession Pulse Sequence demonstrates an efficient simulation of a train of RF pulses. Section Non-Linear Least Square Fitting demonstrates a simple method for parameter estimation at the example of a Balanced Hybrid-State Free Precession pulse sequence; and Section Optimal Control outlines the interface for optimizing RF pulse trains for parameter estimation. More details about these topics can be found in the paper Rapid quantitative magnetization transfer imaging: utilizing the hybrid state and the generalized Bloch model.","category":"page"},{"location":"","page":"Home","title":"Home","text":"More details on the implementation are provided in the Section Generalized Bloch Paper, which reproduces all simulations, data analyses, and figures of the generalized Bloch paper:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages=[\n        \"build_literate/Greens_functions.md\",\n        \"build_literate/Simulation_ContinuousWave.md\",\n        \"build_literate/Simulation_Pulse.md\",\n        \"build_literate/Analyze_NMR_IR_Data.md\",\n        \"build_literate/Analyze_NMR_PreSat_Data.md\",\n        \"build_literate/Linear_Approximation.md\",\n]\nDepth = 2","category":"page"},{"location":"","page":"Home","title":"Home","text":"The documentation of all exported functions can be found in the API Section.","category":"page"}]
}
