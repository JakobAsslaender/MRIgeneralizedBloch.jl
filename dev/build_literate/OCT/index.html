<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Optimal Control · MRIgeneralizedBloch.jl</title><meta name="title" content="Optimal Control · MRIgeneralizedBloch.jl"/><meta property="og:title" content="Optimal Control · MRIgeneralizedBloch.jl"/><meta property="twitter:title" content="Optimal Control · MRIgeneralizedBloch.jl"/><meta name="description" content="Documentation for MRIgeneralizedBloch.jl."/><meta property="og:description" content="Documentation for MRIgeneralizedBloch.jl."/><meta property="twitter:description" content="Documentation for MRIgeneralizedBloch.jl."/><meta property="og:url" content="https://JakobAsslaender.github.io/MRIgeneralizedBloch.jl/build_literate/OCT/"/><meta property="twitter:url" content="https://JakobAsslaender.github.io/MRIgeneralizedBloch.jl/build_literate/OCT/"/><link rel="canonical" href="https://JakobAsslaender.github.io/MRIgeneralizedBloch.jl/build_literate/OCT/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MRIgeneralizedBloch.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../tutorial_singlepulse/">Simulation of a Single RF Pulse</a></li><li><a class="tocitem" href="../tutorial_pulsetrain/">Balanced Hybrid-State Free Precession Pulse Sequence</a></li><li><a class="tocitem" href="../NLLS/">Non-Linear Least Square Fitting</a></li><li class="is-active"><a class="tocitem" href>Optimal Control</a></li><li><span class="tocitem">Generalized Bloch Paper</span><ul><li><a class="tocitem" href="../Greens_functions/">Green&#39;s Functions</a></li><li><a class="tocitem" href="../Simulation_ContinuousWave/">Continuous Wave Simulation</a></li><li><a class="tocitem" href="../Simulation_Pulse/">RF-Pulse Simulation</a></li><li><a class="tocitem" href="../Analyze_NMR_IR_Data/">Inversion Recovery Experiments</a></li><li><a class="tocitem" href="../Analyze_NMR_PreSat_Data/">Continuous Wave Saturation Experiments</a></li><li><a class="tocitem" href="../Linear_Approximation/">Linear Approximation</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Optimal Control</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Optimal Control</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/master/docs/src/OCT.jl#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><p><a href="https://mybinder.org/v2/gh/JakobAsslaender/MRIgeneralizedBloch.jl/gh-pages?filepath=dev/build_literate/OCT.ipynb"><img src="https://mybinder.org/badge_logo.svg" alt/></a></p><h1 id="Optimal-Control"><a class="docs-heading-anchor" href="#Optimal-Control">Optimal Control</a><a id="Optimal-Control-1"></a><a class="docs-heading-anchor-permalink" href="#Optimal-Control" title="Permalink"></a></h1><p>This section provides a brief introduction to the package&#39;s interface for sequence optimization. We use the <a href="https://en.wikipedia.org/wiki/Cramér–Rao_bound">Cramer-Rao bound</a> (CRB) to assess a sequence&#39;s performance and optimize the amplitudes (<span>$ω_1$</span>) and durations (<span>$T_\text{RF}$</span>) of RF-pulses to reduce the CRB, assuming a <a href="../tutorial_pulsetrain/#Balanced-Hybrid-State-Free-Precession-Pulse-Sequence">Balanced Hybrid-State Free Precession Pulse Sequence</a>. For computational efficiency, the derivatives of the CRB wrt. <span>$ω_1$</span> and <span>$T_\text{RF}$</span> are calculated with the adjoint state method common in the <a href="https://www.sciencedirect.com/science/article/pii/S1090780703001538">optimal control literature</a>.</p><p>For this tutorial, we use the following packages:</p><pre><code class="language-julia hljs">using MRIgeneralizedBloch
using LinearAlgebra
BLAS.set_num_threads(1) # single threaded is faster in this case
using Optim             # provides the optimization algorithm
using Plots</code></pre><p>Here, we optimize the pulse sequence for a predefined set of parameters:</p><pre><code class="language-julia hljs">m0s = 0.15
R1f = 0.5   # 1/s
R2f = 15    # 1/s
Rx = 30     # 1/s
R1s = 3     # 1/s
T2s = 10e-6 # s
ω0 = 0      # rad/s
B1 = 1;     # in units of B1_nominal</code></pre><p>and we optimize</p><pre><code class="language-julia hljs">Npulses = 200;</code></pre><p>pulses, spaced</p><pre><code class="language-julia hljs">TR = 3.5e-3; # s</code></pre><p>apart. The cyle duration of</p><pre><code class="language-julia hljs">Npulses * TR</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.7000000000000001</code></pre><p>seconds is shorter than the optimal duration, which is in the range of 4-10s. We here use a small <code>Npulses</code> to speed up the computations. The <a href="../Linear_Approximation/#Linear-Approximation">Linear Approximation</a> of the generalized Bloch model is precomputed with</p><pre><code class="language-julia hljs">R2slT = precompute_R2sl();</code></pre><p>In the calculation of the CRB, we account for following gradients:</p><pre><code class="language-julia hljs">grad_list = [grad_m0s(), grad_R1f(), grad_R2f(), grad_Rx(), grad_R1s(), grad_T2s(), grad_ω0(), grad_B1()];</code></pre><p>and we sum up the CRB of all parameters, weighted by the following vector:</p><pre><code class="language-julia hljs">weights = transpose([0, 1, 0, 0, 0, 0, 0, 0, 0]);</code></pre><p>Note that the vector <code>weights</code> has one more entry compared to the <code>grad_list</code> vector, as the first derivative is always wrt. <span>$M_0$</span>, regardless of <code>grad_list</code>. Here, we only optimize for the CRB of <span>$m_0^s$</span>, while accounting for a fit of all 9 model parameters.</p><p>We take some initial guess for the pulse train:</p><pre><code class="language-julia hljs">α = abs.(sin.((1:Npulses) * 2π/Npulses));</code></pre><p>initialize with a constant <code>TRF = 300μs</code>:</p><pre><code class="language-julia hljs">TRF = 300e-6 .* one.(α);</code></pre><p>and define the first RF pulse as a 500μs inversion pulse by modifying vectors accordingly and by creating a bit vector that indicates the position of the inversion pulse:</p><pre><code class="language-julia hljs">α[1] = π
TRF[1] = 500e-6
isInversionPulse = [true; falses(length(α)-1)];</code></pre><p>We note that inversion pulses are not optimized by this toolbox. We calculate the initial <span>$ω_1$</span></p><pre><code class="language-julia hljs">ω1 = α ./ TRF;</code></pre><p>and plot the initial control:</p><pre><code class="language-julia hljs">p1 = plot(TR*(1:Npulses), α ./ π, ylabel=&quot;α/π&quot;)
p2 = plot(TR*(1:Npulses), 1e6TRF, ylim=(0, 1e3), xlabel=&quot;t (s)&quot;, ylabel=&quot;TRF (μs)&quot;)
p = plot(p1, p2, layout=(2, 1), legend=:none)</code></pre><object type="text/html" data="../../plots/762339618.html" style="width:100%;height:425px;"></object><p>With above defined weights, the function <a href="../../api/#MRIgeneralizedBloch.CRB_gradient_OCT-NTuple{14, Any}"><code>MRIgeneralizedBloch.CRB_gradient_OCT</code></a> returns the CRB</p><pre><code class="language-julia hljs">(CRBm0s, grad_ω1, grad_TRF) = MRIgeneralizedBloch.CRB_gradient_OCT(ω1, TRF, TR, ω0, B1, m0s, R1f, R2f, Rx, R1s, T2s, R2slT, grad_list, weights, isInversionPulse=isInversionPulse)
CRBm0s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6341.95059806531</code></pre><p>along with the gradients:</p><pre><code class="language-julia hljs">p1 = plot(TR*(1:Npulses), grad_ω1  .* ((-1) .^ (1:Npulses)), ylabel=&quot;∂CRB(m0s) / ∂ω1 (s/rad)&quot;)
p2 = plot(TR*(1:Npulses), grad_TRF .* ((-1) .^ (1:Npulses)), ylabel=&quot;∂CRB(m0s) / ∂TRF (1/s)&quot;, xlabel=&quot;t (s)&quot;)
p = plot(p1, p2, layout=(2, 1), legend=:none)</code></pre><object type="text/html" data="../../plots/886547897.html" style="width:100%;height:425px;"></object><p>Note that we remove the oscillating nature of the gradient for the display.</p><p>In this example, we limit the control to the following bounds</p><pre><code class="language-julia hljs">ω1_min  = 0      # rad/s
ω1_max  = 2e3π   # rad/s
TRF_min = 100e-6 # s
TRF_max = 500e-6; # s</code></pre><p>and the function <a href="../../api/#MRIgeneralizedBloch.bound_ω1_TRF!-Tuple{Any, Any}"><code>MRIgeneralizedBloch.bound_ω1_TRF!</code></a> modifies <code>ω1</code> and <code>TRF</code> to comply with these bounds and returns a single vector in the range <code>[-Inf, Inf]</code> that relates to the bounded control by a <code>tanh</code> transformation:</p><pre><code class="language-julia hljs">x0 = MRIgeneralizedBloch.bound_ω1_TRF!(ω1, TRF; ω1_min = ω1_min, ω1_max = ω1_max, TRF_min = TRF_min, TRF_max = TRF_max)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">400-element Vector{Float64}:
 Inf
 -1.683988287115545
 -1.4729988693565415
 -1.3209392186669002
 -1.2011921567736858
 -1.1019049796994895
 -1.0167581958717071
 -0.9419826140711725
 -0.8751499388454517
 -0.814605017748036
  ⋮
 -1.1102230246251565e-16
 -1.1102230246251565e-16
 -1.1102230246251565e-16
 -1.1102230246251565e-16
 -1.1102230246251565e-16
 -1.1102230246251565e-16
 -1.1102230246251565e-16
 -1.1102230246251565e-16
 -1.1102230246251565e-16</code></pre><p>Further, we initialize a gradient of the same length:</p><pre><code class="language-julia hljs">G = similar(x0);</code></pre><p>and define the cost function:</p><pre><code class="language-julia hljs">function fg!(F, G, x)
    ω1, TRF = MRIgeneralizedBloch.get_bounded_ω1_TRF(x; ω1_min = ω1_min, ω1_max = ω1_max, TRF_min = TRF_min, TRF_max = TRF_max)

    (F, grad_ω1, grad_TRF) = MRIgeneralizedBloch.CRB_gradient_OCT(ω1, TRF, TR, ω0, B1, m0s, R1f, R2f, Rx, R1s, T2s, R2slT, grad_list, weights, isInversionPulse=isInversionPulse)
    F = abs(F)

    F += MRIgeneralizedBloch.second_order_α!(grad_ω1, grad_TRF, ω1, TRF; idx = .!isInversionPulse, λ=1e4)
    F += MRIgeneralizedBloch.RF_power!(grad_ω1, grad_TRF, ω1, TRF; idx = .!isInversionPulse, λ=1e-3, Pmax=3e6, TR=TR)
    F += MRIgeneralizedBloch.TRF_TV!(grad_TRF, ω1, TRF; idx = .!isInversionPulse, λ=1e3)

    MRIgeneralizedBloch.apply_bounds_to_grad!(G, x, grad_ω1, grad_TRF; ω1_min = ω1_min, ω1_max = ω1_max, TRF_min = TRF_min, TRF_max = TRF_max)
    return F
end;</code></pre><p>We perform the optimization with the package <a href="https://julianlsolvers.github.io/Optim.jl/stable/">Optim.jl</a>, which requires the cost function <code>fg!(F, G, x)</code> to take the cost, the gradient, and the control as input variables and to over-write the gradient in place. The cost function calculates the gradient of the CRB with above described optimal control code and we, further, add some regularization terms: <a href="../../api/#MRIgeneralizedBloch.second_order_α!-NTuple{4, Any}"><code>MRIgeneralizedBloch.second_order_α!</code></a> penalizes the curvature of α, which smoothes the flip angle train and helps ensuring the <a href="https://www.nature.com/articles/s42005-019-0174-0">hybrid state conditions</a>. The penalty <a href="../../api/#MRIgeneralizedBloch.RF_power!-NTuple{4, Any}"><code>MRIgeneralizedBloch.RF_power!</code></a> penalizes the power deposition of the RF-pulse train if <span>$\Sigma_i(ω_1^2[i] ⋅ T_{\text{RF}}[i]) / T_{\text{cycle}} ≥ P_{\max}$</span> and helps with compliance to safety limits. Assuming a reasonable <code>λ</code>, the optimization will converge to an average RF-power deposition equal to or less than <code>Pmax</code> in units of (rad/s)². Heuristically, the value <code>Pmax=3e6</code> (rad/s)² proofed to be a reasonable choice for 3T systems. The penalty <a href="../../api/#MRIgeneralizedBloch.TRF_TV!-Tuple{Any, Any, Any}"><code>MRIgeneralizedBloch.TRF_TV!</code></a> penalizes fast fluctuations of <span>$T_\text{RF}$</span>. This penalty is justified by the knowledge that fluctuations of the control have negligible effect if they are fast compared to the biophysical time constants. We note, however, that this penalty is not required and rather ensure <em>beauty</em> of the result and speeds up convergence.</p><p>With all this in place, we can start the actual optimization</p><pre><code class="language-julia hljs">result = optimize(Optim.only_fg!(fg!), # cost function
    x0,                                # initialization
    BFGS(),                            # algorithm
    Optim.Options(
        iterations=10_000,             # larger number as we use a time limit
        time_limit=(15*60)             # in seconds
        )
    )</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"> * Status: success (objective increased between iterations)

 * Candidate solution
    Final objective value:     9.181392e+01

 * Found with
    Algorithm:     BFGS

 * Convergence measures
    |x - x&#39;|               = 7.39e+03 ≰ 0.0e+00
    |x - x&#39;|/|x&#39;|          = 0.00e+00 ≤ 0.0e+00
    |f(x) - f(x&#39;)|         = 2.45e-11 ≰ 0.0e+00
    |f(x) - f(x&#39;)|/|f(x&#39;)| = 2.67e-13 ≰ 0.0e+00
    |g(x)|                 = 7.41e-09 ≤ 1.0e-08

 * Work counters
    Seconds run:   794  (vs limit 900)
    Iterations:    2242
    f(x) calls:    6152
    ∇f(x) calls:   6152
</code></pre><p>After transforming the optimized control back into the space of bounded <span>$ω_1$</span> and <span>$T_\text{RF}$</span> values</p><pre><code class="language-julia hljs">ω1, TRF = MRIgeneralizedBloch.get_bounded_ω1_TRF(result.minimizer; ω1_min = ω1_min, ω1_max = ω1_max, TRF_min = TRF_min, TRF_max = TRF_max)
α = ω1 .* TRF;</code></pre><p>we analyze the CRB(m0s):</p><pre><code class="language-julia hljs">(CRBm0s, grad_ω1, grad_TRF) = MRIgeneralizedBloch.CRB_gradient_OCT(ω1, TRF, TR, ω0, B1, m0s, R1f, R2f, Rx, R1s, T2s, R2slT, grad_list, weights, isInversionPulse=isInversionPulse)
CRBm0s</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">67.51418488495337</code></pre><p>and observe a substantial reduction. Further, we plot the optimized control:</p><pre><code class="language-julia hljs">p1 = plot(TR*(1:Npulses), α ./ π, ylabel=&quot;α/π&quot;)
p2 = plot(TR*(1:Npulses), 1e6TRF, ylim=(0, 1e3), xlabel=&quot;t (s)&quot;, ylabel=&quot;TRF (μs)&quot;)
p = plot(p1, p2, layout=(2, 1), legend=:none)</code></pre><object type="text/html" data="../../plots/600424374.html" style="width:100%;height:425px;"></object><p>To further analyze the results, we can calculate and plot all magnetization components:</p><pre><code class="language-julia hljs">m = calculatesignal_linearapprox(α, TRF, TR, ω0, B1, m0s, R1f, R2f, Rx, R1s, T2s, R2slT; output=:realmagnetization)
m = vec(m)

xf = [m[i][1] for i=1:length(m)]
yf = [m[i][2] for i=1:length(m)]
zf = [m[i][3] for i=1:length(m)]
xs = [m[i][4] for i=1:length(m)]
zs = [m[i][5] for i=1:length(m)]

p = plot(xlabel=&quot;t (s)&quot;, ylabel=&quot;m (normalized)&quot;)
plot!(p, TR*(1:Npulses), xf ./(1-m0s), label=&quot;xᶠ&quot;)
plot!(p, TR*(1:Npulses), yf ./(1-m0s), label=&quot;yᶠ&quot;)
plot!(p, TR*(1:Npulses), zf ./(1-m0s), label=&quot;zᶠ&quot;)
plot!(p, TR*(1:Npulses), xs ./   m0s , label=&quot;xˢ&quot;)
plot!(p, TR*(1:Npulses), zs ./   m0s , label=&quot;zˢ&quot;)</code></pre><object type="text/html" data="../../plots/38933208.html" style="width:100%;height:425px;"></object><p>And we can also plot the dynamics of the free spin pool on the Bloch sphere:</p><pre><code class="language-julia hljs">p = plot(xf, zf, xlabel=&quot;xf&quot;, ylabel=&quot;zf&quot;, framestyle = :zerolines, legend=:none)</code></pre><object type="text/html" data="../../plots/1602005.html" style="width:100%;height:425px;"></object><p>As yᶠ is close to zero in this particular case, we neglect it in this 2D plot.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../NLLS/">« Non-Linear Least Square Fitting</a><a class="docs-footer-nextpage" href="../Greens_functions/">Green&#39;s Functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Saturday 25 November 2023 01:44">Saturday 25 November 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
