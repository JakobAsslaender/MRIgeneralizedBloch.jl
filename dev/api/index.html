<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · MRIgeneralizedBloch.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://JakobAsslaender.github.io/MRIgeneralizedBloch.jl/api/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MRIgeneralizedBloch.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../build_literate/tutorial/">Quick Start Tutorial</a></li><li><span class="tocitem">Generalized Bloch Paper</span><ul><li><a class="tocitem" href="../build_literate/Greens_functions/">Green&#39;s Functions</a></li><li><a class="tocitem" href="../build_literate/Simulation_ContinuousWave/">Continuous Wave Simulation</a></li><li><a class="tocitem" href="../build_literate/Simulation_Pulse/">RF-Pulse Simulation</a></li><li><a class="tocitem" href="../build_literate/Analyze_NMR_IR_Data/">Inversion Recovery Experiments</a></li><li><a class="tocitem" href="../build_literate/Analyze_NMR_PreSat_Data/">Continuous Wave Saturation Experiments</a></li><li><a class="tocitem" href="../build_literate/Linear_Approximation/">Linear Approximation</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/master/docs/src/api.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><p>In the following, you find the documentation of all exported functions of the <a href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl">MRIgeneralizedBloch.jl</a> package:</p><ul><li><a href="#MRIgeneralizedBloch.apply_hamiltonian_gbloch!-Tuple{Any, Any, Any, NTuple{11, Any}, Any}"><code>MRIgeneralizedBloch.apply_hamiltonian_gbloch!</code></a></li><li><a href="#MRIgeneralizedBloch.apply_hamiltonian_sled!-Tuple{Any, Any, NTuple{6, Any}, Any}"><code>MRIgeneralizedBloch.apply_hamiltonian_sled!</code></a></li><li><a href="#MRIgeneralizedBloch.calculatesignal_gbloch_ide-NTuple{11, Any}"><code>MRIgeneralizedBloch.calculatesignal_gbloch_ide</code></a></li><li><a href="#MRIgeneralizedBloch.calculatesignal_graham_ode-NTuple{11, Any}"><code>MRIgeneralizedBloch.calculatesignal_graham_ode</code></a></li><li><a href="#MRIgeneralizedBloch.calculatesignal_linearapprox-NTuple{12, Any}"><code>MRIgeneralizedBloch.calculatesignal_linearapprox</code></a></li><li><a href="#MRIgeneralizedBloch.dG_o_dT2s_x_T2s_gaussian-Tuple{Any}"><code>MRIgeneralizedBloch.dG_o_dT2s_x_T2s_gaussian</code></a></li><li><a href="#MRIgeneralizedBloch.dG_o_dT2s_x_T2s_lorentzian-Tuple{Any}"><code>MRIgeneralizedBloch.dG_o_dT2s_x_T2s_lorentzian</code></a></li><li><a href="#MRIgeneralizedBloch.dG_o_dT2s_x_T2s_superlorentzian-Tuple{Any}"><code>MRIgeneralizedBloch.dG_o_dT2s_x_T2s_superlorentzian</code></a></li><li><a href="#MRIgeneralizedBloch.greens_gaussian-Tuple{Any}"><code>MRIgeneralizedBloch.greens_gaussian</code></a></li><li><a href="#MRIgeneralizedBloch.greens_lorentzian-Tuple{Any}"><code>MRIgeneralizedBloch.greens_lorentzian</code></a></li><li><a href="#MRIgeneralizedBloch.greens_superlorentzian-Tuple{Any}"><code>MRIgeneralizedBloch.greens_superlorentzian</code></a></li><li><a href="#MRIgeneralizedBloch.hamiltonian_linear-NTuple{10, Any}"><code>MRIgeneralizedBloch.hamiltonian_linear</code></a></li><li><a href="#MRIgeneralizedBloch.interpolate_greens_function-Tuple{Any, Any, Any}"><code>MRIgeneralizedBloch.interpolate_greens_function</code></a></li><li><a href="#MRIgeneralizedBloch.precompute_R2sl-Tuple{}"><code>MRIgeneralizedBloch.precompute_R2sl</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="MRIgeneralizedBloch.apply_hamiltonian_gbloch!-Tuple{Any, Any, Any, NTuple{11, Any}, Any}" href="#MRIgeneralizedBloch.apply_hamiltonian_gbloch!-Tuple{Any, Any, Any, NTuple{11, Any}, Any}"><code>MRIgeneralizedBloch.apply_hamiltonian_gbloch!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply_hamiltonian_gbloch!(∂m∂t, m, mfun, p, t)</code></pre><p>Apply the generalized Bloch Hamiltonian to <code>m</code> and write the resulting derivative wrt. time into <code>∂m∂t</code>.</p><p><strong>Arguments</strong></p><ul><li><code>∂m∂t::Vector{&lt;:Number}</code>: Vector describing to derivative of <code>m</code> wrt. time; this vector has to be of the same size as <code>m</code>, but can contain any value, which is replaced by <code>H * m</code></li><li><code>m::Vector{&lt;:Number}</code>: Vector the spin ensemble state of the form <code>[xf, yf, zf, zs, 1]</code> if now gradient is calculated or of the form <code>[xf, yf, zf, zs, 1, ∂xf/∂θ1, ∂yf/∂θ1, ∂zf/∂θ1, ∂zs/∂θ1, 0, ..., ∂xf/∂θn, ∂yf/∂θn, ∂zf/∂θn, ∂zs/∂θn, 0]</code> if n derivatives wrt. <code>θn</code> are calculated</li><li><code>mfun</code>: History fuction; can be initialized with <code>mfun(p, t; idxs=nothing) = typeof(idxs) &lt;: Number ? 0.0 : zeros(5n + 5)</code> for n gradients, and is then updated by the delay differential equation solvers</li><li><code>p::NTuple{9,10, or 11, Any}</code>: <code>(ω1, B1, ω0, m0s, R1f, R2f, Rx, R1s, T2s, g)</code>, with    -<code>ω1::Number</code>: Rabi frequency in rad/s (rotation about the y-axis)   -<code>B1::Number</code>: B1 scaling normalized so that <code>B1=1</code> corresponds to a perfectly calibrated RF field   -<code>ω0::Number</code>: Larmor or off-resonance frequency in rad/s   -<code>m0s::Number</code>: Fractional semi-solid spin pool size in the range of 0 to 1   -<code>R1f::Number</code>: Longitudinal spin relaxation rate of the free pool in 1/seconds   -<code>R2f::Number</code>: Trasversal spin relaxation rate of the free pool in 1/seconds   -<code>Rx::Number</code>: Exchange rate between the two pools in 1/seconds   -<code>R1s::Number</code>: Longitudinal spin relaxation rate of the semi-solid pool in 1/seconds   -<code>T2s::Number</code>: Trasversal spin relaxation time of the semi-solid pool in seconds   -<code>g::Function</code>: Green&#39;s function of the form <code>G(κ) = G((t-τ)/T2s)</code>   or <code>(ω1, B1, ω0, m0s, R1f, R2f, Rx, R1s, T2s, zs_idx, g)</code> with<ul><li><code>zs_idx::Integer</code>: Index to be used history function to be used in the Green&#39;s function; Default is 4 (zs), and for derivatives 9, 14, ... are used</li></ul>or <code>(ω1, B1, ω0, m0s, R1f, R2f, Rx, R1s, T2s, g, dG_o_dT2s_x_T2s, grad_list)</code> with<ul><li><code>dG_o_dT2s_x_T2s::Function</code>: Derivative of the Green&#39;s function wrt. T2s, multiplied by T2s; of the form <code>dG_o_dT2s_x_T2s(κ) = dG_o_dT2s_x_T2s((t-τ)/T2s)</code></li><li><code>grad_list::Vector{&lt;:grad_param}</code>: List of gradients to be calucualted; any subset of <code>[grad_m0s(), grad_R1f(), grad_R2f(), grad_Rx(), grad_R1s(), grad_T2s(), grad_ω0(), grad_B1()]</code>; length of the vector must be n (cf. arguments <code>m</code> and <code>∂m∂t</code>); ; the derivative wrt. to apparent <code>R1a = R1f = R1s</code> can be calculated with <code>grad_R1a()</code></li></ul></li><li><code>t::Number</code>: Time in seconds</li></ul><p>Optional:</p><ul><li><code>pulsetype=:normal</code>: Use default for a regular RF-pulse; the option <code>pulsetype=:inversion</code> should be handled with care as it is only inteded to calculate the saturation of the semi-solid pool and its derivative. </li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DifferentialEquations

julia&gt; α = π/2;

julia&gt; TRF = 100e-6;

julia&gt; ω1 = α/TRF;

julia&gt; B1 = 1;

julia&gt; ω0 = 0;

julia&gt; m0s = 0.2;

julia&gt; R1f = 1/3;

julia&gt; R2f = 15;

julia&gt; R1s = 2;

julia&gt; T2s = 10e-6;

julia&gt; Rx = 30;

julia&gt; G = interpolate_greens_function(greens_superlorentzian, 0, TRF / T2s);


julia&gt; m0 = [0; 0; 1-m0s; m0s; 1];

julia&gt; mfun(p, t; idxs=nothing) = typeof(idxs) &lt;: Number ? 0.0 : zeros(5);

julia&gt; sol = solve(DDEProblem(apply_hamiltonian_gbloch!, m0, mfun, (0, TRF), (ω1, B1, ω0, m0s, R1f, R2f, Rx, R1s, T2s, G)))
retcode: Success
Interpolation: specialized 4th order &quot;free&quot; interpolation, specialized 2nd order &quot;free&quot; stiffness-aware interpolation
t: 9-element Vector{Float64}:
 0.0
 1.375006182301112e-7
 1.512506800531223e-6
 8.04255964308422e-6
 2.1078484518172075e-5
 3.9114139737297395e-5
 6.268790292353144e-5
 9.147705095836351e-5
 0.0001
u: 9-element Vector{Vector{Float64}}:
 [0.0, 0.0, 0.8, 0.2, 1.0]
 [0.001727880603076341, 0.0, 0.7999981340131751, 0.19999953350448, 1.0]
 [0.019004717382235078, 0.0, 0.7997742277135814, 0.19994357804868362, 1.0]
 [0.10079108788864381, 0.0, 0.7936248155456308, 0.19842287319977142, 1.0]
 [0.26002573409211854, 0.0, 0.7565529847116781, 0.18981913439205117, 1.0]
 [0.4610419429673234, 0.0, 0.6537242534410707, 0.16937688960872904, 1.0]
 [0.666173809234659, 0.0, 0.44261243675880635, 0.13589316093594178, 1.0]
 [0.7923116716967052, 0.0, 0.10713152453821989, 0.09390269485075242, 1.0]
 [0.7994211188440913, 0.0, 0.0004403374356386769, 0.0821480968384837, 1.0]

julia&gt; using Plots

julia&gt; plot(sol, labels=[&quot;xf&quot; &quot;yf&quot; &quot;zf&quot; &quot;zs&quot; &quot;1&quot;], xlabel=&quot;t (s)&quot;, ylabel=&quot;m(t)&quot;);



julia&gt; dG_o_dT2s_x_T2s = interpolate_greens_function(dG_o_dT2s_x_T2s_superlorentzian, 0, TRF / T2s);


julia&gt; grad_list = [grad_R2f(), grad_m0s()];


julia&gt; m0 = [0; 0; 1-m0s; m0s; 1; zeros(5*length(grad_list))];


julia&gt; mfun(p, t; idxs=nothing) = typeof(idxs) &lt;: Number ? 0.0 : zeros(5 + 5*length(grad_list));

julia&gt; sol = solve(DDEProblem(apply_hamiltonian_gbloch!, m0, mfun, (0, TRF), (ω1, B1, ω0, m0s, R1f, R2f, Rx, R1s, T2s, G, dG_o_dT2s_x_T2s, grad_list)));



julia&gt; plot(sol);
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/c67164ba9da82ed84df336d57d99ccf925ba4de9/src/DiffEq_Hamiltonians.jl#L5-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIgeneralizedBloch.apply_hamiltonian_sled!-Tuple{Any, Any, NTuple{6, Any}, Any}" href="#MRIgeneralizedBloch.apply_hamiltonian_sled!-Tuple{Any, Any, NTuple{6, Any}, Any}"><code>MRIgeneralizedBloch.apply_hamiltonian_sled!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply_hamiltonian_sled!(∂m∂t, m, p, t)</code></pre><p>Apply Sled&#39;s Hamiltonian to <code>m</code> and write the resulting derivative wrt. time into <code>∂m∂t</code>.</p><p><strong>Arguments</strong></p><ul><li><code>∂m∂t::Vector{&lt;:Number}</code>: Vector of length 1 describing to derivative of <code>m</code> wrt. time; this vector can contain any value, which is replaced by <code>H * m</code></li><li><code>m::Vector{&lt;:Number}</code>: Vector of length 1 describing the <code>zs</code> magnetization</li><li><code>p::NTuple{6 or 10, Any}</code>: <code>(ω1, B1, ω0, R1s, T2s, g)</code> for a simulating an isolated semi-solid pool or <code>(ω1, B1, ω0, m0s, R1f, R2f, Rx, R1s, T2s, g)</code> for simulating a coupled spin system; with    -<code>ω1::Number</code>: Rabi frequency in rad/s (rotation about the y-axis)   -<code>B1::Number</code>: B1 scaling normalized so that <code>B1=1</code> corresponds to a perfectly calibrated RF field   -<code>ω0::Number</code>: Larmor or off-resonance frequency in rad/s   -<code>R1f::Number</code>: Longitudinal spin relaxation rate of the free pool in 1/seconds   -<code>R2f::Number</code>: Trasversal spin relaxation rate of the free pool in 1/seconds   -<code>R1s::Number</code>: Longitudinal spin relaxation rate of the semi-solid in 1/seconds   -<code>Rx::Number</code>: Exchange rate between the two pools in 1/seconds   -<code>T2s::Number</code>: Trasversal spin relaxation time in seconds   -<code>g::Function</code>: Green&#39;s function of the form <code>G(κ) = G((t-τ)/T2s)</code></li><li><code>t::Number</code>: Time in seconds</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DifferentialEquations

julia&gt; α = π/2;

julia&gt; TRF = 100e-6;

julia&gt; ω1 = α/TRF;

julia&gt; B1 = 1;

julia&gt; ω0 = 0;

julia&gt; R1s = 2;

julia&gt; T2s = 10e-6;

julia&gt; G = interpolate_greens_function(greens_superlorentzian, 0, TRF / T2s);

julia&gt; m0 = [1];

julia&gt; sol = solve(ODEProblem(apply_hamiltonian_sled!, m0, (0, TRF), (ω1, 1, ω0, R1s, T2s, G)), Tsit5())
retcode: Success
Interpolation: specialized 4th order &quot;free&quot; interpolation
t: 3-element Vector{Float64}:
 0.0
 7.475414666720001e-5
 0.0001
u: 3-element Vector{Vector{Float64}}:
 [1.0]
 [0.6313928231811974]
 [0.48953654496619214]

julia&gt; using Plots

julia&gt; plot(sol, labels=[&quot;zs&quot;], xlabel=&quot;t (s)&quot;, ylabel=&quot;m(t)&quot;);

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/c67164ba9da82ed84df336d57d99ccf925ba4de9/src/DiffEq_Hamiltonians.jl#L477-L537">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIgeneralizedBloch.calculatesignal_gbloch_ide-NTuple{11, Any}" href="#MRIgeneralizedBloch.calculatesignal_gbloch_ide-NTuple{11, Any}"><code>MRIgeneralizedBloch.calculatesignal_gbloch_ide</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculatesignal_gbloch_ide(α, TRF, TR, ω0, B1, m0s, R1f, R2f, Rx, R1s, T2s[; grad_list, Ncyc=2, output=:complexsignal])</code></pre><p>Calculate the signal or magnetixation evolution with the full generalized Bloch model assuming a super-Lorentzian lineshape (slow).</p><p>The simulation assumes a sequence of rectangluar RF-pulses with varying flip angles α and RF-pulse durations TRF, but a fixed repetition time TR. Further, it assumes balanced gradient moments. </p><p><strong>Arguments</strong></p><ul><li><code>α::Vector{&lt;:Number}</code>: Array of flip angles in radians</li><li><code>TRF::Vector{&lt;:Number}</code>: Array of the RF-pulse durations in seconds</li><li><code>TR::Number</code>: Repetition time in seconds</li><li><code>ω0::Number</code>: Off-resonance frequency in rad/s </li><li><code>B1::Number</code>: Normalized transmit B1 field, i.e. B1 = 1 corresponds to a well-calibrated B1 field</li><li><code>m0s::Number</code>: Fractional size of the semi-solid pool; should be in range of 0 to 1</li><li><code>R1f::Number</code>: Longitudinal relaxation rate of the free pool in 1/seconds</li><li><code>R2f::Number</code>: Transversal relaxation rate of the free pool in 1/seconds</li><li><code>Rx::Number</code>: Exchange rate between the two spin pools in 1/seconds</li><li><code>R1s::Number</code>: Longitudinal relaxation rate of the semi-solid pool in 1/seconds</li><li><code>T2s::Number</code>: Transversal relaxationt time of the semi-solid pool in seconds</li></ul><p>Optional:</p><ul><li><code>grad_list=[]</code>: Vector to indicate which gradients should be calculated; the vector can either be empty <code>[]</code> for no gradient, or contain any subset/order of <code>grad_list=[grad_m0s(), grad_R1s(), grad_R2f(), grad_Rx(), grad_R1s(), grad_T2s(), grad_ω0(), grad_B1()]</code>; the derivative wrt. to apparent <code>R1a = R1f = R1s</code> can be calculated with <code>grad_R1a()</code></li><li><code>Ncyc=2</code>: The magnetization is initialized with thermal equilibrium and then performed Ncyc times and only the last cycle is stored. The default value is usually a good approximation for antiperiodic boundary conditions. Increase the number for higher precision at the cost of computation time. </li><li><code>output=:complexsignal</code>: The defaul keywords triggers the function to output a complex-valued signal (<code>xf + 1im yf</code>); the keyword <code>output=:realmagnetization</code> triggers an output of the entire (real valued) vector <code>[xf, yf, zf, xs, zs]</code></li><li><code>greens=(greens_superlorentzian, dG_o_dT2s_x_T2s_superlorentzian)</code>: Tuple of a Greens function <code>G(κ) = G((t-τ)/T2s)</code> and its partial derivative wrt. T2s, multiplied by T2s <code>∂G((t-τ)/T2s)/∂T2s * T2s</code>. This package supplies the three Greens functions <code>greens=(greens_superlorentzian, dG_o_dT2s_x_T2s_superlorentzian)</code> (default), <code>greens=(greens_lorentzian, dG_o_dT2s_x_T2s_lorentzian)</code>, and <code>greens=(greens_gaussian, dG_o_dT2s_x_T2s_gaussian)</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; calculatesignal_gbloch_ide(ones(100)*π/2, ones(100)*5e-4, 4e-3, 0, 1, 0.2, 0.3, 15, 20, 2, 10e-6)
100×1 Matrix{ComplexF64}:
   -0.00796631644501679 + 0.0im
  0.0012590590419314775 - 0.0im
  -0.006088855588122639 + 0.0im
  0.0024187389404174958 - 0.0im
  -0.004361339395232399 + 0.0im
   0.003489135821004988 - 0.0im
 -0.0027633710614651317 + 0.0im
   0.004483217941394422 - 0.0im
 -0.0012812573517352534 + 0.0im
    0.00540885403467719 - 0.0im
                        ⋮
   0.017760808273049045 - 0.0im
   0.017576118974646872 + 0.0im
   0.017813950945910605 - 0.0im
    0.01764385633550697 + 0.0im
   0.017863575855931853 - 0.0im
    0.01770692603385291 + 0.0im
   0.017909914934082043 - 0.0im
    0.01776565037329648 + 0.0im
   0.017953184893717555 - 0.0im

julia&gt; calculatesignal_gbloch_ide(ones(100)*π/2, ones(100)*5e-4, 4e-3, 0, 1, 0.2, 0.3, 15, 20, 2, 10e-6; grad_list=[grad_R1f(), grad_T2s()], output=:realmagnetization)
100×15 transpose(::Matrix{Float64}) with eltype Float64:
 -0.00796627   0.0   0.000637773  …   0.0   -10.8757  -335.26   0.0
  0.00125903  -0.0  -0.00700671      -0.0   125.882   -326.977  0.0
 -0.00608882   0.0   0.00185086       0.0   -30.4187  -317.56   0.0
  0.00241873  -0.0  -0.00520622      -0.0    96.1776  -309.906  0.0
 -0.00436133   0.0   0.00296471       0.0   -47.5803  -302.948  0.0
  0.003489    -0.0  -0.00354518   …  -0.0    69.5148  -298.697  0.0
 -0.00276366   0.0   0.00399588       0.0   -62.8453  -294.886  0.0
  0.00448273  -0.0  -0.00200673      -0.0    45.3179  -292.783  0.0
 -0.00128187   0.0   0.00495478       0.0   -76.6573  -290.321  0.0
  0.00540814  -0.0  -0.000578836     -0.0    23.1756  -289.245  0.0
  ⋮                               ⋱
  0.0177563   -0.0   0.0175372       -0.0  -290.779   -349.855  0.0
  0.0175716    0.0   0.0177845        0.0  -295.347   -350.002  0.0
  0.0178094   -0.0   0.0176073       -0.0  -292.44    -350.163  0.0
  0.0176393    0.0   0.0178359        0.0  -296.668   -350.3    0.0
  0.017859    -0.0   0.0176727    …  -0.0  -294.001   -350.451  0.0
  0.0177024    0.0   0.0178838        0.0  -297.914   -350.579  0.0
  0.0179053   -0.0   0.0177335       -0.0  -295.467   -350.72   0.0
  0.0177611    0.0   0.0179286        0.0  -299.09    -350.84   0.0
  0.0179486   -0.0   0.0177902       -0.0  -296.845   -350.972  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/c67164ba9da82ed84df336d57d99ccf925ba4de9/src/DiffEq_Sovlers.jl#L1-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIgeneralizedBloch.calculatesignal_graham_ode-NTuple{11, Any}" href="#MRIgeneralizedBloch.calculatesignal_graham_ode-NTuple{11, Any}"><code>MRIgeneralizedBloch.calculatesignal_graham_ode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculatesignal_graham_ode(α, TRF, TR, ω0, B1, m0s, R1f, R2f, Rx, R1s, T2s[; grad_list, Ncyc=2, output=:complexsignal])</code></pre><p>Calculate the signal or magnetixation evolution with Graham&#39;s spectral model assuming a super-Lorentzian lineshape.</p><p>The simulation assumes a sequence of rectangluar RF-pulses with varying flip angles α and RF-pulse durations TRF, but a fixed repetition time TR. Further, it assumes balanced gradient moments. </p><p><strong>Arguments</strong></p><ul><li><code>α::Vector{&lt;:Number}</code>: Array of flip angles in radians</li><li><code>TRF::Vector{&lt;:Number}</code>: Array of the RF-pulse durations in seconds</li><li><code>TR::Number</code>: Repetition time in seconds</li><li><code>ω0::Number</code>: Off-resonance frequency in rad/s </li><li><code>B1::Number</code>: Normalized transmit B1 field, i.e. B1 = 1 corresponds to a well-calibrated B1 field</li><li><code>m0s::Number</code>: Fractional size of the semi-solid pool; should be in range of 0 to 1</li><li><code>R1f::Number</code>: Longitudinal relaxation rate of the free pool in 1/seconds</li><li><code>R2f::Number</code>: Transversal relaxation rate of the free pool in 1/seconds</li><li><code>Rx::Number</code>: Exchange rate between the two spin pools in 1/seconds</li><li><code>R1s::Number</code>: Longitudinal relaxation rate of the semi-solid pool in 1/seconds</li><li><code>T2s::Number</code>: Transversal relaxationt time of the semi-solid pool in seconds</li></ul><p>Optional:</p><ul><li><code>grad_list=[]</code>: Vector to indicate which gradients should be calculated; the vector can either be empty <code>[]</code> for no gradient, or contain any subset/order of <code>grad_list=[grad_m0s(), grad_R1f(), grad_R2f(), grad_Rx(), grad_R1s(), grad_T2s(), grad_ω0(), grad_B1(), grad_R1a()]</code></li><li><code>Ncyc=2</code>: The magnetization is initialized with thermal equilibrium and then performed Ncyc times and only the last cycle is stored. The default value is usually a good approximation for antiperiodic boundary conditions. Increase the number for higher precision at the cost of computation time. </li><li><code>output=:complexsignal</code>: The defaul keywords triggers the function to output a complex-valued signal (<code>xf + 1im yf</code>); the keyword <code>output=:realmagnetization</code> triggers an output of the entire (real valued) vector <code>[xf, yf, zf, xs, zs]</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; calculatesignal_graham_ode(ones(100)*π/2, ones(100)*5e-4, 4e-3, 0, 1, 0.2, 0.3, 15, 20, 2, 10e-6)
100×1 Matrix{ComplexF64}:
  -0.00807345119202598 + 0.0im
 0.0012686432904785246 - 0.0im
 -0.006178694437440372 + 0.0im
  0.002435865817868477 - 0.0im
 -0.004437476277388273 + 0.0im
  0.003516464650880384 - 0.0im
 -0.002831554256573095 + 0.0im
  0.004523902251349811 - 0.0im
 -0.001342229952563084 + 0.0im
  0.005454562035727423 - 0.0im
                       ⋮
  0.018148222055411015 - 0.0im
  0.017957696642062964 + 0.0im
  0.018204860894110032 - 0.0im
  0.018029363128597056 + 0.0im
  0.018257820158882408 - 0.0im
   0.01809616895266688 + 0.0im
  0.018307337749218777 - 0.0im
   0.01815844455461564 + 0.0im
  0.018353636251669653 - 0.0im

julia&gt; calculatesignal_graham_ode(ones(100)*π/2, ones(100)*5e-4, 4e-3, 0, 1, 0.2, 0.3, 15, 20, 2, 10e-6; grad_list=[grad_R1f(), grad_T2s()], output=:realmagnetization)
100×15 transpose(::Matrix{Float64}) with eltype Float64:
 -0.0080756    0.0   0.000643162  …   0.0   -10.4986  -323.634  0.0
  0.00126867  -0.0  -0.00710692      -0.0   123.078   -316.358  0.0
 -0.00618067   0.0   0.00186482       0.0   -29.4458  -307.862  0.0
  0.00243634  -0.0  -0.0052899       -0.0    94.1692  -300.821  0.0
 -0.00443746   0.0   0.00298646       0.0   -46.1422  -294.116  0.0
  0.00351386  -0.0  -0.00361718   …  -0.0    68.262   -289.421  0.0
 -0.00282882   0.0   0.00402793       0.0   -61.0236  -285.242  0.0
  0.00451808  -0.0  -0.00206741      -0.0    44.7888  -282.867  0.0
 -0.00133608   0.0   0.00499316       0.0   -74.4075  -280.79   0.0
  0.00544896  -0.0  -0.00062663      -0.0    23.2536  -280.148  0.0
  ⋮                               ⋱
  0.0181755   -0.0   0.0179431       -0.0  -285.071   -337.48   0.0
  0.0179911    0.0   0.0181963        0.0  -289.591   -337.634  0.0
  0.0182343   -0.0   0.018019        -0.0  -286.777   -337.804  0.0
  0.0180645    0.0   0.0182531        0.0  -290.964   -337.948  0.0
  0.0182893   -0.0   0.0180898    …  -0.0  -288.383   -338.106  0.0
  0.0181329    0.0   0.0183062        0.0  -292.261   -338.241  0.0
  0.0183407   -0.0   0.0181559       -0.0  -289.895   -338.39   0.0
  0.0181968    0.0   0.0183559        0.0  -293.488   -338.516  0.0
  0.0183888   -0.0   0.0182175       -0.0  -291.318   -338.656  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/c67164ba9da82ed84df336d57d99ccf925ba4de9/src/DiffEq_Sovlers.jl#L160-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIgeneralizedBloch.calculatesignal_linearapprox-NTuple{12, Any}" href="#MRIgeneralizedBloch.calculatesignal_linearapprox-NTuple{12, Any}"><code>MRIgeneralizedBloch.calculatesignal_linearapprox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculatesignal_linearapprox(α, TRF, TR, ω0, B1, m0s, R1f, R2f, Rx, R1s, T2s, R2slT[; grad_list=[undef], rfphase_increment=[π], m0=:antiperiodic, output=:complexsignal])</code></pre><p>Calculate the signal or magnetization evolution with the linear approximation of the generalized Bloch model assuming a super-Loretzian lineshape. </p><p>The simulation assumes a sequence of rectangluar RF-pulses with varying flip angles α and RF-pulse durations TRF, but a fixed repetition time TR. Further, it assumes balanced gradient moments. </p><p><strong>Arguments</strong></p><ul><li><code>α::Vector{&lt;:Number}</code>: Array of flip angles in radians</li><li><code>TRF::Vector{&lt;:Number}</code>: Array of the RF-pulse durations in seconds</li><li><code>TR::Number</code>: Repetition time in seconds</li><li><code>ω0::Number</code>: Off-resonance frequency in rad/s </li><li><code>B1::Number</code>: Normalized transmit B1 field, i.e. B1 = 1 corresponds to a well-calibrated B1 field</li><li><code>m0s::Number</code>: Fractional size of the semi-solid pool; should be in range of 0 to 1</li><li><code>R1f::Number</code>: Longitudinal relaxation rate of the free pool in 1/seconds</li><li><code>R2f::Number</code>: Transversal relaxation rate of the free pool in 1/seconds</li><li><code>Rx::Number</code>: Exchange rate between the two spin pools in 1/seconds</li><li><code>R1f::Number</code>: Longitudinal relaxation rate of the semi-solid pool in 1/seconds</li><li><code>T2s::Number</code>: Transversal relaxationt time of the semi-solid pool in seconds</li><li><code>R2slT::NTuple{3, Function}</code>: Tuple of three functions: R2sl(TRF, ω1, B1, T2s), dR2sldB1(TRF, ω1, B1, T2s), and R2sldT2s(TRF, ω1, B1, T2s). Can be generated with <a href="#MRIgeneralizedBloch.precompute_R2sl-Tuple{}"><code>precompute_R2sl</code></a></li></ul><p>Optional:</p><ul><li><code>grad_list=[undef]</code>: Vector to indicate which gradients should be calculated; the vector elements can either be <code>undef</code> for no gradient, or any subset/order of <code>grad_list=[grad_m0s(), grad_R1f(), grad_R2f(), grad_Rx(), grad_R1s(), grad_T2s(), grad_ω0(), grad_B1()]</code>; the derivative wrt. to apparent <code>R1a = R1f = R1s</code> can be calculated with <code>grad_R1a()</code></li><li><code>rfphase_increment=[π]::Vector{&lt;:Number}</code>: Increment of the RF phase between consequtive pulses. The default value <code>π</code>, together with <span>$ω0=0$</span> corresponds to the on-resonance condition. When more than one value is supplied, their resulting signal is stored along the second dimension of the output array. </li><li><code>m0=:antiperiodic</code>: With the default keyword <code>:antiperiodic</code>, the signal and their derivatives are calcualted assuming <span>$m(0) = -m(T)$</span>, where <code>T</code> is the duration of the RF-train. With the keyword :thermal, the magnetization <span>$m(0)$</span> is initialized with thermal equilibrium <code>[xf, yf, zf, xs, zs] = [0, 0, 1-m0s, 0, m0s]</code>, followed by a α[1]/2 - TR/2 prep pulse; and with the keyword <code>:IR</code>, this initalization is followed an inversion pulse of duration <code>TRF[1]</code>, (set <code>α[1]=π</code>) and a α[2]/2 - TR/2 prep pulse.</li><li><code>output=:complexsignal</code>: The defaul keywords triggers the function to output a complex-valued signal (<code>xf + 1im yf</code>); the keyword <code>output=:realmagnetization</code> triggers an output of the entire (real valued) vector <code>[xf, yf, zf, xs, zs]</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R2slT = precompute_R2sl();


julia&gt; calculatesignal_linearapprox(ones(100)*π/2, ones(100)*5e-4, 4e-3, 0, 1, 0.1, 1, 15, 30, 6.5, 10e-6, R2slT)
100×1×1 Array{ComplexF64, 3}:
[:, :, 1] =
 -0.029305987774458298 - 2.609023307487357e-18im
  0.004329424678273616 - 9.22858709360654e-19im
  -0.02276140937384383 + 1.3684406715212983e-18im
  0.008280330224850318 - 3.913888063486245e-18im
  -0.01675130572786822 + 4.6409553994856164e-18im
  0.011921649143708501 - 6.302663734240743e-18im
 -0.011190579890418322 + 7.310583447081588e-18im
   0.01530560844095237 - 8.175490153983983e-18im
 -0.006026791818066622 + 9.464626759459701e-18im
  0.018463027499697637 - 9.608537136498097e-18im
                       ⋮
   0.06153147350966063 + 1.496274325112204e-18im
  0.060814007683572674 + 5.6874647068595874e-18im
  0.061725751593187314 + 1.6576028430814674e-18im
   0.06106421622262947 + 5.557937883636948e-18im
   0.06190745705315383 + 1.808443885793045e-18im
   0.06129750535994443 + 5.436837755621598e-18im
  0.062077399758002784 + 1.949397602286564e-18im
   0.06151502191944254 + 5.3236925282029116e-18im
  0.062236337703062715 + 2.0810405785135138e-18im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/c67164ba9da82ed84df336d57d99ccf925ba4de9/src/MatrixExp_Solvers.jl#L4-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIgeneralizedBloch.dG_o_dT2s_x_T2s_gaussian-Tuple{Any}" href="#MRIgeneralizedBloch.dG_o_dT2s_x_T2s_gaussian-Tuple{Any}"><code>MRIgeneralizedBloch.dG_o_dT2s_x_T2s_gaussian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dG_o_dT2s_x_T2s_gaussian(κ)</code></pre><p>Evaluate the derivative of Green&#39;s function, corresponding to a Gaussian lineshape, wrt. <code>T2s</code> at <code>κ = (t-τ)/T2s</code> and multiply it by <code>T2s</code>.</p><p>The multiplication is added so that the function merely depends on <code>κ = (t-τ)/T2s</code>. The actual derivative is given by <code>dG_o_dT2s_x_T2s_gaussian((t-τ)/T2s)/T2s</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; t = 100e-6;

julia&gt; τ = 0;

julia&gt; T2s = 10e-6;

julia&gt; dGdT2s = dG_o_dT2s_x_T2s_gaussian((t-τ)/T2s)/T2s
1.9287498479639177e-15</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/c67164ba9da82ed84df336d57d99ccf925ba4de9/src/Greens_functions.jl#L66-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIgeneralizedBloch.dG_o_dT2s_x_T2s_lorentzian-Tuple{Any}" href="#MRIgeneralizedBloch.dG_o_dT2s_x_T2s_lorentzian-Tuple{Any}"><code>MRIgeneralizedBloch.dG_o_dT2s_x_T2s_lorentzian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dG_o_dT2s_x_T2s_lorentzian(κ)</code></pre><p>Evaluate the derivative of Green&#39;s function, corresponding to a Lorentzian lineshape, wrt. <code>T2s</code> at <code>κ = (t-τ)/T2s</code> and multiply it by <code>T2s</code>.</p><p>The multiplication is added so that the function merely depends on <code>κ = (t-τ)/T2s</code>. The actual derivative is given by <code>dG_o_dT2s_x_T2s_lorentzian((t-τ)/T2s)/T2s</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; t = 100e-6;

julia&gt; τ = 0;

julia&gt; T2s = 10e-6;

julia&gt; dGdT2s = dG_o_dT2s_x_T2s_lorentzian((t-τ)/T2s)/T2s
45.39992976248485</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/c67164ba9da82ed84df336d57d99ccf925ba4de9/src/Greens_functions.jl#L22-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIgeneralizedBloch.dG_o_dT2s_x_T2s_superlorentzian-Tuple{Any}" href="#MRIgeneralizedBloch.dG_o_dT2s_x_T2s_superlorentzian-Tuple{Any}"><code>MRIgeneralizedBloch.dG_o_dT2s_x_T2s_superlorentzian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dG_o_dT2s_x_T2s_superlorentzian(κ)</code></pre><p>Evaluate the derivative of Green&#39;s function, corresponding to a super-Lorentzian lineshape, wrt. <code>T2s</code> at <code>κ = (t-τ)/T2s</code> and multiply it by <code>T2s</code>.</p><p>The multiplication is added so that the function merely depends on <code>κ = (t-τ)/T2s</code>. The actual derivative is given by <code>dG_o_dT2s_x_T2s_superlorentzian((t-τ)/T2s)/T2s</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; t = 100e-6;

julia&gt; τ = 0;

julia&gt; T2s = 10e-6;

julia&gt; dGdT2s = dG_o_dT2s_x_T2s_superlorentzian((t-τ)/T2s)/T2s
15253.095033670965</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/c67164ba9da82ed84df336d57d99ccf925ba4de9/src/Greens_functions.jl#L110-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIgeneralizedBloch.greens_gaussian-Tuple{Any}" href="#MRIgeneralizedBloch.greens_gaussian-Tuple{Any}"><code>MRIgeneralizedBloch.greens_gaussian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">greens_gaussian(κ)</code></pre><p>Evaluate the Green&#39;s function corresponding to a Gaussian lineshape at <code>κ = (t-τ)/T2s</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; t = 100e-6;

julia&gt; τ = 0;

julia&gt; T2s = 10e-6;

julia&gt; greens_gaussian((t-τ)/T2s)
1.9287498479639178e-22</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/c67164ba9da82ed84df336d57d99ccf925ba4de9/src/Greens_functions.jl#L45-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIgeneralizedBloch.greens_lorentzian-Tuple{Any}" href="#MRIgeneralizedBloch.greens_lorentzian-Tuple{Any}"><code>MRIgeneralizedBloch.greens_lorentzian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">greens_lorentzian(κ)</code></pre><p>Evaluate the Green&#39;s function corresponding to a Lorentzian lineshape at <code>κ = (t-τ)/T2s</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; t = 100e-6;

julia&gt; τ = 0;

julia&gt; T2s = 10e-6;

julia&gt; greens_lorentzian((t-τ)/T2s)
4.5399929762484854e-5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/c67164ba9da82ed84df336d57d99ccf925ba4de9/src/Greens_functions.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIgeneralizedBloch.greens_superlorentzian-Tuple{Any}" href="#MRIgeneralizedBloch.greens_superlorentzian-Tuple{Any}"><code>MRIgeneralizedBloch.greens_superlorentzian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">greens_superlorentzian(κ)</code></pre><p>Evaluate the Green&#39;s function corresponding to a super-Lorentzian lineshape at <code>κ = (t-τ)/T2s</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; t = 100e-6;

julia&gt; τ = 0;

julia&gt; T2s = 10e-6;

julia&gt; greens_superlorentzian((t-τ)/T2s)
0.1471246868094442</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/c67164ba9da82ed84df336d57d99ccf925ba4de9/src/Greens_functions.jl#L89-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIgeneralizedBloch.hamiltonian_linear-NTuple{10, Any}" href="#MRIgeneralizedBloch.hamiltonian_linear-NTuple{10, Any}"><code>MRIgeneralizedBloch.hamiltonian_linear</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hamiltonian_linear(ω1, B1, ω0, T, m0s, R1f, R2f, Rx, R1s, R2s[, dR2sdT2s, dR2sdB1, grad_type])</code></pre><p>Calculate the hamiltonian of the linear approximation of the generalized Bloch model. </p><p>If no gradient is supplied, it returns a 6x6 (static) matrix with the dimensions (in this order) <code>[xf, yf, zf, xs, zs, 1]</code>; the attached 1 is a mathematical trick to allow for <span>$T_1$</span> relaxation to a non-zero thermal equilibrium. If a gradient is supplied, it returns a 11x11 (static) matrix with the dimensions (in this order) <code>[xf, yf, zf, xs, zs, dxf/dθ, dyf/dθ, dzf/dθ, dxs/dθ, dzs/dθ,  1]</code>, where <code>θ</code> is the parameter specified by <code>grad_type</code></p><p><strong>Arguments</strong></p><ul><li><code>ω1::Number</code>: Rabi frequency in rad/s (rotation about the y-axis)</li><li><code>B1::Number</code>: Normalized transmit B1 field, i.e. B1 = 1 corresponds to a well-calibrated B1 field</li><li><code>ω0::Number</code>: Larmor (or off-resonance) frequency in rad/s (rotation about the z-axis)</li><li><code>T::Number</code>: Time in seconds; this can, e.g., be the RF-pulse duration, or the time of free precession with <code>ω1=0</code></li><li><code>m0s::Number</code>: Fractional size of the semi-solid pool; should be in range of 0 to 1</li><li><code>R1f::Number</code>: Longitudinal relaxation rate of the free pool in 1/seconds</li><li><code>R2f::Number</code>: Transversal relaxation rate of the free pool in 1/seconds</li><li><code>Rx::Number</code>: Exchange rate between the two spin pools in 1/seconds</li><li><code>R1s::Number</code>: Longitudinal relaxation rate of the semi-solid pool in 1/seconds</li><li><code>R2s::Number</code>: Transversal relaxationt rate of the semi-solid pool in 1/seconds; this number can be calcualated with the first function returned by <a href="#MRIgeneralizedBloch.precompute_R2sl-Tuple{}"><code>precompute_R2sl</code></a> to implement the linear approximation described in the generalized Bloch paper</li></ul><p>Optional:</p><ul><li><code>dR2sdT2s::Number</code>: Derivative of linearized R2sl wrt. the actual T2s; only required if <code>grad_type = grad_T2s()</code>; this number can be calcualated with the second function returned by <a href="#MRIgeneralizedBloch.precompute_R2sl-Tuple{}"><code>precompute_R2sl</code></a></li><li><code>dR2sdB1::Number</code>: Derivative of linearized R2sl wrt. B1; only required if <code>grad_type = grad_B1()</code>; this number can be calcualated with the third function returned by <a href="#MRIgeneralizedBloch.precompute_R2sl-Tuple{}"><code>precompute_R2sl</code></a></li><li><code>grad_type::grad_param</code>: <code>grad_m0s()</code>, <code>grad_R1f()</code>, <code>grad_R1s()</code>, <code>grad_R2f()</code>, <code>grad_Rx()</code>, <code>grad_T2s()</code>, <code>grad_ω0()</code>, or <code>grad_B1()</code>; create one hamiltonian for each desired gradient</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; α = π;

julia&gt; T = 500e-6;

julia&gt; ω1 = α/T;

julia&gt; B1 = 1;

julia&gt; ω0 = 0;

julia&gt; m0s = 0.1;

julia&gt; R1f = 1;

julia&gt; R2f = 15;

julia&gt; Rx = 30;

julia&gt; R1s = 6.5;

julia&gt; R2s = 1e5;

julia&gt; m0 = [0, 0, 1-m0s, 0, m0s, 1];

julia&gt; (xf, yf, zf, xs, zs, _) = exp(hamiltonian_linear(ω1, B1, ω0, T, m0s, R1f, R2f, Rx, R1s, R2s)) * m0
6-element StaticArrays.SVector{6, Float64} with indices SOneTo(6):
  0.0010647535813059729
  0.0
 -0.8957848274535016
  0.005126529591877105
  0.08122007142111892
  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/c67164ba9da82ed84df336d57d99ccf925ba4de9/src/MatrixExp_Hamiltonians.jl#L2-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIgeneralizedBloch.interpolate_greens_function-Tuple{Any, Any, Any}" href="#MRIgeneralizedBloch.interpolate_greens_function-Tuple{Any, Any, Any}"><code>MRIgeneralizedBloch.interpolate_greens_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">interpolate_greens_function(f, κmin, κmax)</code></pre><p>Interpolate the Green&#39;s function f in the range between κmin and κmax.</p><p>The interpolation uses the ApproxFun.jl package that incorporates Chebyshev polynomials and ensures an approximation to machine precision. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; t = 100e-6;

julia&gt; τ = 0;

julia&gt; T2s = 10e-6;

julia&gt; greens_superlorentzian((t-τ)/T2s)
0.1471246868094442

julia&gt; Gint = interpolate_greens_function(greens_superlorentzian, 0, 20);


julia&gt; Gint((t-τ)/T2s)
0.14712468680944407</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/c67164ba9da82ed84df336d57d99ccf925ba4de9/src/Greens_functions.jl#L134-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIgeneralizedBloch.precompute_R2sl-Tuple{}" href="#MRIgeneralizedBloch.precompute_R2sl-Tuple{}"><code>MRIgeneralizedBloch.precompute_R2sl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">precompute_R2sl([;TRF_min=100e-6, TRF_max=500e-6, T2s_min=5e-6, T2s_max=21e-6, ω1_max=π/TRF_max, B1_max=1.5, greens=greens_superlorentzian])</code></pre><p>Pre-compute and interpolate the linearized <code>R2sl(TRF, α, B1, T2s)</code> and its derivatives <code>dR2sldB1(TRF, α, B1, T2s)</code>, <code>R2sldT2s(TRF, α, B1, T2s)</code> etc. in the range specified by the arguments.</p><p>The function solves the generalized Bloch equations of an isolated semi-solid pool for values in the specified range, calulates the linearized R2sl that minimizes the error of <code>zs</code> at the end of the RF-pulse, and interpolates between the different samples. </p><p><strong>Optional Arguments:</strong></p><ul><li><code>TRF_min::Number</code>: lower bound of the RF-pulse duration range in seconds</li><li><code>TRF_max::Number</code>: upper bound of the RF-pulse duration range in seconds</li><li><code>T2s_min::Number</code>: lower bound of the <code>T2s</code> range in seconds</li><li><code>T2s_max::Number</code>: upper bound of the <code>T2s</code> range in seconds</li><li><code>ω1_max::Number</code>: upper bound of the Rabi frequency ω1, the default is the frequency of a 500μs long π-pulse</li><li><code>B1_max::Number</code>: upper bound of the B1 range, normalized so that <code>B1 = 1</code> corresponds to a perfectly calibrated RF field</li><li><code>greens=greens_superlorentzian</code>: Greens function in the form <code>G(κ) = G((t-τ)/T2s)</code>. This package supplies the three Greens functions <code>greens=greens_superlorentzian</code> (default), <code>greens=greens_lorentzian</code>, and <code>greens=greens_gaussian</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R2slT = precompute_R2sl();

julia&gt; R2sl, dR2sldB1, R2sldT2s, _ = precompute_R2sl(TRF_min=100e-6, TRF_max=500e-6, T2s_min=5e-6, T2s_max=15e-6, ω1_max=π/500e-6, B1_max=1.3, greens=greens_gaussian);
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/c67164ba9da82ed84df336d57d99ccf925ba4de9/src/Linearized_R2s.jl#L1-L24">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../build_literate/Linear_Approximation/">« Linear Approximation</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Thursday 30 December 2021 03:09">Thursday 30 December 2021</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
