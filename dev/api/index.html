<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · MRIgeneralizedBloch.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://JakobAsslaender.github.io/MRIgeneralizedBloch.jl/api/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MRIgeneralizedBloch.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../build_literate/tutorial_singlepulse/">Simulation of a Single RF Pulse</a></li><li><a class="tocitem" href="../build_literate/tutorial_pulsetrain/">Balanced Hybrid-State Free Precession Pulse Sequence</a></li><li><a class="tocitem" href="../build_literate/NLLS/">Non-Linear Least Square Fitting</a></li><li><a class="tocitem" href="../build_literate/OCT/">Optimal Control</a></li><li><span class="tocitem">Generalized Bloch Paper</span><ul><li><a class="tocitem" href="../build_literate/Greens_functions/">Green&#39;s Functions</a></li><li><a class="tocitem" href="../build_literate/Simulation_ContinuousWave/">Continuous Wave Simulation</a></li><li><a class="tocitem" href="../build_literate/Simulation_Pulse/">RF-Pulse Simulation</a></li><li><a class="tocitem" href="../build_literate/Analyze_NMR_IR_Data/">Inversion Recovery Experiments</a></li><li><a class="tocitem" href="../build_literate/Analyze_NMR_PreSat_Data/">Continuous Wave Saturation Experiments</a></li><li><a class="tocitem" href="../build_literate/Linear_Approximation/">Linear Approximation</a></li></ul></li><li class="is-active"><a class="tocitem" href>API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/master/docs/src/api.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><p>In the following, you find the documentation of all exported functions of the <a href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl">MRIgeneralizedBloch.jl</a> package:</p><ul><li><a href="#MRIgeneralizedBloch.CRB_gradient_OCT-NTuple{14, Any}"><code>MRIgeneralizedBloch.CRB_gradient_OCT</code></a></li><li><a href="#MRIgeneralizedBloch.RF_power!-NTuple{4, Any}"><code>MRIgeneralizedBloch.RF_power!</code></a></li><li><a href="#MRIgeneralizedBloch.TRF_TV!-Tuple{Any, Any, Any}"><code>MRIgeneralizedBloch.TRF_TV!</code></a></li><li><a href="#MRIgeneralizedBloch.apply_hamiltonian_gbloch!-Tuple{Any, Any, Any, NTuple{11, Any}, Any}"><code>MRIgeneralizedBloch.apply_hamiltonian_gbloch!</code></a></li><li><a href="#MRIgeneralizedBloch.apply_hamiltonian_sled!-Tuple{Any, Any, NTuple{6, Any}, Any}"><code>MRIgeneralizedBloch.apply_hamiltonian_sled!</code></a></li><li><a href="#MRIgeneralizedBloch.bound_ω1_TRF!-Tuple{Any, Any}"><code>MRIgeneralizedBloch.bound_ω1_TRF!</code></a></li><li><a href="#MRIgeneralizedBloch.calculatesignal_gbloch_ide-NTuple{11, Any}"><code>MRIgeneralizedBloch.calculatesignal_gbloch_ide</code></a></li><li><a href="#MRIgeneralizedBloch.calculatesignal_graham_ode-NTuple{11, Any}"><code>MRIgeneralizedBloch.calculatesignal_graham_ode</code></a></li><li><a href="#MRIgeneralizedBloch.calculatesignal_linearapprox-NTuple{12, Any}"><code>MRIgeneralizedBloch.calculatesignal_linearapprox</code></a></li><li><a href="#MRIgeneralizedBloch.dG_o_dT2s_x_T2s_gaussian-Tuple{Any}"><code>MRIgeneralizedBloch.dG_o_dT2s_x_T2s_gaussian</code></a></li><li><a href="#MRIgeneralizedBloch.dG_o_dT2s_x_T2s_lorentzian-Tuple{Any}"><code>MRIgeneralizedBloch.dG_o_dT2s_x_T2s_lorentzian</code></a></li><li><a href="#MRIgeneralizedBloch.dG_o_dT2s_x_T2s_superlorentzian-Tuple{Any}"><code>MRIgeneralizedBloch.dG_o_dT2s_x_T2s_superlorentzian</code></a></li><li><a href="#MRIgeneralizedBloch.fit_gBloch-NTuple{4, Any}"><code>MRIgeneralizedBloch.fit_gBloch</code></a></li><li><a href="#MRIgeneralizedBloch.get_bounded_ω1_TRF-Tuple{Any}"><code>MRIgeneralizedBloch.get_bounded_ω1_TRF</code></a></li><li><a href="#MRIgeneralizedBloch.greens_gaussian-Tuple{Any}"><code>MRIgeneralizedBloch.greens_gaussian</code></a></li><li><a href="#MRIgeneralizedBloch.greens_lorentzian-Tuple{Any}"><code>MRIgeneralizedBloch.greens_lorentzian</code></a></li><li><a href="#MRIgeneralizedBloch.greens_superlorentzian-Tuple{Any}"><code>MRIgeneralizedBloch.greens_superlorentzian</code></a></li><li><a href="#MRIgeneralizedBloch.hamiltonian_linear-NTuple{10, Any}"><code>MRIgeneralizedBloch.hamiltonian_linear</code></a></li><li><a href="#MRIgeneralizedBloch.interpolate_greens_function-Tuple{Any, Any, Any}"><code>MRIgeneralizedBloch.interpolate_greens_function</code></a></li><li><a href="#MRIgeneralizedBloch.precompute_R2sl-Tuple{}"><code>MRIgeneralizedBloch.precompute_R2sl</code></a></li><li><a href="#MRIgeneralizedBloch.second_order_α!-NTuple{4, Any}"><code>MRIgeneralizedBloch.second_order_α!</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="MRIgeneralizedBloch.CRB_gradient_OCT-NTuple{14, Any}" href="#MRIgeneralizedBloch.CRB_gradient_OCT-NTuple{14, Any}"><code>MRIgeneralizedBloch.CRB_gradient_OCT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CRB, grad_ω1, grad_TRF = CRB_gradient_OCT(ω1, TRF, TR, ω0, B1, m0s, R1f, R2f, Rx, R1s, T2s, R2slT, grad_list, weights; isInversionPulse = [true; falses(length(ω1)-1)])</code></pre><p>Calculate the Cramer-Rao bound of a pulse sequence along with the derivatives wrt. <code>ω1</code> and <code>TRF</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ω1::Vector{&lt;:Number}</code>: Control vector of <code>length = Npulses</code></li><li><code>TRF::Vector{&lt;:Number}</code>: Control vector of <code>length = Npulses</code></li><li><code>TR::Number</code>: Repetition time in seconds</li><li><code>ω0::Number</code>: Off-resonance frequency in rad/s</li><li><code>B1::Number</code>: Normalized transmit B1 field, i.e. B1 = 1 corresponds to a well-calibrated B1 field</li><li><code>m0s::Number</code>: Fractional size of the semi-solid pool; should be in range of 0 to 1</li><li><code>R1f::Number</code>: Longitudinal relaxation rate of the free pool in 1/seconds</li><li><code>R2f::Number</code>: Transversal relaxation rate of the free pool in 1/seconds</li><li><code>Rx::Number</code>: Exchange rate between the two spin pools in 1/seconds</li><li><code>R1f::Number</code>: Longitudinal relaxation rate of the semi-solid pool in 1/seconds</li><li><code>T2s::Number</code>: Transversal relaxation time of the semi-solid pool in seconds</li><li><code>R2slT::NTuple{3, Function}</code>: Tuple of three functions: R2sl(TRF, ω1, B1, T2s), dR2sldB1(TRF, ω1, B1, T2s), and R2sldT2s(TRF, ω1, B1, T2s). Can be generated with <a href="#MRIgeneralizedBloch.precompute_R2sl-Tuple{}"><code>precompute_R2sl</code></a></li><li><code>grad_list::Vector{&lt;:grad_param}</code>: Vector that specifies the gradients that are calculated; the vector elements can either be any subset/order of <code>grad_list=[grad_m0s(), grad_R1f(), grad_R2f(), grad_Rx(), grad_R1s(), grad_T2s(), grad_ω0(), grad_B1()]</code>; the derivative wrt. to apparent <code>R1a = R1f = R1s</code> can be calculated with <code>grad_R1a()</code></li><li><code>weights::transpose(Vector{&lt;:Number})</code>: Row vector of weights applied to the Cramer-Rao bounds (CRB) of the individual parameters. The first entry always refers to the CRB of M0, followed by the values defined in <code>grad_list</code> in the order defined therein. Hence, the vector <code>weights</code> has to have one more entry than <code>grad_list</code></li></ul><p><strong>Optional Keyword Arguments:</strong></p><ul><li><code>isInversionPulse::Vector{Bool}</code>: Indicates all inversion pulses; must have the same length as α; the <code>default = [true; falses(length(ω1)-1)]</code> indicates that the first pulse is an inversion pulse and all others are not</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; CRB, grad_ω1, grad_TRF = MRIgeneralizedBloch.CRB_gradient_OCT(rand(100) .* π, rand(100) .* 400e-6 .+ 100e-6, 3.5e-3, 0, 1, 0.15, 0.5, 15, 30, 2, 10e-6, precompute_R2sl(), [grad_m0s(), grad_R1f()], transpose([0, 1, 1]); isInversionPulse = [true, falses(99)...])
(4.326345257791475e20, [0.0, 3.8149138162765024e20, -1.4073464193072628e20, 1.196651310804305e20, -1.9989638164742383e20, 3.6493209787269874e20, -1.5536324770044346e20, 1.7284798914645443e20, -2.0772522228321904e20, 2.7044669618035792e20  …  -6.3928347250126905e19, 1.5671768655962505e20, -1.1080723702078613e20, 5.7454290837437145e19, -7.845659845122268e19, 1.3447202941410777e20, -6.377328799158878e19, 5.1500654841007415e19, -3.97683716404465e19, 1.2714666624472279e20], [0.0, 2.9969441368202493e24, -1.4650231537214497e24, 1.8226585318981564e24, -4.7462030797597407e23, 1.97549455130354e24, -1.5270500210926142e24, 9.099568864141483e23, -1.4811032902868818e24, 1.2220830933233262e24  …  -5.258326682397155e23, 6.918585992930617e23, -2.8293355719514886e23, 4.015546075884712e23, -4.1767064624316516e23, 5.061776753372734e23, -4.1049901738345103e23, 9.311794792265391e23, -4.131984395429261e23, 7.610379029805631e23])
</code></pre><p>c.f. <a href="../build_literate/OCT/#Optimal-Control">Optimal Control</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/ed30a12d9b12e0bb77da8a1d1088237cf10cc749/src/OptimalControl.jl#L1-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIgeneralizedBloch.RF_power!-NTuple{4, Any}" href="#MRIgeneralizedBloch.RF_power!-NTuple{4, Any}"><code>MRIgeneralizedBloch.RF_power!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">F = RF_power!(grad_ω1, grad_TRF, ω1, TRF; λ=1, Pmax=3e6, TR=3.5e-3)</code></pre><p>Calculate RF power penalty and over-write the gradients in place.</p><p><strong>Arguments</strong></p><ul><li><code>grad_ω1::Vector{&lt;:Number}</code>: Gradient of control, which will be over-written in place</li><li><code>grad_TRF::Vector{&lt;:Number}</code>: Gradient of control, which will be over-written in place</li><li><code>ω1::Vector{&lt;:Number}</code>: Control vector</li><li><code>TRF::Vector{&lt;:Number}</code>: Control vector</li></ul><p><strong>Optional Keyword Arguments:</strong></p><ul><li><code>λ::Number</code>: regularization parameter</li><li><code>Pmax::Number</code>: Maximum average power deposition in (rad/s)²; everything above this value will be penalized and with an appropriate λ, the resulting power will be equal to or less than this value.</li><li><code>TR::Number</code>: Repetition time of the pulse sequence</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ω1 = 4000π * rand(100);

julia&gt; TRF = 500e-6 * rand(100);

julia&gt; grad_ω1 = similar(ω1);

julia&gt; grad_TRF = similar(ω1);

julia&gt; F = MRIgeneralizedBloch.RF_power!(grad_ω1, grad_TRF, ω1, TRF; λ=1e3, Pmax=3e5)
9.54432950518758e15</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/ed30a12d9b12e0bb77da8a1d1088237cf10cc749/src/OptimalControlHelpers.jl#L333-L362">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIgeneralizedBloch.TRF_TV!-Tuple{Any, Any, Any}" href="#MRIgeneralizedBloch.TRF_TV!-Tuple{Any, Any, Any}"><code>MRIgeneralizedBloch.TRF_TV!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">F = TRF_TV!(grad_TRF, ω1, TRF; λ = 1)</code></pre><p>Calculate the total variation penalty of <code>TRF</code> and over-write <code>grad_TRF</code> in place.</p><p><strong>Arguments</strong></p><ul><li><code>grad_TRF::Vector{&lt;:Number}</code>: Gradient of control, which will be over-written in place</li><li><code>ω1::Vector{&lt;:Number}</code>: Control vector</li><li><code>TRF::Vector{&lt;:Number}</code>: Control vector</li></ul><p><strong>Optional Keyword Arguments:</strong></p><ul><li><code>λ::Number</code>: regularization parameter</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ω1 = 4000π * rand(100);

julia&gt; TRF = 500e-6 * rand(100);

julia&gt; grad_TRF = similar(ω1);

julia&gt; F = MRIgeneralizedBloch.TRF_TV!(grad_TRF, ω1, TRF; λ = 1e-3)
1.826335488333797e-5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/ed30a12d9b12e0bb77da8a1d1088237cf10cc749/src/OptimalControlHelpers.jl#L284-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIgeneralizedBloch.apply_hamiltonian_gbloch!-Tuple{Any, Any, Any, NTuple{11, Any}, Any}" href="#MRIgeneralizedBloch.apply_hamiltonian_gbloch!-Tuple{Any, Any, Any, NTuple{11, Any}, Any}"><code>MRIgeneralizedBloch.apply_hamiltonian_gbloch!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply_hamiltonian_gbloch!(∂m∂t, m, mfun, p, t)</code></pre><p>Apply the generalized Bloch Hamiltonian to <code>m</code> and write the resulting derivative wrt. time into <code>∂m∂t</code>.</p><p><strong>Arguments</strong></p><ul><li><code>∂m∂t::Vector{&lt;:Number}</code>: Vector describing to derivative of <code>m</code> wrt. time; this vector has to be of the same size as <code>m</code>, but can contain any value, which is replaced by <code>H * m</code></li><li><code>m::Vector{&lt;:Number}</code>: Vector the spin ensemble state of the form <code>[xf, yf, zf, zs, 1]</code> if now gradient is calculated or of the form <code>[xf, yf, zf, zs, 1, ∂xf/∂θ1, ∂yf/∂θ1, ∂zf/∂θ1, ∂zs/∂θ1, 0, ..., ∂xf/∂θn, ∂yf/∂θn, ∂zf/∂θn, ∂zs/∂θn, 0]</code> if n derivatives wrt. <code>θn</code> are calculated</li><li><code>mfun</code>: History function; can be initialized with <code>mfun(p, t; idxs=nothing) = typeof(idxs) &lt;: Number ? 0.0 : zeros(5n + 5)</code> for n gradients, and is then updated by the delay differential equation solvers</li><li><code>p::NTuple{9,10, or 11, Any}</code>: <code>(ω1, B1, ω0, m0s, R1f, R2f, Rx, R1s, T2s, g)</code>, with   -<code>ω1::Number</code>: Rabi frequency in rad/s (rotation about the y-axis)   -<code>B1::Number</code>: B1 scaling normalized so that <code>B1=1</code> corresponds to a perfectly calibrated RF field   -<code>ω0::Number</code>: Larmor or off-resonance frequency in rad/s   -<code>m0s::Number</code>: Fractional semi-solid spin pool size in the range of 0 to 1   -<code>R1f::Number</code>: Longitudinal spin relaxation rate of the free pool in 1/seconds   -<code>R2f::Number</code>: Transversal spin relaxation rate of the free pool in 1/seconds   -<code>Rx::Number</code>: Exchange rate between the two pools in 1/seconds   -<code>R1s::Number</code>: Longitudinal spin relaxation rate of the semi-solid pool in 1/seconds   -<code>T2s::Number</code>: Transversal spin relaxation time of the semi-solid pool in seconds   -<code>g::Function</code>: Green&#39;s function of the form <code>G(κ) = G((t-τ)/T2s)</code>   or <code>(ω1, B1, ω0, m0s, R1f, R2f, Rx, R1s, T2s, zs_idx, g)</code> with<ul><li><code>zs_idx::Integer</code>: Index to be used history function to be used in the Green&#39;s function; Default is 4 (zs), and for derivatives 9, 14, ... are used</li></ul>or <code>(ω1, B1, ω0, m0s, R1f, R2f, Rx, R1s, T2s, g, dG_o_dT2s_x_T2s, grad_list)</code> with<ul><li><code>dG_o_dT2s_x_T2s::Function</code>: Derivative of the Green&#39;s function wrt. T2s, multiplied by T2s; of the form <code>dG_o_dT2s_x_T2s(κ) = dG_o_dT2s_x_T2s((t-τ)/T2s)</code></li><li><code>grad_list::Vector{&lt;:grad_param}</code>: List of gradients to be calculated; any subset of <code>[grad_m0s(), grad_R1f(), grad_R2f(), grad_Rx(), grad_R1s(), grad_T2s(), grad_ω0(), grad_B1()]</code>; length of the vector must be n (cf. arguments <code>m</code> and <code>∂m∂t</code>); ; the derivative wrt. to apparent <code>R1a = R1f = R1s</code> can be calculated with <code>grad_R1a()</code></li></ul></li><li><code>t::Number</code>: Time in seconds</li></ul><p>Optional:</p><ul><li><code>pulsetype=:normal</code>: Use default for a regular RF-pulse; the option <code>pulsetype=:inversion</code> should be handled with care as it is only intended to calculate the saturation of the semi-solid pool and its derivative.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DifferentialEquations


julia&gt; α = π/2;

julia&gt; TRF = 100e-6;

julia&gt; ω1 = α/TRF;

julia&gt; B1 = 1;

julia&gt; ω0 = 0;

julia&gt; m0s = 0.2;

julia&gt; R1f = 1/3;

julia&gt; R2f = 15;

julia&gt; R1s = 2;

julia&gt; T2s = 10e-6;

julia&gt; Rx = 30;

julia&gt; G = interpolate_greens_function(greens_superlorentzian, 0, TRF / T2s);


julia&gt; m0 = [0; 0; 1-m0s; m0s; 1];

julia&gt; mfun(p, t; idxs=nothing) = typeof(idxs) &lt;: Number ? 0.0 : zeros(5);

julia&gt; sol = solve(DDEProblem(apply_hamiltonian_gbloch!, m0, mfun, (0, TRF), (ω1, B1, ω0, m0s, R1f, R2f, Rx, R1s, T2s, G)))
retcode: Success
Interpolation: specialized 4th order &quot;free&quot; interpolation, specialized 2nd order &quot;free&quot; stiffness-aware interpolation
t: 9-element Vector{Float64}:
 0.0
 1.375006182301112e-7
 1.512506800531223e-6
 8.042561696923577e-6
 2.107848894861101e-5
 3.911414415070652e-5
 6.26879093553081e-5
 9.147705752659822e-5
 0.0001
u: 9-element Vector{Vector{Float64}}:
 [0.0, 0.0, 0.8, 0.2, 1.0]
 [0.0017278806030763402, 0.0, 0.7999981340131751, 0.19999953350448, 1.0]
 [0.019004717382235078, 0.0, 0.7997742277135814, 0.19994357804868362, 1.0]
 [0.10079111348917136, 0.0, 0.7936248122939504, 0.19842287240365722, 1.0]
 [0.26002578672576243, 0.0, 0.7565529666157937, 0.18981913039644657, 1.0]
 [0.4610419882566734, 0.0, 0.6537242214798688, 0.16937688382096108, 1.0]
 [0.6661738538876186, 0.0, 0.44261236945975563, 0.1358931514238721, 1.0]
 [0.7923116826717905, 0.0, 0.10713144280454787, 0.09390268562369869, 1.0]
 [0.7994211188440815, 0.0, 0.0004403374355099447, 0.08214809683848684, 1.0]

julia&gt; using Plots

julia&gt; plot(sol, labels=[&quot;xf&quot; &quot;yf&quot; &quot;zf&quot; &quot;zs&quot; &quot;1&quot;], xlabel=&quot;t (s)&quot;, ylabel=&quot;m(t)&quot;);




julia&gt; dG_o_dT2s_x_T2s = interpolate_greens_function(dG_o_dT2s_x_T2s_superlorentzian, 0, TRF / T2s);


julia&gt; grad_list = [grad_R2f(), grad_m0s()];


julia&gt; m0 = [0; 0; 1-m0s; m0s; 1; zeros(5*length(grad_list))];


julia&gt; mfun(p, t; idxs=nothing) = typeof(idxs) &lt;: Number ? 0.0 : zeros(5 + 5*length(grad_list));

julia&gt; sol = solve(DDEProblem(apply_hamiltonian_gbloch!, m0, mfun, (0, TRF), (ω1, B1, ω0, m0s, R1f, R2f, Rx, R1s, T2s, G, dG_o_dT2s_x_T2s, grad_list)));




julia&gt; plot(sol);

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/ed30a12d9b12e0bb77da8a1d1088237cf10cc749/src/DiffEq_Hamiltonians.jl#L5-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIgeneralizedBloch.apply_hamiltonian_sled!-Tuple{Any, Any, NTuple{6, Any}, Any}" href="#MRIgeneralizedBloch.apply_hamiltonian_sled!-Tuple{Any, Any, NTuple{6, Any}, Any}"><code>MRIgeneralizedBloch.apply_hamiltonian_sled!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">apply_hamiltonian_sled!(∂m∂t, m, p, t)</code></pre><p>Apply Sled&#39;s Hamiltonian to <code>m</code> and write the resulting derivative wrt. time into <code>∂m∂t</code>.</p><p><strong>Arguments</strong></p><ul><li><code>∂m∂t::Vector{&lt;:Number}</code>: Vector of length 1 describing to derivative of <code>m</code> wrt. time; this vector can contain any value, which is replaced by <code>H * m</code></li><li><code>m::Vector{&lt;:Number}</code>: Vector of length 1 describing the <code>zs</code> magnetization</li><li><code>p::NTuple{6 or 10, Any}</code>: <code>(ω1, B1, ω0, R1s, T2s, g)</code> for a simulating an isolated semi-solid pool or <code>(ω1, B1, ω0, m0s, R1f, R2f, Rx, R1s, T2s, g)</code> for simulating a coupled spin system; with   -<code>ω1::Number</code>: Rabi frequency in rad/s (rotation about the y-axis)   -<code>B1::Number</code>: B1 scaling normalized so that <code>B1=1</code> corresponds to a perfectly calibrated RF field   -<code>ω0::Number</code>: Larmor or off-resonance frequency in rad/s   -<code>R1f::Number</code>: Longitudinal spin relaxation rate of the free pool in 1/seconds   -<code>R2f::Number</code>: Transversal spin relaxation rate of the free pool in 1/seconds   -<code>R1s::Number</code>: Longitudinal spin relaxation rate of the semi-solid in 1/seconds   -<code>Rx::Number</code>: Exchange rate between the two pools in 1/seconds   -<code>T2s::Number</code>: Transversal spin relaxation time in seconds   -<code>g::Function</code>: Green&#39;s function of the form <code>G(κ) = G((t-τ)/T2s)</code></li><li><code>t::Number</code>: Time in seconds</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using DifferentialEquations


julia&gt; α = π/2;

julia&gt; TRF = 100e-6;

julia&gt; ω1 = α/TRF;

julia&gt; B1 = 1;

julia&gt; ω0 = 0;

julia&gt; R1s = 2;

julia&gt; T2s = 10e-6;

julia&gt; G = interpolate_greens_function(greens_superlorentzian, 0, TRF / T2s);

julia&gt; m0 = [1];

julia&gt; sol = solve(ODEProblem(apply_hamiltonian_sled!, m0, (0, TRF), (ω1, 1, ω0, R1s, T2s, G)), Tsit5())
retcode: Success
Interpolation: specialized 4th order &quot;free&quot; interpolation
t: 3-element Vector{Float64}:
 0.0
 7.475414666720001e-5
 0.0001
u: 3-element Vector{Vector{Float64}}:
 [1.0]
 [0.631392823181197]
 [0.48953654496619187]

julia&gt; using Plots

julia&gt; plot(sol, labels=[&quot;zs&quot;], xlabel=&quot;t (s)&quot;, ylabel=&quot;m(t)&quot;);


</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/ed30a12d9b12e0bb77da8a1d1088237cf10cc749/src/DiffEq_Hamiltonians.jl#L481-L543">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIgeneralizedBloch.bound_ω1_TRF!-Tuple{Any, Any}" href="#MRIgeneralizedBloch.bound_ω1_TRF!-Tuple{Any, Any}"><code>MRIgeneralizedBloch.bound_ω1_TRF!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">x = bound_ω1_TRF!(ω1, TRF; ω1_min = 0, ω1_max = 2e3π, TRF_min = 100e-6, TRF_max = 500e-6)</code></pre><p>Bound the controls <code>ω1</code> and <code>TRF</code> (over-written in place) and return a vector of length <code>2Npulses</code> with values in the range <code>[-Inf, Inf]</code> that relate to the bounded <code>ω1</code> and <code>TRF</code> via the <code>tanh</code> function.</p><p><strong>Arguments</strong></p><ul><li><code>ω1::Vector{&lt;:Number}</code>: Control vector of length <code>Npulses</code></li><li><code>TRF::Vector{&lt;:Number}</code>: Control vector of length <code>Npulses</code></li></ul><p><strong>Optional Keyword Arguments (see above for defaults):</strong></p><ul><li><code>ω1_min::Number</code>: lower bound for ω1 in rad/s</li><li><code>ω1_max::Number</code>: upper bound for ω1 in rad/s</li><li><code>TRF_min::Number</code>: lower bound for TRF in s</li><li><code>TRF_max::Number</code>: upper bound for TRF in s</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ω1 = 4000π * rand(100);

julia&gt; TRF = 500e-6 * rand(100);

julia&gt; x = MRIgeneralizedBloch.bound_ω1_TRF!(ω1, TRF)
200-element Vector{Float64}:
  Inf
   0.16123919298957837
  Inf
  Inf
  Inf
  Inf
   0.17719147195925186
   0.33617937553604216
  -1.1288911659500056
  Inf
   ⋮
 -Inf
  -0.5475311433614531
  -0.6572991695812251
 -Inf
  -0.5487931795341404
  -2.097250369053942
 -Inf
  -1.1536520473794025
   0.07161170293075586</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/ed30a12d9b12e0bb77da8a1d1088237cf10cc749/src/OptimalControlHelpers.jl#L32-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIgeneralizedBloch.calculatesignal_gbloch_ide-NTuple{11, Any}" href="#MRIgeneralizedBloch.calculatesignal_gbloch_ide-NTuple{11, Any}"><code>MRIgeneralizedBloch.calculatesignal_gbloch_ide</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculatesignal_gbloch_ide(α, TRF, TR, ω0, B1, m0s, R1f, R2f, Rx, R1s, T2s[; grad_list, Ncyc=2, output=:complexsignal])</code></pre><p>Calculate the signal or magnetization evolution with the full generalized Bloch model assuming a super-Lorentzian lineshape (slow).</p><p>The simulation assumes a sequence of rectangular RF-pulses with varying flip angles α and RF-pulse durations TRF, but a fixed repetition time TR. Further, it assumes balanced gradient moments.</p><p><strong>Arguments</strong></p><ul><li><code>α::Vector{&lt;:Number}</code>: Array of flip angles in radians</li><li><code>TRF::Vector{&lt;:Number}</code>: Array of the RF-pulse durations in seconds</li><li><code>TR::Number</code>: Repetition time in seconds</li><li><code>ω0::Number</code>: Off-resonance frequency in rad/s</li><li><code>B1::Number</code>: Normalized transmit B1 field, i.e. B1 = 1 corresponds to a well-calibrated B1 field</li><li><code>m0s::Number</code>: Fractional size of the semi-solid pool; should be in range of 0 to 1</li><li><code>R1f::Number</code>: Longitudinal relaxation rate of the free pool in 1/seconds</li><li><code>R2f::Number</code>: Transversal relaxation rate of the free pool in 1/seconds</li><li><code>Rx::Number</code>: Exchange rate between the two spin pools in 1/seconds</li><li><code>R1s::Number</code>: Longitudinal relaxation rate of the semi-solid pool in 1/seconds</li><li><code>T2s::Number</code>: Transversal relaxation time of the semi-solid pool in seconds</li></ul><p>Optional:</p><ul><li><code>grad_list=[]</code>: Vector that specifies the gradients that are calculated; the vector can either be empty <code>[]</code> for no gradient, or contain any subset/order of <code>grad_list=[grad_m0s(), grad_R1s(), grad_R2f(), grad_Rx(), grad_R1s(), grad_T2s(), grad_ω0(), grad_B1()]</code>; the derivative wrt. to apparent <code>R1a = R1f = R1s</code> can be calculated with <code>grad_R1a()</code></li><li><code>Ncyc=2</code>: The magnetization is initialized with thermal equilibrium and then performed Ncyc times and only the last cycle is stored. The default value is usually a good approximation for antiperiodic boundary conditions. Increase the number for higher precision at the cost of computation time.</li><li><code>output=:complexsignal</code>: The default keywords triggers the function to output a complex-valued signal (<code>xf + 1im yf</code>); the keyword <code>output=:realmagnetization</code> triggers an output of the entire (real valued) vector <code>[xf, yf, zf, xs, zs]</code></li><li><code>greens=(greens_superlorentzian, dG_o_dT2s_x_T2s_superlorentzian)</code>: Tuple of a Greens function <code>G(κ) = G((t-τ)/T2s)</code> and its partial derivative wrt. T2s, multiplied by T2s <code>∂G((t-τ)/T2s)/∂T2s * T2s</code>. This package supplies the three Greens functions <code>greens=(greens_superlorentzian, dG_o_dT2s_x_T2s_superlorentzian)</code> (default), <code>greens=(greens_lorentzian, dG_o_dT2s_x_T2s_lorentzian)</code>, and <code>greens=(greens_gaussian, dG_o_dT2s_x_T2s_gaussian)</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; calculatesignal_gbloch_ide(ones(100)*π/2, ones(100)*5e-4, 4e-3, 0, 1, 0.2, 0.3, 15, 20, 2, 10e-6)
100×1 Matrix{ComplexF64}:
  -0.007966316445016917 + 0.0im
  0.0012590590419314762 - 0.0im
  -0.006088855588122765 + 0.0im
  0.0024187389404174905 - 0.0im
  -0.004361339395232529 + 0.0im
  0.0034891358210049914 - 0.0im
 -0.0027633710614652324 + 0.0im
   0.004483217941394411 - 0.0im
 -0.0012812573517353436 + 0.0im
   0.005408854034677167 - 0.0im
                        ⋮
   0.017760808273048677 - 0.0im
   0.017576118974646303 + 0.0im
   0.017813950945910262 - 0.0im
   0.017643856335506514 + 0.0im
   0.017863575855931582 - 0.0im
   0.017706926033852457 + 0.0im
   0.017909914934081783 - 0.0im
    0.01776565037329605 + 0.0im
    0.01795318489371729 - 0.0im

julia&gt; calculatesignal_gbloch_ide(ones(100)*π/2, ones(100)*5e-4, 4e-3, 0, 1, 0.2, 0.3, 15, 20, 2, 10e-6; grad_list=[grad_R1f(), grad_T2s()], output=:realmagnetization)
100×15 transpose(::Matrix{Float64}) with eltype Float64:
 -0.00796627   0.0   0.000637773  …   0.0   -10.8757  -335.26   0.0
  0.00125903  -0.0  -0.00700671      -0.0   125.882   -326.977  0.0
 -0.00608882   0.0   0.00185086       0.0   -30.4187  -317.56   0.0
  0.00241873  -0.0  -0.00520622      -0.0    96.1776  -309.906  0.0
 -0.00436133   0.0   0.00296471       0.0   -47.5803  -302.948  0.0
  0.003489    -0.0  -0.00354518   …  -0.0    69.5148  -298.697  0.0
 -0.00276366   0.0   0.00399588       0.0   -62.8453  -294.886  0.0
  0.00448273  -0.0  -0.00200673      -0.0    45.3179  -292.783  0.0
 -0.00128187   0.0   0.00495478       0.0   -76.6573  -290.321  0.0
  0.00540814  -0.0  -0.000578836     -0.0    23.1756  -289.245  0.0
  ⋮                               ⋱
  0.0177563   -0.0   0.0175372       -0.0  -290.779   -349.855  0.0
  0.0175716    0.0   0.0177845        0.0  -295.347   -350.002  0.0
  0.0178094   -0.0   0.0176073       -0.0  -292.44    -350.163  0.0
  0.0176393    0.0   0.0178359        0.0  -296.668   -350.3    0.0
  0.017859    -0.0   0.0176727    …  -0.0  -294.001   -350.451  0.0
  0.0177024    0.0   0.0178838        0.0  -297.914   -350.579  0.0
  0.0179053   -0.0   0.0177335       -0.0  -295.467   -350.72   0.0
  0.0177611    0.0   0.0179286        0.0  -299.09    -350.84   0.0
  0.0179486   -0.0   0.0177902       -0.0  -296.845   -350.972  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/ed30a12d9b12e0bb77da8a1d1088237cf10cc749/src/DiffEq_Sovlers.jl#L1-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIgeneralizedBloch.calculatesignal_graham_ode-NTuple{11, Any}" href="#MRIgeneralizedBloch.calculatesignal_graham_ode-NTuple{11, Any}"><code>MRIgeneralizedBloch.calculatesignal_graham_ode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculatesignal_graham_ode(α, TRF, TR, ω0, B1, m0s, R1f, R2f, Rx, R1s, T2s[; grad_list, Ncyc=2, output=:complexsignal])</code></pre><p>Calculate the signal or magnetization evolution with Graham&#39;s spectral model assuming a super-Lorentzian lineshape.</p><p>The simulation assumes a sequence of rectangular RF-pulses with varying flip angles α and RF-pulse durations TRF, but a fixed repetition time TR. Further, it assumes balanced gradient moments.</p><p><strong>Arguments</strong></p><ul><li><code>α::Vector{&lt;:Number}</code>: Array of flip angles in radians</li><li><code>TRF::Vector{&lt;:Number}</code>: Array of the RF-pulse durations in seconds</li><li><code>TR::Number</code>: Repetition time in seconds</li><li><code>ω0::Number</code>: Off-resonance frequency in rad/s</li><li><code>B1::Number</code>: Normalized transmit B1 field, i.e. B1 = 1 corresponds to a well-calibrated B1 field</li><li><code>m0s::Number</code>: Fractional size of the semi-solid pool; should be in range of 0 to 1</li><li><code>R1f::Number</code>: Longitudinal relaxation rate of the free pool in 1/seconds</li><li><code>R2f::Number</code>: Transversal relaxation rate of the free pool in 1/seconds</li><li><code>Rx::Number</code>: Exchange rate between the two spin pools in 1/seconds</li><li><code>R1s::Number</code>: Longitudinal relaxation rate of the semi-solid pool in 1/seconds</li><li><code>T2s::Number</code>: Transversal relaxation time of the semi-solid pool in seconds</li></ul><p>Optional:</p><ul><li><code>grad_list=[]</code>: Vector that specifies the gradients that are calculated; the vector can either be empty <code>[]</code> for no gradient, or contain any subset/order of <code>grad_list=[grad_m0s(), grad_R1f(), grad_R2f(), grad_Rx(), grad_R1s(), grad_T2s(), grad_ω0(), grad_B1(), grad_R1a()]</code></li><li><code>Ncyc=2</code>: The magnetization is initialized with thermal equilibrium and then performed Ncyc times and only the last cycle is stored. The default value is usually a good approximation for antiperiodic boundary conditions. Increase the number for higher precision at the cost of computation time.</li><li><code>output=:complexsignal</code>: The default keywords triggers the function to output a complex-valued signal (<code>xf + 1im yf</code>); the keyword <code>output=:realmagnetization</code> triggers an output of the entire (real valued) vector <code>[xf, yf, zf, xs, zs]</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; calculatesignal_graham_ode(ones(100)*π/2, ones(100)*5e-4, 4e-3, 0, 1, 0.2, 0.3, 15, 20, 2, 10e-6)
100×1 Matrix{ComplexF64}:
  -0.008073451191813547 + 0.0im
    0.00126864329048296 - 0.0im
  -0.006178694437239949 + 0.0im
   0.002435865817867096 - 0.0im
  -0.004437476277201384 + 0.0im
  0.0035164646498403165 - 0.0im
 -0.0028315542520438355 + 0.0im
   0.004523902250379148 - 0.0im
 -0.0013422299483389299 + 0.0im
   0.005454562034842184 - 0.0im
                        ⋮
   0.018148222040953982 - 0.0im
    0.01795769661414948 + 0.0im
    0.01820486087666198 - 0.0im
   0.018029363102618986 + 0.0im
   0.018257820142562945 - 0.0im
    0.01809616891246802 + 0.0im
   0.018307337729977703 - 0.0im
   0.018158444501177453 + 0.0im
   0.018353636229654635 - 0.0im

julia&gt; calculatesignal_graham_ode(ones(100)*π/2, ones(100)*5e-4, 4e-3, 0, 1, 0.2, 0.3, 15, 20, 2, 10e-6; grad_list=[grad_R1f(), grad_T2s()], output=:realmagnetization)
100×15 transpose(::Matrix{Float64}) with eltype Float64:
 -0.0080756    0.0   0.000643162  …   0.0   -10.4986  -323.634  0.0
  0.00126867  -0.0  -0.00710692      -0.0   123.078   -316.358  0.0
 -0.00618067   0.0   0.00186482       0.0   -29.4458  -307.862  0.0
  0.00243634  -0.0  -0.0052899       -0.0    94.1692  -300.821  0.0
 -0.00443746   0.0   0.00298646       0.0   -46.1422  -294.116  0.0
  0.00351386  -0.0  -0.00361718   …  -0.0    68.262   -289.421  0.0
 -0.00282882   0.0   0.00402793       0.0   -61.0236  -285.242  0.0
  0.00451808  -0.0  -0.00206741      -0.0    44.7888  -282.867  0.0
 -0.00133608   0.0   0.00499316       0.0   -74.4075  -280.79   0.0
  0.00544896  -0.0  -0.00062663      -0.0    23.2536  -280.148  0.0
  ⋮                               ⋱
  0.0181755   -0.0   0.0179431       -0.0  -285.071   -337.48   0.0
  0.0179911    0.0   0.0181963        0.0  -289.591   -337.634  0.0
  0.0182343   -0.0   0.018019        -0.0  -286.777   -337.804  0.0
  0.0180645    0.0   0.0182531        0.0  -290.964   -337.948  0.0
  0.0182893   -0.0   0.0180898    …  -0.0  -288.383   -338.106  0.0
  0.0181329    0.0   0.0183062        0.0  -292.261   -338.241  0.0
  0.0183407   -0.0   0.0181559       -0.0  -289.895   -338.39   0.0
  0.0181968    0.0   0.0183559        0.0  -293.488   -338.516  0.0
  0.0183888   -0.0   0.0182175       -0.0  -291.318   -338.656  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/ed30a12d9b12e0bb77da8a1d1088237cf10cc749/src/DiffEq_Sovlers.jl#L160-L233">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIgeneralizedBloch.calculatesignal_linearapprox-NTuple{12, Any}" href="#MRIgeneralizedBloch.calculatesignal_linearapprox-NTuple{12, Any}"><code>MRIgeneralizedBloch.calculatesignal_linearapprox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calculatesignal_linearapprox(α, TRF, TR, ω0, B1, m0s, R1f, R2f, Rx, R1s, T2s, R2slT[; grad_list=[undef], rfphase_increment=[π], m0=:periodic, output=:complexsignal, isInversionPulse = [true; falses(length(α)-1)]])</code></pre><p>Calculate the signal or magnetization evolution with the linear approximation of the generalized Bloch model assuming a super-Lorentzian lineshape.</p><p>The simulation assumes a sequence of rectangular RF-pulses with varying flip angles α and RF-pulse durations TRF, but a fixed repetition time TR. Further, it assumes balanced gradient moments.</p><p><strong>Arguments</strong></p><ul><li><code>α::Vector{&lt;:Number}</code>: Array of flip angles in radians</li><li><code>TRF::Vector{&lt;:Number}</code>: Array of the RF-pulse durations in seconds</li><li><code>TR::Number</code>: Repetition time in seconds</li><li><code>ω0::Number</code>: Off-resonance frequency in rad/s</li><li><code>B1::Number</code>: Normalized transmit B1 field, i.e. B1 = 1 corresponds to a well-calibrated B1 field</li><li><code>m0s::Number</code>: Fractional size of the semi-solid pool; should be in range of 0 to 1</li><li><code>R1f::Number</code>: Longitudinal relaxation rate of the free pool in 1/seconds</li><li><code>R2f::Number</code>: Transversal relaxation rate of the free pool in 1/seconds</li><li><code>Rx::Number</code>: Exchange rate between the two spin pools in 1/seconds</li><li><code>R1f::Number</code>: Longitudinal relaxation rate of the semi-solid pool in 1/seconds</li><li><code>T2s::Number</code>: Transversal relaxation time of the semi-solid pool in seconds</li><li><code>R2slT::NTuple{3, Function}</code>: Tuple of three functions: R2sl(TRF, ω1, B1, T2s), dR2sldB1(TRF, ω1, B1, T2s), and R2sldT2s(TRF, ω1, B1, T2s). Can be generated with <a href="#MRIgeneralizedBloch.precompute_R2sl-Tuple{}"><code>precompute_R2sl</code></a></li></ul><p>Optional:</p><ul><li><code>grad_list=[undef]</code>: Vector that specifies the gradients that are calculated; the vector elements can either be <code>undef</code> for no gradient, or any subset/order of <code>grad_list=[grad_m0s(), grad_R1f(), grad_R2f(), grad_Rx(), grad_R1s(), grad_T2s(), grad_ω0(), grad_B1()]</code>; the derivative wrt. to apparent <code>R1a = R1f = R1s</code> can be calculated with <code>grad_R1a()</code></li><li><code>rfphase_increment=[π]::Vector{&lt;:Number}</code>: Increment of the RF phase between consecutive pulses. The default value <code>π</code>, together with <span>$ω0=0$</span> corresponds to the on-resonance condition. When more than one value is supplied, their resulting signal is stored along the second dimension of the output array.</li><li><code>m0=:periodic</code>: With the default keyword <code>:periodic</code>, the signal and their derivatives are calculated assuming <span>$m(0) = -m(T)$</span>, where <code>T</code> is the duration of the RF-train. With the keyword :thermal, the magnetization <span>$m(0)$</span> is initialized with thermal equilibrium <code>[xf, yf, zf, xs, zs] = [0, 0, 1-m0s, 0, m0s]</code>, followed by a α[1]/2 - TR/2 prep pulse; and with the keyword <code>:IR</code>, this initialization is followed an inversion pulse of duration <code>TRF[1]</code>, (set <code>α[1]=π</code>) and a α[2]/2 - TR/2 prep pulse.</li><li><code>output=:complexsignal</code>: The default keywords triggers the function to output a complex-valued signal (<code>xf + 1im yf</code>); the keyword <code>output=:realmagnetization</code> triggers an output of the entire (real valued) vector <code>[xf, yf, zf, xs, zs]</code></li><li><code>isInversionPulse::Vector{Bool}</code>: Indicates all inversion pulses; must have the same length as α; the <code>default = [true; falses(length(α)-1)]</code> indicates that the first pulse is an inversion pulse and all others are not</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R2slT = precompute_R2sl();


julia&gt; calculatesignal_linearapprox(ones(100)*π/2, ones(100)*5e-4, 4e-3, 0, 1, 0.1, 1, 15, 30, 6.5, 10e-6, R2slT)
100×1×1 Array{ComplexF64, 3}:
[:, :, 1] =
  -0.029305987774458163 - 2.6090233074873602e-18im
   0.004329424678273618 - 9.228587093606358e-19im
  -0.022761409373843695 + 1.3684406715212817e-18im
   0.008280330224850314 - 3.913888063486213e-18im
  -0.016751305727868086 + 4.640955399485587e-18im
   0.011921649143708494 - 6.302663734240699e-18im
   -0.01119057989041819 + 7.310583447081545e-18im
   0.015305608440952356 - 8.175490153983926e-18im
 -0.0060267918180664974 + 9.464626759459644e-18im
   0.018463027499697613 - 9.608537136498027e-18im
                        ⋮
   0.061531473509660414 + 1.4962743251121995e-18im
    0.06081400768357244 + 5.6874647068595666e-18im
     0.0617257515931871 + 1.6576028430814591e-18im
   0.061064216222629225 + 5.55793788363693e-18im
     0.0619074570531536 + 1.8084438857930338e-18im
    0.06129750535994419 + 5.436837755621582e-18im
   0.062077399758002534 + 1.9493976022865502e-18im
   0.061515021919442275 + 5.323692528202896e-18im
    0.06223633770306246 + 2.0810405785134972e-18im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/ed30a12d9b12e0bb77da8a1d1088237cf10cc749/src/MatrixExp_Solvers.jl#L4-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIgeneralizedBloch.dG_o_dT2s_x_T2s_gaussian-Tuple{Any}" href="#MRIgeneralizedBloch.dG_o_dT2s_x_T2s_gaussian-Tuple{Any}"><code>MRIgeneralizedBloch.dG_o_dT2s_x_T2s_gaussian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dG_o_dT2s_x_T2s_gaussian(κ)</code></pre><p>Evaluate the derivative of Green&#39;s function, corresponding to a Gaussian lineshape, wrt. <code>T2s</code> at <code>κ = (t-τ)/T2s</code> and multiply it by <code>T2s</code>.</p><p>The multiplication is added so that the function merely depends on <code>κ = (t-τ)/T2s</code>. The actual derivative is given by <code>dG_o_dT2s_x_T2s_gaussian((t-τ)/T2s)/T2s</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; t = 100e-6;

julia&gt; τ = 0;

julia&gt; T2s = 10e-6;

julia&gt; dGdT2s = dG_o_dT2s_x_T2s_gaussian((t-τ)/T2s)/T2s
1.9287498479639177e-15</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/ed30a12d9b12e0bb77da8a1d1088237cf10cc749/src/Greens_functions.jl#L66-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIgeneralizedBloch.dG_o_dT2s_x_T2s_lorentzian-Tuple{Any}" href="#MRIgeneralizedBloch.dG_o_dT2s_x_T2s_lorentzian-Tuple{Any}"><code>MRIgeneralizedBloch.dG_o_dT2s_x_T2s_lorentzian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dG_o_dT2s_x_T2s_lorentzian(κ)</code></pre><p>Evaluate the derivative of Green&#39;s function, corresponding to a Lorentzian lineshape, wrt. <code>T2s</code> at <code>κ = (t-τ)/T2s</code> and multiply it by <code>T2s</code>.</p><p>The multiplication is added so that the function merely depends on <code>κ = (t-τ)/T2s</code>. The actual derivative is given by <code>dG_o_dT2s_x_T2s_lorentzian((t-τ)/T2s)/T2s</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; t = 100e-6;

julia&gt; τ = 0;

julia&gt; T2s = 10e-6;

julia&gt; dGdT2s = dG_o_dT2s_x_T2s_lorentzian((t-τ)/T2s)/T2s
45.39992976248485</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/ed30a12d9b12e0bb77da8a1d1088237cf10cc749/src/Greens_functions.jl#L22-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIgeneralizedBloch.dG_o_dT2s_x_T2s_superlorentzian-Tuple{Any}" href="#MRIgeneralizedBloch.dG_o_dT2s_x_T2s_superlorentzian-Tuple{Any}"><code>MRIgeneralizedBloch.dG_o_dT2s_x_T2s_superlorentzian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dG_o_dT2s_x_T2s_superlorentzian(κ)</code></pre><p>Evaluate the derivative of Green&#39;s function, corresponding to a super-Lorentzian lineshape, wrt. <code>T2s</code> at <code>κ = (t-τ)/T2s</code> and multiply it by <code>T2s</code>.</p><p>The multiplication is added so that the function merely depends on <code>κ = (t-τ)/T2s</code>. The actual derivative is given by <code>dG_o_dT2s_x_T2s_superlorentzian((t-τ)/T2s)/T2s</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; t = 100e-6;

julia&gt; τ = 0;

julia&gt; T2s = 10e-6;

julia&gt; dGdT2s = dG_o_dT2s_x_T2s_superlorentzian((t-τ)/T2s)/T2s
15253.095033670965</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/ed30a12d9b12e0bb77da8a1d1088237cf10cc749/src/Greens_functions.jl#L110-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIgeneralizedBloch.fit_gBloch-NTuple{4, Any}" href="#MRIgeneralizedBloch.fit_gBloch-NTuple{4, Any}"><code>MRIgeneralizedBloch.fit_gBloch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">qM = fit_gBloch(data, α, TRF, TR;
    reM0 = (-Inf,   1,  Inf),
    imM0 = (-Inf,   0,  Inf),
    m0s  = (   0, 0.2,    1),
    R1f  = (   0, 0.3,  Inf),
    R2f  = (   0,  15,  Inf),
    Rx   = (   0,  20,  Inf),
    R1s  = (   0,   3,  Inf),
    T2s  = (8e-6,1e-5,12e-6),
    ω0   = (-Inf,   0,  Inf),
    B1   = (   0,   1,  1.5),
    R1a  = (   0, 0.7,  Inf),
    u=1,
    fit_apparentR1=false,
    show_trace=false,
    maxIter=100,
    R2slT = precompute_R2sl(TRF_min=minimum(TRF), TRF_max=maximum(TRF), T2s_min=minimum(T2s), T2s_max=maximum(T2s), ω1_max=maximum(α ./ TRF), B1_max=maximum(B1)),
    )</code></pre><p>Fit the generalized Bloch model for a train of RF pulses and balanced gradient moments to <code>data</code>.</p><p><strong>Arguments</strong></p><ul><li><code>data::Vector{&lt;:Number}</code>: Array of measured data points, either in the time or a compressed domain (cf. <code>u</code>)</li><li><code>α::Vector{&lt;:Number}</code>: Array of flip angles in radians</li><li><code>TRF::Vector{&lt;:Number}</code>: Array of the RF-pulse durations in seconds</li><li><code>TR::Number</code>: Repetition time in seconds</li><li><code>ω0::Number</code>: Off-resonance frequency in rad/s</li></ul><p><strong>Optional Keyword Arguments:</strong></p><ul><li><code>reM0::Union{Number, Tuple{Number, Number, Number}}</code>: Real part of <code>M0</code>; either fixed value as a <code>Number</code> or fit limits thereof as a <code>Tuple</code> with the elements <code>(min, start, max)</code></li><li><code>imM0::Union{Number, Tuple{Number, Number, Number}}</code>: Imaginary part of <code>M0</code>; either fixed value as a <code>Number</code> or fit limits thereof as a <code>Tuple</code> with the elements <code>(min, start, max)</code></li><li><code>m0s::Union{Number, Tuple{Number, Number, Number}}</code>: Fractional size of the semi-solid pool (should be in range of 0 to 1); either fixed value as a <code>Number</code> or fit limits thereof as a <code>Tuple</code> with the elements <code>(min, start, max)</code></li><li><code>R1f::Union{Number, Tuple{Number, Number, Number}}</code>: Longitudinal relaxation rate of the free pool in 1/s; only used in combination with <code>fit_apparentR1=false</code>; either fixed value as a <code>Number</code> or fit limits thereof as a <code>Tuple</code> with the elements <code>(min, start, max)</code></li><li><code>R2f::Union{Number, Tuple{Number, Number, Number}}</code>: Transversal relaxation rate of the free pool in 1/s; either fixed value as a <code>Number</code> or fit limits thereof as a <code>Tuple</code> with the elements <code>(min, start, max)</code></li><li><code>Rx::Union{Number, Tuple{Number, Number, Number}}</code>: Exchange rate between the two spin pools in 1/s; either fixed value as a <code>Number</code> or fit limits thereof as a <code>Tuple</code> with the elements <code>(min, start, max)</code></li><li><code>R1s::Union{Number, Tuple{Number, Number, Number}}</code>: Longitudinal relaxation rate of the semi-solid pool in 1/s; only used in combination with <code>fit_apparentR1=false</code>; either fixed value as a <code>Number</code> or fit limits thereof as a <code>Tuple</code> with the elements <code>(min, start, max)</code></li><li><code>T2s::Union{Number, Tuple{Number, Number, Number}}</code>: Transversal relaxation time of the semi-solid pool in s; either fixed value as a <code>Number</code> or fit limits thereof as a <code>Tuple</code> with the elements <code>(min, start, max)</code></li><li><code>ω0::Union{Number, Tuple{Number, Number, Number}}</code>: Off-resonance frequency in rad/s; either fixed value as a <code>Number</code> or fit limits thereof as a <code>Tuple</code> with the elements <code>(min, start, max)</code></li><li><code>B1::Union{Number, Tuple{Number, Number, Number}}</code>: Normalized transmit B1 field, i.e. B1 = 1 corresponds to a well-calibrated B1 field; either fixed value as a <code>Number</code> or fit limits thereof as a <code>Tuple</code> with the elements <code>(min, start, max)</code></li><li><code>R1a::Union{Number, Tuple{Number, Number, Number}}</code>: Apparent longitudinal relaxation rate in 1/s; only used in combination with <code>fit_apparentR1=true</code>; either fixed value as a <code>Number</code> or fit limits thereof as a <code>Tuple</code> with the elements <code>(min, start, max)</code></li><li><code>u::Union{Number, Matrix}</code>: Compression matrix that transform the simulated time series to a series of coefficients. Set to <code>1</code> by default to enable the fitting in the time domain</li><li><code>fit_apparentR1::Bool</code>: Switch between fitting <code>R1f</code> and <code>R1s</code> separately (<code>false</code>; default) and an apparent <code>R1a = R1f = R1s</code> (<code>true</code>)</li><li><code>show_trace::Bool</code>: print output during the optimization; <code>default=false</code></li><li><code>maxIter::Int</code>: Maximum number of iteration; <code>default=100</code></li><li><code>R2slT::NTuple{3, Function}</code>: Tuple of three functions: R2sl(TRF, ω1, B1, T2s), dR2sldB1(TRF, ω1, B1, T2s), and R2sldT2s(TRF, ω1, B1, T2s). By default generated with <a href="#MRIgeneralizedBloch.precompute_R2sl-Tuple{}"><code>precompute_R2sl</code></a></li></ul><p><strong>Examples</strong></p><p>c.f. <a href="../build_literate/NLLS/#Non-Linear-Least-Square-Fitting">Non-Linear Least Square Fitting</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/ed30a12d9b12e0bb77da8a1d1088237cf10cc749/src/NLLSFit.jl#L2-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIgeneralizedBloch.get_bounded_ω1_TRF-Tuple{Any}" href="#MRIgeneralizedBloch.get_bounded_ω1_TRF-Tuple{Any}"><code>MRIgeneralizedBloch.get_bounded_ω1_TRF</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ω1, TRF = get_bounded_ω1_TRF(x; ω1_min = 0, ω1_max = 2e3π, TRF_min = 100e-6, TRF_max = 500e-6)</code></pre><p>Transform a vector of length <code>2Npulses</code> with values in the range <code>[-Inf, Inf]</code> into two vectors of length <code>Npulses</code>, which describe the bounded controls <code>ω1</code> and <code>TRF</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x::Vector{&lt;:Number}</code>: Control vector of <code>length = 2Npulses</code> with values in the range <code>[-Inf, Inf]</code></li></ul><p><strong>Optional Keyword Arguments:</strong></p><ul><li><code>ω1_min::Number</code>: lower bound for ω1 in rad/s</li><li><code>ω1_max::Number</code>: upper bound for ω1 in rad/s</li><li><code>TRF_min::Number</code>: lower bound for TRF in s</li><li><code>TRF_max::Number</code>: upper bound for TRF in s</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; x = 1000 * randn(2 * 100);

julia&gt; ω1, TRF = MRIgeneralizedBloch.get_bounded_ω1_TRF(x)
([6283.185307179586, 0.0, 6283.185307179586, 0.0, 6283.185307179586, 0.0, 6283.185307179586, 0.0, 6283.185307179586, 6283.185307179586  …  6283.185307179586, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 6283.185307179586, 0.0, 0.0], [0.0005, 0.0005, 0.0005, 0.0001, 0.0005, 0.0001, 0.0001, 0.0005, 0.0005, 0.0005  …  0.0001, 0.0001, 0.0005, 0.0005, 0.0001, 0.0005, 0.0001, 0.0005, 0.0001, 0.0001])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/ed30a12d9b12e0bb77da8a1d1088237cf10cc749/src/OptimalControlHelpers.jl#L4-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIgeneralizedBloch.greens_gaussian-Tuple{Any}" href="#MRIgeneralizedBloch.greens_gaussian-Tuple{Any}"><code>MRIgeneralizedBloch.greens_gaussian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">greens_gaussian(κ)</code></pre><p>Evaluate the Green&#39;s function corresponding to a Gaussian lineshape at <code>κ = (t-τ)/T2s</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; t = 100e-6;

julia&gt; τ = 0;

julia&gt; T2s = 10e-6;

julia&gt; greens_gaussian((t-τ)/T2s)
1.9287498479639178e-22</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/ed30a12d9b12e0bb77da8a1d1088237cf10cc749/src/Greens_functions.jl#L45-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIgeneralizedBloch.greens_lorentzian-Tuple{Any}" href="#MRIgeneralizedBloch.greens_lorentzian-Tuple{Any}"><code>MRIgeneralizedBloch.greens_lorentzian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">greens_lorentzian(κ)</code></pre><p>Evaluate the Green&#39;s function corresponding to a Lorentzian lineshape at <code>κ = (t-τ)/T2s</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; t = 100e-6;

julia&gt; τ = 0;

julia&gt; T2s = 10e-6;

julia&gt; greens_lorentzian((t-τ)/T2s)
4.5399929762484854e-5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/ed30a12d9b12e0bb77da8a1d1088237cf10cc749/src/Greens_functions.jl#L1-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIgeneralizedBloch.greens_superlorentzian-Tuple{Any}" href="#MRIgeneralizedBloch.greens_superlorentzian-Tuple{Any}"><code>MRIgeneralizedBloch.greens_superlorentzian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">greens_superlorentzian(κ)</code></pre><p>Evaluate the Green&#39;s function corresponding to a super-Lorentzian lineshape at <code>κ = (t-τ)/T2s</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; t = 100e-6;

julia&gt; τ = 0;

julia&gt; T2s = 10e-6;

julia&gt; greens_superlorentzian((t-τ)/T2s)
0.1471246868094442</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/ed30a12d9b12e0bb77da8a1d1088237cf10cc749/src/Greens_functions.jl#L89-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIgeneralizedBloch.hamiltonian_linear-NTuple{10, Any}" href="#MRIgeneralizedBloch.hamiltonian_linear-NTuple{10, Any}"><code>MRIgeneralizedBloch.hamiltonian_linear</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hamiltonian_linear(ω1, B1, ω0, T, m0s, R1f, R2f, Rx, R1s, R2s[, dR2sdT2s, dR2sdB1, grad_type])</code></pre><p>Calculate the hamiltonian of the linear approximation of the generalized Bloch model.</p><p>If no gradient is supplied, it returns a 6x6 (static) matrix with the dimensions (in this order) <code>[xf, yf, zf, xs, zs, 1]</code>; the attached 1 is a mathematical trick to allow for <span>$T_1$</span> relaxation to a non-zero thermal equilibrium. If a gradient is supplied, it returns a 11x11 (static) matrix with the dimensions (in this order) <code>[xf, yf, zf, xs, zs, dxf/dθ, dyf/dθ, dzf/dθ, dxs/dθ, dzs/dθ,  1]</code>, where <code>θ</code> is the parameter specified by <code>grad_type</code></p><p><strong>Arguments</strong></p><ul><li><code>ω1::Number</code>: Rabi frequency in rad/s (rotation about the y-axis)</li><li><code>B1::Number</code>: Normalized transmit B1 field, i.e. B1 = 1 corresponds to a well-calibrated B1 field</li><li><code>ω0::Number</code>: Larmor (or off-resonance) frequency in rad/s (rotation about the z-axis)</li><li><code>T::Number</code>: Time in seconds; this can, e.g., be the RF-pulse duration, or the time of free precession with <code>ω1=0</code></li><li><code>m0s::Number</code>: Fractional size of the semi-solid pool; should be in range of 0 to 1</li><li><code>R1f::Number</code>: Longitudinal relaxation rate of the free pool in 1/seconds</li><li><code>R2f::Number</code>: Transversal relaxation rate of the free pool in 1/seconds</li><li><code>Rx::Number</code>: Exchange rate between the two spin pools in 1/seconds</li><li><code>R1s::Number</code>: Longitudinal relaxation rate of the semi-solid pool in 1/seconds</li><li><code>R2s::Number</code>: Transversal relaxation rate of the semi-solid pool in 1/seconds; this number can be calculated with the first function returned by <a href="#MRIgeneralizedBloch.precompute_R2sl-Tuple{}"><code>precompute_R2sl</code></a> to implement the linear approximation described in the generalized Bloch paper</li></ul><p>Optional:</p><ul><li><code>dR2sdT2s::Number</code>: Derivative of linearized R2sl wrt. the actual T2s; only required if <code>grad_type = grad_T2s()</code>; this number can be calculated with the second function returned by <a href="#MRIgeneralizedBloch.precompute_R2sl-Tuple{}"><code>precompute_R2sl</code></a></li><li><code>dR2sdB1::Number</code>: Derivative of linearized R2sl wrt. B1; only required if <code>grad_type = grad_B1()</code>; this number can be calculated with the third function returned by <a href="#MRIgeneralizedBloch.precompute_R2sl-Tuple{}"><code>precompute_R2sl</code></a></li><li><code>grad_type::grad_param</code>: <code>grad_m0s()</code>, <code>grad_R1f()</code>, <code>grad_R1s()</code>, <code>grad_R2f()</code>, <code>grad_Rx()</code>, <code>grad_T2s()</code>, <code>grad_ω0()</code>, or <code>grad_B1()</code>; create one hamiltonian for each desired gradient</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; α = π;

julia&gt; T = 500e-6;

julia&gt; ω1 = α/T;

julia&gt; B1 = 1;

julia&gt; ω0 = 0;

julia&gt; m0s = 0.1;

julia&gt; R1f = 1;

julia&gt; R2f = 15;

julia&gt; Rx = 30;

julia&gt; R1s = 6.5;

julia&gt; R2s = 1e5;

julia&gt; m0 = [0, 0, 1-m0s, 0, m0s, 1];

julia&gt; (xf, yf, zf, xs, zs, _) = exp(hamiltonian_linear(ω1, B1, ω0, T, m0s, R1f, R2f, Rx, R1s, R2s)) * m0
6-element StaticArrays.SVector{6, Float64} with indices SOneTo(6):
  0.0010647535813058293
  0.0
 -0.8957848274535014
  0.005126529591877105
  0.08122007142111888
  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/ed30a12d9b12e0bb77da8a1d1088237cf10cc749/src/MatrixExp_Hamiltonians.jl#L2-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIgeneralizedBloch.interpolate_greens_function-Tuple{Any, Any, Any}" href="#MRIgeneralizedBloch.interpolate_greens_function-Tuple{Any, Any, Any}"><code>MRIgeneralizedBloch.interpolate_greens_function</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">interpolate_greens_function(f, κmin, κmax)</code></pre><p>Interpolate the Green&#39;s function f in the range between κmin and κmax.</p><p>The interpolation uses the ApproxFun.jl package that incorporates Chebyshev polynomials and ensures an approximation to machine precision. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; t = 100e-6;

julia&gt; τ = 0;

julia&gt; T2s = 10e-6;

julia&gt; greens_superlorentzian((t-τ)/T2s)
0.1471246868094442

julia&gt; Gint = interpolate_greens_function(greens_superlorentzian, 0, 20);


julia&gt; Gint((t-τ)/T2s)
0.14712468680944407</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/ed30a12d9b12e0bb77da8a1d1088237cf10cc749/src/Greens_functions.jl#L134-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIgeneralizedBloch.precompute_R2sl-Tuple{}" href="#MRIgeneralizedBloch.precompute_R2sl-Tuple{}"><code>MRIgeneralizedBloch.precompute_R2sl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">precompute_R2sl([;TRF_min=100e-6, TRF_max=500e-6, T2s_min=5e-6, T2s_max=21e-6, ω1_max=π/TRF_max, B1_max=1.5, greens=greens_superlorentzian])</code></pre><p>Pre-compute and interpolate the linearized <code>R2sl(TRF, α, B1, T2s)</code> and its derivatives <code>dR2sldB1(TRF, α, B1, T2s)</code>, <code>R2sldT2s(TRF, α, B1, T2s)</code> etc. in the range specified by the arguments.</p><p>The function solves the generalized Bloch equations of an isolated semi-solid pool for values in the specified range, calculates the linearized R2sl that minimizes the error of <code>zs</code> at the end of the RF-pulse, and interpolates between the different samples.</p><p><strong>Optional Arguments:</strong></p><ul><li><code>TRF_min::Number</code>: lower bound of the RF-pulse duration range in seconds</li><li><code>TRF_max::Number</code>: upper bound of the RF-pulse duration range in seconds</li><li><code>T2s_min::Number</code>: lower bound of the <code>T2s</code> range in seconds</li><li><code>T2s_max::Number</code>: upper bound of the <code>T2s</code> range in seconds</li><li><code>ω1_max::Number</code>: upper bound of the Rabi frequency ω1, the default is the frequency of a 500μs long π-pulse</li><li><code>B1_max::Number</code>: upper bound of the B1 range, normalized so that <code>B1 = 1</code> corresponds to a perfectly calibrated RF field</li><li><code>greens=greens_superlorentzian</code>: Greens function in the form <code>G(κ) = G((t-τ)/T2s)</code>. This package supplies the three Greens functions <code>greens=greens_superlorentzian</code> (default), <code>greens=greens_lorentzian</code>, and <code>greens=greens_gaussian</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; R2slT = precompute_R2sl();


julia&gt; R2sl, dR2sldB1, R2sldT2s, _ = precompute_R2sl(TRF_min=100e-6, TRF_max=500e-6, T2s_min=5e-6, T2s_max=15e-6, ω1_max=π/500e-6, B1_max=1.3, greens=greens_gaussian);
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/ed30a12d9b12e0bb77da8a1d1088237cf10cc749/src/Linearized_R2s.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MRIgeneralizedBloch.second_order_α!-NTuple{4, Any}" href="#MRIgeneralizedBloch.second_order_α!-NTuple{4, Any}"><code>MRIgeneralizedBloch.second_order_α!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">F = second_order_α!(grad_ω1, grad_TRF, ω1, TRF; λ = 1)</code></pre><p>Calculate second order penalty of variations of the flip angle α and over-write the gradients in place.</p><p><strong>Arguments</strong></p><ul><li><code>grad_ω1::Vector{&lt;:Number}</code>: Gradient of control, which will be over-written in place</li><li><code>grad_TRF::Vector{&lt;:Number}</code>: Gradient of control, which will be over-written in place</li><li><code>ω1::Vector{&lt;:Number}</code>: Control vector</li><li><code>TRF::Vector{&lt;:Number}</code>: Control vector</li></ul><p><strong>Optional Keyword Arguments:</strong></p><ul><li><code>λ::Number</code>: regularization parameter</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ω1 = 4000π * rand(100);

julia&gt; TRF = 500e-6 * rand(100);

julia&gt; grad_ω1 = similar(ω1);

julia&gt; grad_TRF = similar(ω1);

julia&gt; F = MRIgeneralizedBloch.second_order_α!(grad_ω1, grad_TRF, ω1, TRF; λ = 1e-3)
0.3394498406831758</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JakobAsslaender/MRIgeneralizedBloch.jl/blob/ed30a12d9b12e0bb77da8a1d1088237cf10cc749/src/OptimalControlHelpers.jl#L178-L205">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../build_literate/Linear_Approximation/">« Linear Approximation</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.21 on <span class="colophon-date" title="Tuesday 19 July 2022 10:40">Tuesday 19 July 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
